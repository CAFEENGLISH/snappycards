<!DOCTYPE html>
<html>
<head>
    <title>K√©nyszer√≠tett T√∂rl√©s √©s Friss√≠t√©s</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        .section { background: white; margin: 15px 0; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .error { background: #fff5f5; border: 2px solid #dc3545; }
        .success { background: #f8fff8; border: 2px solid #28a745; }
        .warning { background: #fffef0; border: 2px solid #ffc107; }
        .info { background: #f0f8ff; border: 2px solid #007bff; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 12px; max-height: 200px; overflow-y: auto; }
        button { padding: 15px 30px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 10px; font-weight: bold; font-size: 16px; }
        .delete-btn { background: #dc3545; }
        .success-btn { background: #28a745; }
        .warning-btn { background: #ffc107; color: #000; }
        h2 { color: #333; }
        .count { font-size: 24px; font-weight: bold; color: #dc3545; }
        .live-count { font-size: 32px; font-weight: bold; color: #28a745; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>üö® K√©nyszer√≠tett T√∂rl√©s √©s Val√≥s Idej≈± Friss√≠t√©s</h1>
    
    <div class="section info">
        <h2>üìä Val√≥s idej≈± sz√°ml√°l√≥k</h2>
        <div class="live-count" id="liveCount">Bet√∂lt√©s...</div>
        <button onclick="refreshCount()" class="success-btn">üîÑ Sz√°ml√°l√≥ friss√≠t√©s</button>
        <button onclick="clearAllNow()" class="delete-btn">üí• AZONNALI T√ñRL√âS</button>
        <button onclick="nukeDashboard()" class="warning-btn">‚ò¢Ô∏è DASHBOARD CACHE NUKE</button>
    </div>

    <div id="logContainer"></div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        const SUPABASE_URL = 'https://ycxqxdhaxehspypqbnpi.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InljeHF4ZGhheGVoc3B5cHFibnBpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMyMDMwMzEsImV4cCI6MjA2ODc3OTAzMX0.7RGVld6WOhNgeTA6xQc_U_eDXfMGzIshUlKV6j2Ru6g';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        function log(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
            container.innerHTML += `
                <div class="section ${className}">
                    <strong>${timestamp}</strong> - ${message}
                </div>
            `;
            container.scrollTop = container.scrollHeight;
        }
        
        async function refreshCount() {
            try {
                const { data: sets, error } = await supabase
                    .from('flashcard_sets')
                    .select('id, title')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    document.getElementById('liveCount').innerHTML = `‚ùå HIBA: ${error.message}`;
                    log(`‚ùå Sz√°ml√°l√≥ hiba: ${error.message}`, 'error');
                    return;
                }
                
                const nonCNN = sets.filter(set => !set.title || !set.title.toLowerCase().includes('cnn'));
                const cnn = sets.filter(set => set.title && set.title.toLowerCase().includes('cnn'));
                
                document.getElementById('liveCount').innerHTML = `
                    üìä √ñSSZES SZETT: ${sets.length} db<br>
                    üéØ CNN szettek: ${cnn.length} db<br>
                    üóëÔ∏è T√ñRLEND≈ê: ${nonCNN.length} db
                `;
                
                if (nonCNN.length > 0) {
                    log(`üóëÔ∏è T√ñRLEND≈ê SZETTEK (${nonCNN.length} db):<pre>${JSON.stringify(nonCNN, null, 2)}</pre>`, 'warning');
                } else {
                    log(`‚úÖ TISZTA! Nincsenek t√∂rlend≈ë szettek!`, 'success');
                }
                
                if (cnn.length > 0) {
                    log(`üéØ CNN SZETTEK (${cnn.length} db):<pre>${JSON.stringify(cnn, null, 2)}</pre>`, 'info');
                }
                
            } catch (error) {
                log(`‚ùå Sz√°ml√°l√≥ hiba: ${error.message}`, 'error');
            }
        }
        
        async function clearAllNow() {
            if (!confirm('üö® VESZ√âLYES! Minden nem-CNN szett t√∂rl√©se!\n\nFOLYTATOD?')) return;
            
            log('üí• AZONNALI T√ñRL√âS KEZDETE...', 'warning');
            
            try {
                // 1. Get current sets
                const { data: beforeSets, error: beforeError } = await supabase
                    .from('flashcard_sets')
                    .select('*');
                
                if (beforeError) {
                    log(`‚ùå El≈ëz≈ë √°llapot lek√©r√©s hiba: ${beforeError.message}`, 'error');
                    return;
                }
                
                const toDelete = beforeSets.filter(set => !set.title || !set.title.toLowerCase().includes('cnn'));
                log(`üéØ T√ñRL√âS EL≈êTT: ${beforeSets.length} szett √∂sszesen, ${toDelete.length} t√∂r√∂lni kell`, 'info');
                
                // 2. Delete each set with full logging
                for (let i = 0; i < toDelete.length; i++) {
                    const set = toDelete[i];
                    log(`üóëÔ∏è [${i+1}/${toDelete.length}] T√∂rl√©s: ${set.title} (${set.id})`, 'warning');
                    
                    try {
                        // Get connections first
                        const { data: connections } = await supabase
                            .from('flashcard_set_cards')
                            .select('card_id')
                            .eq('set_id', set.id);
                        
                        // Delete progress
                        if (connections && connections.length > 0) {
                            const cardIds = connections.map(c => c.card_id);
                            await supabase.from('user_card_progress').delete().in('card_id', cardIds);
                            log(`   üìà Progress t√∂r√∂lve: ${cardIds.length} k√°rtya`, 'info');
                        }
                        
                        // Delete connections
                        await supabase.from('flashcard_set_cards').delete().eq('set_id', set.id);
                        log(`   üîó Kapcsolatok t√∂r√∂lve`, 'info');
                        
                        // Delete categories
                        await supabase.from('flashcard_set_categories').delete().eq('set_id', set.id);
                        log(`   üè∑Ô∏è Kateg√≥ri√°k t√∂r√∂lve`, 'info');
                        
                        // Delete set
                        const { data: deletedSet, error: deleteError } = await supabase
                            .from('flashcard_sets')
                            .delete()
                            .eq('id', set.id)
                            .select();
                        
                        if (deleteError) {
                            log(`   ‚ùå SZETT T√ñRL√âSI HIBA: ${deleteError.message}`, 'error');
                        } else if (deletedSet && deletedSet.length > 0) {
                            log(`   ‚úÖ SZETT T√ñR√ñLVE: ${deletedSet[0].title}`, 'success');
                        } else {
                            log(`   ‚ö†Ô∏è Szett nem tal√°lhat√≥ vagy m√°r t√∂r√∂lve`, 'warning');
                        }
                        
                    } catch (setError) {
                        log(`   ‚ùå Szett t√∂rl√©si hiba: ${setError.message}`, 'error');
                    }
                    
                    // Update count after each deletion
                    await refreshCount();
                    await new Promise(resolve => setTimeout(resolve, 500)); // Wait between deletions
                }
                
                // 3. Final verification
                log('üîç V√âGELLEN≈êRZ√âS...', 'info');
                const { data: afterSets, error: afterError } = await supabase
                    .from('flashcard_sets')
                    .select('*');
                
                if (afterError) {
                    log(`‚ùå Ut√≥lagos ellen≈ërz√©s hiba: ${afterError.message}`, 'error');
                } else {
                    const remaining = afterSets.filter(set => !set.title || !set.title.toLowerCase().includes('cnn'));
                    if (remaining.length === 0) {
                        log(`üéâ SIKER! Minden nemk√≠v√°nt szett t√∂r√∂lve! Maradt: ${afterSets.length} szett (csak CNN)`, 'success');
                    } else {
                        log(`‚ö†Ô∏è M√©g ${remaining.length} szett maradt:<pre>${JSON.stringify(remaining, null, 2)}</pre>`, 'warning');
                    }
                }
                
                await refreshCount();
                
            } catch (error) {
                log(`‚ùå T√∂rl√©si hiba: ${error.message}`, 'error');
            }
        }
        
        async function nukeDashboard() {
            log('‚ò¢Ô∏è DASHBOARD CACHE NUKE KEZDETE...', 'warning');
            
            // Clear all browser storage
            localStorage.clear();
            sessionStorage.clear();
            
            // Clear all caches
            if ('caches' in window) {
                const cacheNames = await caches.keys();
                for (const name of cacheNames) {
                    await caches.delete(name);
                    log(`üí• Cache t√∂r√∂lve: ${name}`, 'info');
                }
            }
            
            // Force reload Supabase connection
            window.location.reload(true);
        }
        
        // Auto-refresh every 3 seconds
        setInterval(refreshCount, 3000);
        
        // Initial load
        refreshCount();
    </script>
</body>
</html>
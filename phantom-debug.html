<!DOCTYPE html>
<html>
<head>
    <title>Fantom Szettek Debug</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #000; color: #00ff00; }
        .debug { background: #111; padding: 15px; margin: 10px 0; border-radius: 8px; border: 1px solid #333; }
        .error { border-color: #ff0000; background: #330000; color: #ff6666; }
        .success { border-color: #00ff00; background: #003300; color: #66ff66; }
        .warning { border-color: #ffaa00; background: #332200; color: #ffcc66; }
        .info { border-color: #0066ff; background: #000033; color: #6699ff; }
        
        pre { background: #222; padding: 10px; border-radius: 5px; font-size: 11px; overflow-x: auto; max-height: 200px; overflow-y: auto; }
        button { padding: 15px 25px; font-size: 16px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; margin: 10px; }
        .test-btn { background: #0066ff; color: white; }
        .force-btn { background: #ff0000; color: white; }
        .auth-btn { background: #00aa00; color: white; }
        
        h1 { text-align: center; color: #ff0000; text-transform: uppercase; }
        h2 { color: #00ff00; }
    </style>
</head>
<body>
    <h1>üëª FANTOM SZETTEK DEBUGGER</h1>
    
    <div style="text-align: center;">
        <button onclick="loginUser()" class="auth-btn">üîë BEJELENTKEZ√âS</button>
        <button onclick="debugAuth()" class="auth-btn">üë§ AUTH TESZT</button>
        <button onclick="debugRLS()" class="test-btn">üîí RLS TESZT</button>
        <button onclick="directDelete()" class="force-btn">üíÄ DIRECT DELETE</button>
        <button onclick="sqlHack()" class="force-btn">‚ö° SQL HACK</button>
        <button onclick="ownershipFix()" class="auth-btn">üëë OWNERSHIP FIX</button>
        <button onclick="superDebug()" class="force-btn">üî¨ SUPER DEBUG</button>
    </div>
    
    <div id="loginForm" style="background: #333; padding: 20px; margin: 20px auto; max-width: 400px; border-radius: 10px; display: none;">
        <h3 style="color: #00ff00; text-align: center;">üîë Bejelentkez√©s</h3>
        <input type="email" id="loginEmail" placeholder="Email c√≠m" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #666; background: #222; color: #fff; border-radius: 5px;">
        <input type="password" id="loginPassword" placeholder="Jelsz√≥" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #666; background: #222; color: #fff; border-radius: 5px;">
        <button onclick="performLogin()" style="width: 100%; padding: 12px; background: #00aa00; color: white; border: none; border-radius: 5px; font-weight: bold;">BEJELENTKEZ√âS</button>
    </div>
    
    <div id="results"></div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        const SUPABASE_URL = 'https://ycxqxdhaxehspypqbnpi.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InljeHF4ZGhheGVoc3B5cHFibnBpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMyMDMwMzEsImV4cCI6MjA2ODc3OTAzMX0.7RGVld6WOhNgeTA6xQc_U_eDXfMGzIshUlKV6j2Ru6g';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        const TARGET_SETS = [
            "11111111-1111-1111-1111-111111111111",
            "22222222-2222-2222-2222-222222222222", 
            "33333333-3333-3333-3333-333333333333",
            "44444444-4444-4444-4444-444444444444",
            "55555555-5555-5555-5555-555555555555"
        ];
        
        function log(title, content, type = 'info') {
            const results = document.getElementById('results');
            const timestamp = new Date().toLocaleTimeString();
            results.innerHTML += `
                <div class="debug ${type}">
                    <h3>[${timestamp}] ${title}</h3>
                    ${content}
                </div>
            `;
            results.scrollTop = results.scrollHeight;
            console.log(`${title}: ${content.replace(/<[^>]*>/g, '')}`);
        }
        
        function loginUser() {
            const loginForm = document.getElementById('loginForm');
            if (loginForm.style.display === 'none') {
                loginForm.style.display = 'block';
                document.getElementById('loginEmail').value = 'vidamkos@gmail.com'; // Auto-fill known email
                log('üîë BEJELENTKEZ√âSI FORM', 'Bejelentkez√©si form megnyitva. Email el≈ëre kit√∂ltve.', 'info');
            } else {
                loginForm.style.display = 'none';
            }
        }
        
        async function performLogin() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                log('‚ùå HI√ÅNYZ√ì ADATOK', 'Email √©s jelsz√≥ megad√°sa k√∂telez≈ë!', 'error');
                return;
            }
            
            log('üîë BEJELENTKEZ√âS FOLYAMATBAN', `Email: ${email}`, 'info');
            
            try {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password
                });
                
                if (error) {
                    log('‚ùå BEJELENTKEZ√âSI HIBA', `
                        <p><strong>√úzenet:</strong> ${error.message}</p>
                        <p><strong>K√≥d:</strong> ${error.status}</p>
                        <p><strong>R√©szletek:</strong></p>
                        <pre>${JSON.stringify(error, null, 2)}</pre>
                    `, 'error');
                } else {
                    log('‚úÖ SIKERES BEJELENTKEZ√âS', `
                        <p><strong>User:</strong> ${data.user.email}</p>
                        <p><strong>ID:</strong> ${data.user.id}</p>
                        <p><strong>Session created:</strong> ${new Date(data.session.expires_at * 1000).toLocaleString()}</p>
                    `, 'success');
                    
                    // Hide login form
                    document.getElementById('loginForm').style.display = 'none';
                    
                    // Auto-run auth debug
                    setTimeout(debugAuth, 1000);
                }
            } catch (error) {
                log('üíÄ KRITIKUS HIBA', `${error.message}<pre>${error.stack}</pre>`, 'error');
            }
        }
        
        async function debugAuth() {
            log('üë§ AUTHENTICATION DEBUG', 'Checking auth status...', 'info');
            
            try {
                const { data: { user }, error: authError } = await supabase.auth.getUser();
                
                if (authError) {
                    log('‚ùå AUTH ERROR', `Error: ${authError.message}<pre>${JSON.stringify(authError, null, 2)}</pre>`, 'error');
                } else if (!user) {
                    log('‚ö†Ô∏è NO USER', 'Not authenticated - using anonymous access', 'warning');
                } else {
                    log('‚úÖ USER FOUND', `
                        <p>Email: ${user.email}</p>
                        <p>ID: ${user.id}</p>
                        <p>Role: ${user.role || 'default'}</p>
                        <p>App metadata:</p>
                        <pre>${JSON.stringify(user.app_metadata, null, 2)}</pre>
                        <p>User metadata:</p>
                        <pre>${JSON.stringify(user.user_metadata, null, 2)}</pre>
                    `, 'success');
                }
                
                // Test session
                const { data: { session }, error: sessionError } = await supabase.auth.getSession();
                if (sessionError) {
                    log('‚ùå SESSION ERROR', `Error: ${sessionError.message}`, 'error');
                } else if (!session) {
                    log('‚ö†Ô∏è NO SESSION', 'No active session', 'warning');
                } else {
                    log('‚úÖ SESSION ACTIVE', `
                        <p>Access token: ${session.access_token.substring(0, 50)}...</p>
                        <p>Token type: ${session.token_type}</p>
                        <p>Expires: ${new Date(session.expires_at * 1000).toLocaleString()}</p>
                    `, 'success');
                }
                
            } catch (error) {
                log('üíÄ AUTH CRITICAL ERROR', `${error.message}<pre>${error.stack}</pre>`, 'error');
            }
        }
        
        async function debugRLS() {
            log('üîí ROW LEVEL SECURITY DEBUG', 'Testing RLS policies...', 'info');
            
            try {
                // Test 1: Simple select on one phantom set
                const testId = TARGET_SETS[0];
                log('üîç TEST 1: SINGLE SELECT', `Testing select on ${testId}...`, 'info');
                
                const { data: singleSet, error: selectError } = await supabase
                    .from('flashcard_sets')
                    .select('*')
                    .eq('id', testId)
                    .single();
                
                if (selectError) {
                    log('‚ùå SELECT ERROR', `Error: ${selectError.message}<pre>${JSON.stringify(selectError, null, 2)}</pre>`, 'error');
                } else {
                    log('‚úÖ SELECT SUCCESS', `<pre>${JSON.stringify(singleSet, null, 2)}</pre>`, 'success');
                }
                
                // Test 2: Try direct delete with detailed error
                log('üóëÔ∏è TEST 2: DIRECT DELETE', `Testing delete on ${testId}...`, 'info');
                
                const { data: deleteResult, error: deleteError } = await supabase
                    .from('flashcard_sets')
                    .delete()
                    .eq('id', testId)
                    .select();
                
                if (deleteError) {
                    log('‚ùå DELETE ERROR DETAILS', `
                        <p><strong>Message:</strong> ${deleteError.message}</p>
                        <p><strong>Code:</strong> ${deleteError.code}</p>
                        <p><strong>Details:</strong> ${deleteError.details}</p>
                        <p><strong>Hint:</strong> ${deleteError.hint}</p>
                        <p><strong>Full error:</strong></p>
                        <pre>${JSON.stringify(deleteError, null, 2)}</pre>
                    `, 'error');
                } else {
                    log('‚úÖ DELETE SUCCESS', `Deleted: <pre>${JSON.stringify(deleteResult, null, 2)}</pre>`, 'success');
                }
                
                // Test 3: Check if still exists
                log('üîç TEST 3: POST-DELETE CHECK', 'Checking if set still exists...', 'info');
                
                const { data: checkSet, error: checkError } = await supabase
                    .from('flashcard_sets')
                    .select('*')
                    .eq('id', testId)
                    .maybeSingle();
                
                if (checkError) {
                    log('‚ùå CHECK ERROR', `Error: ${checkError.message}`, 'error');
                } else if (checkSet) {
                    log('üëª PHANTOM CONFIRMED', `Set still exists after delete!<pre>${JSON.stringify(checkSet, null, 2)}</pre>`, 'error');
                } else {
                    log('‚úÖ ACTUALLY DELETED', 'Set no longer exists', 'success');
                }
                
            } catch (error) {
                log('üíÄ RLS TEST CRITICAL ERROR', `${error.message}<pre>${error.stack}</pre>`, 'error');
            }
        }
        
        async function directDelete() {
            log('üíÄ DIRECT DELETE ATTEMPT', 'Trying each set individually with max verbosity...', 'warning');
            
            for (let i = 0; i < TARGET_SETS.length; i++) {
                const setId = TARGET_SETS[i];
                log(`üéØ TARGET ${i+1}/5`, `Attempting to delete: ${setId}`, 'info');
                
                try {
                    // Step 1: Verify it exists
                    const { data: exists, error: existsError } = await supabase
                        .from('flashcard_sets')
                        .select('id, title, creator_id')
                        .eq('id', setId)
                        .single();
                    
                    if (existsError) {
                        log(`‚ùå EXISTS CHECK FAILED`, `Cannot verify existence: ${existsError.message}`, 'error');
                        continue;
                    }
                    
                    log(`‚úÖ EXISTS CONFIRMED`, `Set found: "${exists.title}" (creator: ${exists.creator_id})`, 'success');
                    
                    // Step 2: Try delete with all possible options
                    const deleteOptions = [
                        { name: 'BASIC DELETE', method: () => supabase.from('flashcard_sets').delete().eq('id', setId) },
                        { name: 'DELETE WITH SELECT', method: () => supabase.from('flashcard_sets').delete().eq('id', setId).select() },
                        { name: 'DELETE WITH SINGLE', method: () => supabase.from('flashcard_sets').delete().eq('id', setId).select().single() },
                    ];
                    
                    for (const option of deleteOptions) {
                        log(`üîß TRYING: ${option.name}`, `Method: ${option.name}`, 'info');
                        
                        const { data: delResult, error: delError } = await option.method();
                        
                        if (delError) {
                            log(`‚ùå ${option.name} FAILED`, `
                                <p><strong>Error:</strong> ${delError.message}</p>
                                <p><strong>Code:</strong> ${delError.code}</p>
                                <p><strong>Details:</strong> ${delError.details || 'N/A'}</p>
                                <p><strong>Hint:</strong> ${delError.hint || 'N/A'}</p>
                            `, 'error');
                        } else {
                            log(`‚úÖ ${option.name} SUCCESS`, `Result: <pre>${JSON.stringify(delResult, null, 2)}</pre>`, 'success');
                            break; // If one works, stop trying others
                        }
                    }
                    
                    // Step 3: Verify deletion
                    const { data: stillExists, error: verifyError } = await supabase
                        .from('flashcard_sets')
                        .select('*')
                        .eq('id', setId)
                        .maybeSingle();
                    
                    if (verifyError) {
                        log(`‚ùå VERIFY ERROR`, `Cannot verify deletion: ${verifyError.message}`, 'error');
                    } else if (stillExists) {
                        log(`üëª STILL EXISTS`, `Delete command executed but set still exists!`, 'error');
                    } else {
                        log(`‚úÖ CONFIRMED DELETED`, `Set successfully removed`, 'success');
                    }
                    
                } catch (error) {
                    log(`üíÄ CRITICAL ERROR ${i+1}`, `${error.message}`, 'error');
                }
                
                // Small delay between attempts
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }
        
        async function sqlHack() {
            log('‚ö° SQL HACK ATTEMPT', 'Trying raw SQL approaches...', 'warning');
            
            try {
                // Method 1: Try with RPC (if available)
                log('üîß METHOD 1: RPC CALL', 'Attempting RPC delete...', 'info');
                
                try {
                    const { data: rpcResult, error: rpcError } = await supabase
                        .rpc('delete_flashcard_set', { set_id: TARGET_SETS[0] });
                    
                    if (rpcError) {
                        log('‚ùå RPC FAILED', `RPC not available or failed: ${rpcError.message}`, 'error');
                    } else {
                        log('‚úÖ RPC SUCCESS', `RPC result: ${rpcResult}`, 'success');
                    }
                } catch (rpcError) {
                    log('‚ùå RPC NOT AVAILABLE', 'No RPC function available', 'error');
                }
                
                // Method 2: Batch delete
                log('üîß METHOD 2: BATCH DELETE', 'Attempting batch delete...', 'info');
                
                const { data: batchResult, error: batchError } = await supabase
                    .from('flashcard_sets')
                    .delete()
                    .in('id', TARGET_SETS)
                    .select();
                
                if (batchError) {
                    log('‚ùå BATCH DELETE FAILED', `
                        <p><strong>Message:</strong> ${batchError.message}</p>
                        <p><strong>Code:</strong> ${batchError.code}</p>
                        <p><strong>Full error:</strong></p>
                        <pre>${JSON.stringify(batchError, null, 2)}</pre>
                    `, 'error');
                } else {
                    log('‚úÖ BATCH DELETE SUCCESS', `Deleted ${batchResult?.length || 0} sets:<pre>${JSON.stringify(batchResult, null, 2)}</pre>`, 'success');
                }
                
                // Method 3: Check what CREATE permissions we have
                log('üîß METHOD 3: PERMISSION TEST', 'Testing create permissions...', 'info');
                
                const testSet = {
                    title: 'TEST DELETE SET',
                    description: 'Test set for deletion',
                    creator_id: '00000000-0000-0000-0000-000000000000',
                    is_public: false,
                    language_a: 'Hungarian',
                    language_b: 'English'
                };
                
                const { data: createResult, error: createError } = await supabase
                    .from('flashcard_sets')
                    .insert(testSet)
                    .select()
                    .single();
                
                if (createError) {
                    log('‚ùå CREATE FAILED', `Cannot create test set: ${createError.message}`, 'error');
                } else {
                    log('‚úÖ CREATE SUCCESS', `Test set created: ${createResult.id}`, 'success');
                    
                    // Try to delete the test set immediately
                    const { data: testDelResult, error: testDelError } = await supabase
                        .from('flashcard_sets')
                        .delete()
                        .eq('id', createResult.id)
                        .select();
                    
                    if (testDelError) {
                        log('‚ùå TEST DELETE FAILED', `Cannot delete own created set: ${testDelError.message}`, 'error');
                    } else {
                        log('‚úÖ TEST DELETE SUCCESS', 'Can delete newly created sets', 'success');
                    }
                }
                
            } catch (error) {
                log('üíÄ SQL HACK CRITICAL ERROR', `${error.message}<pre>${error.stack}</pre>`, 'error');
            }
        }
        
        async function ownershipFix() {
            log('üëë OWNERSHIP FIX KEZDETE', '√Årva szettek tulajdonos√°nak be√°ll√≠t√°sa...', 'warning');
            
            try {
                // Get current user
                const { data: { user }, error: userError } = await supabase.auth.getUser();
                if (userError || !user) {
                    log('‚ùå USER HIBA', 'Nem vagy bejelentkezve!', 'error');
                    return;
                }
                
                log('üë§ CURRENT USER', `Email: ${user.email}, ID: ${user.id}`, 'info');
                
                // Find all phantom sets (null creator_id)
                log('üîç PHANTOM SZETTEK KERES√âSE', 'Null creator_id szettek keres√©se...', 'info');
                
                const { data: phantomSets, error: searchError } = await supabase
                    .from('flashcard_sets')
                    .select('id, title, creator_id')
                    .is('creator_id', null);
                
                if (searchError) {
                    log('‚ùå KERES√âSI HIBA', `Error: ${searchError.message}`, 'error');
                    return;
                }
                
                log('üëª PHANTOM SZETTEK TAL√ÅLVA', `${phantomSets.length} √°rva szett:<pre>${JSON.stringify(phantomSets, null, 2)}</pre>`, 'info');
                
                if (phantomSets.length === 0) {
                    log('‚úÖ NINCS PHANTOM', 'Nincsenek √°rva szettek!', 'success');
                    return;
                }
                
                // Update ownership for each phantom set
                log('üîß TULAJDONOS BE√ÅLL√çT√ÅSA', `${phantomSets.length} szett friss√≠t√©se...`, 'info');
                
                for (let i = 0; i < phantomSets.length; i++) {
                    const set = phantomSets[i];
                    log(`üìù FRISS√çT√âS ${i+1}/${phantomSets.length}`, `Szett: "${set.title}" (${set.id})`, 'info');
                    
                    const { data: updateResult, error: updateError } = await supabase
                        .from('flashcard_sets')
                        .update({ creator_id: user.id })
                        .eq('id', set.id)
                        .select();
                    
                    if (updateError) {
                        log(`‚ùå FRISS√çT√âSI HIBA ${i+1}`, `Error: ${updateError.message}`, 'error');
                    } else {
                        log(`‚úÖ FRISS√çTVE ${i+1}`, `"${set.title}" most tulajdonod`, 'success');
                    }
                    
                    // Small delay
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                // Verify the fix by trying to delete one
                log('üß™ FIX TESZTEL√âSE', 'Els≈ë szett t√∂rl√©s√©nek tesztel√©se...', 'info');
                
                const testSetId = phantomSets[0].id;
                const { data: deleteTest, error: deleteTestError } = await supabase
                    .from('flashcard_sets')
                    .delete()
                    .eq('id', testSetId)
                    .select();
                
                if (deleteTestError) {
                    log('‚ùå T√ñRL√âSI TESZT HIBA', `Error: ${deleteTestError.message}`, 'error');
                } else if (deleteTest.length > 0) {
                    log('üéâ FIX SIKERES!', `"${phantomSets[0].title}" sikeresen t√∂r√∂lve!<br>Most m√°r m≈±k√∂dni fog a t√∂rl√©s!`, 'success');
                } else {
                    log('‚ö†Ô∏è R√âSZLEGES SIKER', 'Ownership friss√≠tve, de t√∂rl√©s m√©g nem m≈±k√∂dik', 'warning');
                }
                
                // Final status
                log('üìã OWNERSHIP FIX K√âSZ', `
                    <p><strong>Friss√≠tett szettek:</strong> ${phantomSets.length}</p>
                    <p><strong>√öj tulajdonos:</strong> ${user.email}</p>
                    <p><strong>Most pr√≥b√°ld a "üíÄ DIRECT DELETE" gombot!</strong></p>
                `, 'success');
                
            } catch (error) {
                log('üíÄ OWNERSHIP FIX HIBA', `${error.message}<pre>${error.stack}</pre>`, 'error');
            }
        }
        
        async function superDebug() {
            log('üî¨ SUPER DEBUG KEZDETE', 'M√©lyebb adatb√°zis anal√≠zis...', 'warning');
            
            try {
                const { data: { user }, error: userError } = await supabase.auth.getUser();
                if (userError || !user) {
                    log('‚ùå USER HIBA', 'Nem vagy bejelentkezve!', 'error');
                    return;
                }
                
                log('üë§ USER INFO', `ID: ${user.id}, Email: ${user.email}`, 'info');
                
                // 1. Precise phantom check with fresh data
                log('üîç STEP 1: FRESH PHANTOM CHECK', 'Legfrissebb adatok lek√©rdez√©se...', 'info');
                
                const { data: freshSets, error: freshError } = await supabase
                    .from('flashcard_sets')
                    .select('id, title, creator_id, is_public, created_at')
                    .in('id', TARGET_SETS)
                    .order('title');
                
                if (freshError) {
                    log('‚ùå FRESH CHECK HIBA', `Error: ${freshError.message}`, 'error');
                    return;
                }
                
                log('üìä FRESH SET DATA', `<pre>${JSON.stringify(freshSets, null, 2)}</pre>`, 'info');
                
                // 2. Test UPDATE with detailed response
                log('üîß STEP 2: DETAILED UPDATE TEST', 'Egyetlen szett UPDATE tesztel√©se...', 'info');
                
                const testSetId = TARGET_SETS[0];
                const testUpdate = await supabase
                    .from('flashcard_sets')
                    .update({ 
                        creator_id: user.id,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', testSetId)
                    .select('*');
                
                log('üìù UPDATE RESPONSE', `
                    <p><strong>Data returned:</strong> ${testUpdate.data ? testUpdate.data.length + ' records' : 'null'}</p>
                    <p><strong>Error:</strong> ${testUpdate.error ? testUpdate.error.message : 'none'}</p>
                    <p><strong>Status:</strong> ${testUpdate.status || 'unknown'}</p>
                    <p><strong>Raw response:</strong></p>
                    <pre>${JSON.stringify(testUpdate, null, 2)}</pre>
                `, testUpdate.error ? 'error' : 'info');
                
                // 3. Immediate re-check of the same record
                log('üîç STEP 3: IMMEDIATE RE-CHECK', 'UPDATE ut√°n azonnali ellen≈ërz√©s...', 'info');
                
                const { data: recheckSet, error: recheckError } = await supabase
                    .from('flashcard_sets')
                    .select('*')
                    .eq('id', testSetId)
                    .single();
                
                if (recheckError) {
                    log('‚ùå RECHECK HIBA', `Error: ${recheckError.message}`, 'error');
                } else {
                    log('üìä RECHECK RESULT', `
                        <p><strong>Creator ID after UPDATE:</strong> ${recheckSet.creator_id || 'STILL NULL!'}</p>
                        <p><strong>Updated at:</strong> ${recheckSet.updated_at}</p>
                        <p><strong>Full record:</strong></p>
                        <pre>${JSON.stringify(recheckSet, null, 2)}</pre>
                    `, recheckSet.creator_id ? 'success' : 'error');
                }
                
                // 4. Test permissions with different approaches
                log('üõ°Ô∏è STEP 4: PERMISSION ANALYSIS', 'Jogosults√°gok r√©szletes tesztel√©se...', 'info');
                
                // Try to create a test record to see what permissions we have
                const testRecord = {
                    title: 'DEBUG TEST SET',
                    description: 'Temporary test set for debugging',
                    creator_id: user.id,
                    is_public: false,
                    language_a: 'Hungarian',
                    language_b: 'English'
                };
                
                const { data: createTest, error: createError } = await supabase
                    .from('flashcard_sets')
                    .insert(testRecord)
                    .select()
                    .single();
                
                if (createError) {
                    log('‚ùå CREATE TEST FAILED', `Cannot create test record: ${createError.message}`, 'error');
                } else {
                    log('‚úÖ CREATE TEST SUCCESS', `Test record created: ${createTest.id}`, 'success');
                    
                    // Try to update our own created record
                    const { data: updateOwnTest, error: updateOwnError } = await supabase
                        .from('flashcard_sets')
                        .update({ description: 'Updated description' })
                        .eq('id', createTest.id)
                        .select();
                    
                    if (updateOwnError) {
                        log('‚ùå UPDATE OWN FAILED', `Cannot update own record: ${updateOwnError.message}`, 'error');
                    } else {
                        log('‚úÖ UPDATE OWN SUCCESS', 'Can update own records', 'success');
                    }
                    
                    // Try to delete our own created record
                    const { data: deleteOwnTest, error: deleteOwnError } = await supabase
                        .from('flashcard_sets')
                        .delete()
                        .eq('id', createTest.id)
                        .select();
                    
                    if (deleteOwnError) {
                        log('‚ùå DELETE OWN FAILED', `Cannot delete own record: ${deleteOwnError.message}`, 'error');
                    } else {
                        log('‚úÖ DELETE OWN SUCCESS', `Deleted own record: ${deleteOwnTest.length} rows`, 'success');
                    }
                }
                
                // 5. Try bypass approaches
                log('‚ö° STEP 5: BYPASS ATTEMPTS', 'Alternat√≠v megk√∂zel√≠t√©sek...', 'warning');
                
                // Approach 1: Try with exact user ID format
                const userIdFormatted = user.id.toString();
                log('üîß BYPASS 1: FORMATTED USER ID', `Trying with formatted user ID: ${userIdFormatted}`, 'info');
                
                const { data: formatTest, error: formatError } = await supabase
                    .from('flashcard_sets')
                    .update({ creator_id: userIdFormatted })
                    .eq('id', testSetId)
                    .select();
                
                log('üìù FORMAT UPDATE RESULT', `
                    <p><strong>Success:</strong> ${!formatError}</p>
                    <p><strong>Records affected:</strong> ${formatTest ? formatTest.length : 0}</p>
                    <p><strong>Error:</strong> ${formatError ? formatError.message : 'none'}</p>
                `, formatError ? 'error' : 'success');
                
                // Approach 2: Try updating multiple fields at once
                log('üîß BYPASS 2: MULTI-FIELD UPDATE', 'T√∂bb mez≈ë egy√ºttes friss√≠t√©se...', 'info');
                
                const { data: multiTest, error: multiError } = await supabase
                    .from('flashcard_sets')
                    .update({ 
                        creator_id: user.id,
                        description: 'Updated by debug script',
                        updated_at: new Date().toISOString(),
                        is_public: false  // Try to make it private
                    })
                    .eq('id', testSetId)
                    .select();
                
                log('üìù MULTI UPDATE RESULT', `
                    <p><strong>Success:</strong> ${!multiError}</p>
                    <p><strong>Records affected:</strong> ${multiTest ? multiTest.length : 0}</p>
                    <p><strong>Error:</strong> ${multiError ? multiError.message : 'none'}</p>
                `, multiError ? 'error' : 'success');
                
                // 6. Final comprehensive check
                log('üèÅ STEP 6: FINAL CHECK', 'V√©gs≈ë √°llapot ellen≈ërz√©se...', 'info');
                
                const { data: finalCheck, error: finalError } = await supabase
                    .from('flashcard_sets')
                    .select('*')
                    .in('id', TARGET_SETS)
                    .order('title');
                
                if (finalError) {
                    log('‚ùå FINAL CHECK ERROR', `Error: ${finalError.message}`, 'error');
                } else {
                    const ownedSets = finalCheck.filter(set => set.creator_id === user.id);
                    const nullSets = finalCheck.filter(set => set.creator_id === null);
                    
                    log('üìä FINAL RESULTS', `
                        <p><strong>Total sets checked:</strong> ${finalCheck.length}</p>
                        <p><strong>Sets now owned by you:</strong> ${ownedSets.length}</p>
                        <p><strong>Sets still NULL:</strong> ${nullSets.length}</p>
                        <br>
                        <p><strong>Owned sets:</strong></p>
                        <pre>${JSON.stringify(ownedSets.map(s => ({id: s.id, title: s.title, creator_id: s.creator_id})), null, 2)}</pre>
                        <br>
                        <p><strong>NULL sets:</strong></p>
                        <pre>${JSON.stringify(nullSets.map(s => ({id: s.id, title: s.title, creator_id: s.creator_id})), null, 2)}</pre>
                    `, ownedSets.length > 0 ? 'success' : 'error');
                }
                
                log('üî¨ SUPER DEBUG K√âSZ', 'R√©szletes anal√≠zis befejezve. N√©zd √°t az eredm√©nyeket!', 'info');
                
            } catch (error) {
                log('üíÄ SUPER DEBUG CRITICAL ERROR', `${error.message}<pre>${error.stack}</pre>`, 'error');
            }
        }
        
        // Auto-start with login prompt
        document.addEventListener('DOMContentLoaded', function() {
            log('üöÄ FANTOM DEBUGGER IND√çTVA', 'Kattints a "üîë BEJELENTKEZ√âS" gombra a folytat√°shoz!', 'info');
        });
    </script>
</body>
</html>
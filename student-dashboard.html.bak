<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - SnappyCards</title>
    
    <!-- Favicon - Multiple formats for better browser support -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPCEtLSBCYWNrZ3JvdW5kIC0tPgo8cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHJ4PSI0IiBmaWxsPSIjNjM2NmYxIi8+CjwhLS0gQ2FyZCBTaGFwZSAtLT4KPHJlY3QgeD0iNCIgeT0iNiIgd2lkdGg9IjI0IiBoZWlnaHQ9IjE2IiByeD0iMyIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjZGRkZGRkIiBzdHJva2Utd2lkdGg9IjAuNSIvPgo8IS0tIFRleHQgUyAtLT4KPHRleHQgeD0iMTYiIHk9IjE4IiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjNjM2NmYxIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+UzwvdGV4dD4KPCEtLSBTbWFsbCBkb3RzIGZvciBmbGFzaGNhcmQgZWZmZWN0IC0tPgo8Y2lyY2xlIGN4PSI4IiBjeT0iMTAiIHI9IjEiIGZpbGw9IiM2MzY2ZjEiLz4KPGNpcmNsZSBjeD0iMjQiIGN5PSIxOCIgcj0iMSIgZmlsbD0iIzYzNjZmMSIvPgo8L3N2Zz4K">
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPCEtLSBCYWNrZ3JvdW5kIC0tPgo8cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHJ4PSI0IiBmaWxsPSIjNjM2NmYxIi8+CjwhLS0gQ2FyZCBTaGFwZSAtLT4KPHJlY3QgeD0iNCIgeT0iNiIgd2lkdGg9IjI0IiBoZWlnaHQ9IjE2IiByeD0iMyIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjZGRkZGRkIiBzdHJva2Utd2lkdGg9IjAuNSIvPgo8IS0tIFRleHQgUyAtLT4KPHRleHQgeD0iMTYiIHk9IjE4IiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjNjM2NmYxIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+UzwvdGV4dD4KPCEtLSBTbWFsbCBkb3RzIGZvciBmbGFzaGNhcmQgZWZmZWN0IC0tPgo8Y2lyY2xlIGN4PSI4IiBjeT0iMTAiIHI9IjEiIGZpbGw9IiM2MzY2ZjEiLz4KPGNpcmNsZSBjeD0iMjQiIGN5PSIxOCIgcj0iMSIgZmlsbD0iIzYzNjZmMSIvPgo8L3N2Zz4K">
    <link rel="shortcut icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPCEtLSBCYWNrZ3JvdW5kIC0tPgo8cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHJ4PSI0IiBmaWxsPSIjNjM2NmYxIi8+CjwhLS0gQ2FyZCBTaGFwZSAtLT4KPHJlY3QgeD0iNCIgeT0iNiIgd2lkdGg9IjI0IiBoZWlnaHQ9IjE2IiByeD0iMyIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjZGRkZGRkIiBzdHJva2Utd2lkdGg9IjAuNSIvPgo8IS0tIFRleHQgUyAtLT4KPHRleHQgeD0iMTYiIHk9IjE4IiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjNjM2NmYxIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+UzwvdGV4dD4KPCEtLSBTbWFsbCBkb3RzIGZvciBmbGFzaGNhcmQgZWZmZWN0IC0tPgo8Y2lyY2xlIGN4PSI4IiBjeT0iMTAiIHI9IjEiIGZpbGw9IiM2MzY2ZjEiLz4KPGNpcmNsZSBjeD0iMjQiIGN5PSIxOCIgcj0iMSIgZmlsbD0iIzYzNjZmMSIvPgo8L3N2Zz4K">
    <meta name="theme-color" content="#6366f1">
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Snappy Cards Logo Component -->
    <link rel="stylesheet" href="components/snappy-cards-logo.css">
    
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="config/supabase.js"></script>
    <script src="lib/i18n.js"></script>
    
    <!-- Lucide Icons CDN -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- STYLES_CLEANED_OK (lines 26-1754) -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 50%, #c7d2fe 100%);
            color: #1a202c;
            min-height: 100vh;
            overflow-x: hidden;
        }



        .container {
            max-width: 1440px;
            width: 90%;
            margin: 0 auto;
            padding: 0 24px;
        }
        
        @media (min-width: 1600px) {
            .container {
                max-width: 1600px;
                width: 85%;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                width: 95%;
                padding: 0 16px;
            }
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 16px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo-small {
            display: flex;
            align-items: center;
            text-decoration: none;
            color: inherit;
        }



        .user-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 16px;
        }

        .user-details h3 {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
        }

        .user-details p {
            font-size: 12px;
            color: #64748b;
        }

        .logout-btn {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            color: #dc2626;
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: translateY(-2px);
        }

        /* Main Content */
        .main-content {
            padding: 40px 0;
        }

        .welcome-section {
            text-align: center;
            margin-bottom: 24px;
        }

        .welcome-title {
            font-size: 36px;
            font-weight: 800;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .welcome-subtitle {
            font-size: 18px;
            color: #64748b;
            font-weight: 500;
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            padding: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .stat-number {
            font-size: 32px;
            font-weight: 800;
            color: #667eea;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 14px;
            color: #64748b;
            font-weight: 500;
        }

        .stat-icon {
            font-size: 24px;
            margin-bottom: 12px;
        }

        /* Section Headers */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .section-title-row {
            display: flex;
            align-items: center;
            gap: 24px;
            flex: 1;
        }

        .section-title {
            font-size: 24px;
            font-weight: 700;
            color: #374151;
        }

        /* Search Container */
        .search-container {
            flex: 1;
            max-width: 400px;
        }

        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px;
            padding-right: 44px;
            border: 2px solid rgba(156, 163, 175, 0.2);
            border-radius: 12px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            color: #374151;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.95);
        }

        .search-input::placeholder {
            color: #9ca3af;
        }



        .search-clear {
            position: absolute;
            right: 12px;
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .search-clear:hover {
            color: #374151;
            background: rgba(156, 163, 175, 0.1);
        }

        .add-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
        }

        .add-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.6);
        }

        /* Cards Grid */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
            gap: 24px;
            width: 100%;
            margin-bottom: 24px;
        }

        @media (max-width: 1200px) {
            .cards-grid {
                grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            }
        }

        .flashcard-set {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            padding: 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            display: block !important;
            width: auto !important;
            max-width: none !important;
            min-height: 340px;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .flashcard-set:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .flashcard-set:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 340px;
            transition: transform 0.4s ease;
            transform-style: preserve-3d;
        }

        .flashcard-set.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
        }

        .card-front {
            background: transparent;
            padding: 20px;
            padding-bottom: 24px;
            display: flex;
            flex-direction: column;
            min-height: 280px;
        }

        .card-back {
            background: rgba(255, 255, 255, 0.9);
            transform: rotateY(180deg);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            position: relative;
            overflow: hidden;
        }

        .card-back-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 80%;
            object-fit: cover;
            border-radius: 20px 20px 0 0;
        }

        .card-back-title {
            position: relative;
            z-index: 2;
            height: 20%;
            display: flex;
            align-items: center;
            padding: 16px 24px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 50%, transparent 100%);
            color: white;
            font-weight: 600;
            font-size: 16px;
            border-radius: 0 0 20px 20px;
        }

        .set-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .set-title {
            font-size: 18px;
            font-weight: 700;
            color: #374151;
            margin-bottom: 8px;
        }

        .set-description {
            font-size: 14px;
            color: #64748b;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .set-meta {
            position: absolute;
            bottom: 24px;
            left: 24px;
            right: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #64748b;
        }

        .set-stats {
            display: flex;
            gap: 16px;
        }

        /* 🎯 PONTOSAN 2 SOR statisztika - Figma design alapján */
        .set-stats-2row {
            margin-top: 8px;
            margin-bottom: 0;
            line-height: 1.3;
        }

        .row1 {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 12px;
            gap: 8px;
        }

        .row2 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13.6px;
            color: #64748b;
            padding-top: 2px;
        }

        .row2 .left {
            display: flex;
            align-items: center;
            min-width: 0;
        }

        .row2 .right {
            display: flex;
            align-items: center;
            gap: 8px;
        }


        /* Status indicators - színes háttérrel */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 6px;
            border-radius: 6px;
            font-size: 13.6px;
            font-weight: 500;
        }

        .status-indicator.green {
            background-color: rgb(220, 252, 231); /* green-100 */
            color: rgb(22, 163, 74); /* green-600 */
        }

        .status-indicator.yellow {
            background-color: rgb(254, 249, 195); /* yellow-100 */
            color: rgb(202, 138, 4); /* yellow-600 */
        }

        .status-indicator.red {
            background-color: rgb(254, 226, 226); /* red-100 */
            color: rgb(220, 38, 38); /* red-600 */
        }

        .progress-text, .study-date, .language-pair {
            font-size: 13.6px;
            color: #64748b;
        }
        
        .language-pair.clickable {
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0;
        }
        
        .language-pair.clickable:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
            transform: scale(1.05);
        }

        .dbg-stats{
            font-size:10px; background:#7c3aed; color:#fff;
            padding:2px 6px; border-radius:9999px; margin-left:auto;
        }

        .time-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 13.6px;
            color: #64748b;
        }



        .set-options {
            position: relative;
        }

        .options-btn {
            background: none;
            border: none;
            font-size: 18px;
            color: #64748b;
            cursor: pointer;
            padding: 4px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .options-btn:hover {
            background: rgba(100, 116, 139, 0.1);
        }

        /* Placeholder Card */
        .placeholder-card {
            opacity: 0.85;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.05) 0%, rgba(99, 102, 241, 0.05) 100%);
            border: 2px dashed rgba(139, 92, 246, 0.3) !important;
            cursor: default !important;
        }

        .placeholder-card:hover {
            transform: none !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;
        }

        .placeholder-card .set-title {
            color: #8b5cf6;
            font-weight: 600;
        }

        .placeholder-card .set-description {
            color: #6b7280;
            font-style: italic;
        }

        .placeholder-progress {
            background: linear-gradient(90deg, 
                rgba(139, 92, 246, 0.3) 0%, 
                rgba(139, 92, 246, 0.1) 30%, 
                transparent 100%);
            width: 25% !important;
        }

        .placeholder-actions {
            margin: 16px 0;
            padding: 12px;
            background: rgba(139, 92, 246, 0.08);
            border-radius: 12px;
            border: 1px solid rgba(139, 92, 246, 0.15);
        }

        .placeholder-tip {
            font-size: 13px;
            color: #7c3aed;
            font-weight: 500;
            text-align: center;
        }

        /* Invitations */
        .invitation-card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-left: 4px solid #f59e0b;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 16px;
        }

        .invitation-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .invitation-title {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
        }

        .invitation-from {
            font-size: 14px;
            color: #64748b;
            margin-top: 4px;
        }

        .invitation-actions {
            display: flex;
            gap: 8px;
        }

        .accept-btn {
            background: #22c55e;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .accept-btn:hover {
            background: #16a34a;
        }

        .decline-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .decline-btn:hover {
            background: #dc2626;
        }

        /* Progress Bar */
        .progress-bar {
            background: #e2e8f0;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            
            .section-header {
                flex-direction: column;
                gap: 16px;
                align-items: stretch;
            }

            .section-title-row {
                flex-direction: column;
                gap: 16px;
                align-items: stretch;
            }

            .search-container {
                max-width: none;
            }
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 40px;
            max-width: 1440px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        /* Create set modal smaller */
        #createSetModal .modal {
            max-width: 600px;
        }

        /* Tag styles */
        .tag-suggestion {
            padding: 12px 16px;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            color: #374151;
        }

        .tag-suggestion:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .tag-suggestion:last-child {
            border-bottom: none;
        }

        .selected-tag {
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            margin: 4px 8px 4px 0;
            animation: tagFadeIn 0.3s ease;
        }

        .selected-tag .tag-remove {
            margin-left: 8px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .selected-tag .tag-remove:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        @keyframes tagFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Add cards modal larger - FLEX layout with fixed buttons */
        #addCardsModal .modal {
            max-width: 1400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        /* Edit card modal - same constraints as add cards modal */
        #editCardModalContainer .modal {
            max-width: 1400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-overlay.active .modal {
            transform: scale(1);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .modal-title {
            font-size: 28px;
            font-weight: 800;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal-subtitle {
            font-size: 16px;
            color: #64748b;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .form-input {
            width: 100%;
            padding: 16px 20px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(8px);
            font-size: 16px;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
        }

        .modal-actions {
            display: flex;
            gap: 16px;
            justify-content: flex-end;
            margin-top: 32px;
        }

        .btn-secondary {
            background: rgba(100, 116, 139, 0.1);
            border: 1px solid rgba(100, 116, 139, 0.2);
            color: #64748b;
            padding: 12px 24px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background: rgba(100, 116, 139, 0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.6);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-up {
            animation: fadeInUp 0.6s ease forwards;
        }

        .delay-1 { animation-delay: 0.1s; }
        .delay-2 { animation-delay: 0.2s; }
        .delay-3 { animation-delay: 0.3s; }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Dropdown Menu */
        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 180px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
        }

        .dropdown-menu.active {
            opacity: 1 !important;
            visibility: visible !important;
            transform: translateY(0) !important;
            display: block !important;
            z-index: 9999 !important;
            pointer-events: auto !important;
            position: absolute !important;
            top: 100% !important;
            right: 0 !important;
        }

        .dropdown-menu:not(.active) {
            opacity: 0 !important;
            visibility: hidden !important;
            transform: translateY(-10px) !important;
            display: none !important;
            pointer-events: none !important;
        }

        /* Removed - using .set-actions instead */

        .action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
            color: white;
            position: relative;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .action-btn.add {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }

        .action-btn.edit {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
        }

        .action-btn.list {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }

        .action-btn.import {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .action-btn.delete {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .action-btn.leave {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
        }

        .action-btn.study {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
        }

        .set-actions .action-btn.study {
            margin-right: 16px !important;
        }

        .action-btn svg,
        .action-btn i {
            display: block;
            margin: auto;
            color: white;
            width: 20px;
            height: 20px;
        }

        /* Enhanced Cards List Modal */
        .cards-list-modal {
            max-width: 1440px !important;
            max-height: 90vh !important;
            width: 90% !important;
            padding: 0 !important;
            display: flex !important;
            flex-direction: column !important;
        }

        .cards-list-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 24px 32px 0 32px;
            border-bottom: 1px solid rgba(226, 232, 240, 0.8);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px 24px 0 0;
        }

        .header-title h2 {
            color: #1f2937;
            font-size: 24px;
            font-weight: 700;
            margin: 0 0 8px 0;
        }

        .header-stats {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .stat-badge {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .close-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #374151;
        }

        .cards-list-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 32px;
            background: rgba(249, 250, 251, 0.8);
            border-bottom: 1px solid rgba(226, 232, 240, 0.8);
            gap: 16px;
            flex-wrap: wrap;
        }

        .search-section {
            flex: 1;
            max-width: 400px;
        }

        .toolbar-actions {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .sort-select {
            padding: 8px 12px;
            border: 2px solid rgba(156, 163, 175, 0.2);
            border-radius: 8px;
            background: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .sort-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .export-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
            color: white !important;
            border: none !important;
            padding: 8px 16px !important;
            border-radius: 8px !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            display: flex !important;
            align-items: center !important;
            gap: 6px !important;
        }

        .export-btn:hover {
            transform: translateY(-1px) !important;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3) !important;
        }

        .add-btn {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%) !important;
            color: white !important;
            border: none !important;
            padding: 8px 16px !important;
            border-radius: 8px !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            display: flex !important;
            align-items: center !important;
            gap: 6px !important;
        }

        .add-btn:hover {
            transform: translateY(-1px) !important;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3) !important;
        }

        .cards-list-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px 32px 32px 32px;
            background: rgba(255, 255, 255, 0.5);
        }

        .card-list-item {
            display: grid;
            grid-template-columns: 40px 1fr auto auto auto;
            gap: 16px;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .card-list-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border-color: rgba(102, 126, 234, 0.3);
        }

        .card-number {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }

        .card-content {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 16px;
            align-items: center;
            flex: 1;
        }

        .card-side {
            min-width: 0;
        }

        .side-label {
            font-size: 12px;
            color: #6b7280;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .side-text {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            word-wrap: break-word;
        }

        .card-side.back .side-text {
            color: #4b5563;
            font-weight: 500;
        }

        .card-divider {
            color: #9ca3af;
            opacity: 0.6;
        }

        .card-media {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-actions {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .set-actions {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
            width: 100%;
            margin-top: 16px;
            margin-bottom: 10px;
        }


        .icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 10px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #6b7280;
            line-height: normal;
        }

        .icon-btn:hover {
            background: rgba(156, 163, 175, 0.1);
            color: #111827;
        }

        .icon-btn:focus {
            outline: 2px solid #667eea;
            outline-offset: 1px;
        }

        .icon-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 1.75;
        }

        @keyframes highlight-flash {
            0% { background-color: #EEF2FF; }
            100% { background-color: rgba(255, 255, 255, 0.8); }
        }

        .list-action-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .list-action-btn.edit {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
        }

        .list-action-btn.edit:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: scale(1.1);
        }

        .list-action-btn.delete {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        .list-action-btn.delete:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: scale(1.1);
        }

        .card-date {
            font-size: 12px;
            color: #9ca3af;
            text-align: right;
            min-width: 80px;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .cards-list-modal {
                width: 98% !important;
                max-height: 95vh !important;
            }

            .cards-list-header {
                padding: 16px 20px 0 20px;
            }

            .cards-list-toolbar {
                padding: 12px 20px;
                flex-direction: column;
                gap: 12px;
                align-items: stretch;
            }

            .search-section {
                max-width: none;
            }

            .toolbar-actions {
                justify-content: center;
            }

            .cards-list-container {
                padding: 12px 20px 20px 20px;
            }

            .card-list-item {
                grid-template-columns: 1fr;
                gap: 12px;
                text-align: left;
            }

            .card-content {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .card-divider {
                transform: rotate(90deg);
                margin: 8px 0;
            }

            .card-actions {
                justify-content: center;
            }

            .card-date {
                text-align: center;
            }
        }

        /* Empty state for cards list */
        .empty-state {
            text-align: center;
            padding: 32px 32px;
            color: #6b7280;
        }

        .empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.6;
        }

        .empty-title {
            font-size: 24px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .empty-description {
            font-size: 16px;
            margin-bottom: 24px;
            opacity: 0.8;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            text-decoration: none;
        }

        .dropdown-item:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .dropdown-item.danger:hover {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        .dropdown-icon {
            font-size: 16px;
        }

        /* SlotMachine Modal Styles */
        .slot-machine-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 32px;
            max-width: 1440px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        .slot-machine-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .slot-machine-title {
            font-size: 28px;
            font-weight: 700;
            color: #1f2937;
            margin: 0;
        }

        .close-button {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .close-button:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: scale(1.05);
        }

        .statistics-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 32px;
        }

        .stats-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .stat-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.15);
        }

        .stat-number {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 14px;
            font-weight: 500;
            opacity: 0.8;
        }

        .stat-green { border-left: 4px solid #10b981; }
        .stat-green .stat-number { color: #10b981; }

        .stat-yellow { border-left: 4px solid #f59e0b; }
        .stat-yellow .stat-number { color: #f59e0b; }

        .stat-red { border-left: 4px solid #ef4444; }
        .stat-red .stat-number { color: #ef4444; }

        .stat-blue { border-left: 4px solid #3b82f6; }
        .stat-blue .stat-number { color: #3b82f6; }

        .stat-purple { border-left: 4px solid #8b5cf6; }
        .stat-purple .stat-number { color: #8b5cf6; }

        .stat-orange { border-left: 4px solid #f97316; }
        .stat-orange .stat-number { color: #f97316; }

        .cards-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
            margin-bottom: 32px;
            min-height: 300px;
        }

        .card-slot {
            perspective: 1000px;
            position: relative;
        }

        .study-card {
            width: 100%;
            height: 280px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s ease;
            cursor: pointer;
        }

        .study-card.spinning {
            animation: spinCard 1.5s ease-in-out;
        }

        @keyframes spinCard {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(1080deg) scale(1.1); }
            100% { transform: rotateY(1080deg); }
        }

        .card-content {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));
            backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 24px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .card-content:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .card-term {
            font-size: 24px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 16px;
            text-align: center;
            line-height: 1.2;
        }

        .card-definition {
            font-size: 18px;
            color: #6b7280;
            text-align: center;
            line-height: 1.4;
        }

        .feedback-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            max-width: 600px;
            margin: 0 auto;
        }

        .feedback-btn {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            border-radius: 16px;
            padding: 16px 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .feedback-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.15);
        }

        .feedback-icon {
            font-size: 24px;
            font-weight: bold;
        }

        .feedback-text {
            font-size: 16px;
            font-weight: 600;
        }

        .feedback-correct {
            border-color: #10b981;
            color: #10b981;
        }

        .feedback-correct:hover {
            background: rgba(16, 185, 129, 0.1);
        }

        .feedback-uncertain {
            border-color: #f59e0b;
            color: #f59e0b;
        }

        .feedback-uncertain:hover {
            background: rgba(245, 158, 11, 0.1);
        }

        .feedback-learning {
            border-color: #ef4444;
            color: #ef4444;
        }

        .feedback-learning:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .slot-machine-container {
                padding: 20px;
                margin: 10px;
            }

            .stats-row {
                grid-template-columns: repeat(2, 1fr);
            }

            .cards-container {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .study-card {
                height: 200px;
            }

            .card-term {
                font-size: 20px;
            }

            .card-definition {
                font-size: 16px;
            }

            .feedback-buttons {
                grid-template-columns: 1fr;
            }
        }

        /* Clamp bottom spacing for the dashboard cards section */
        main.main-content,
        main.main-content > .container,
        main.main-content > .container > section.fade-in-up.delay-2,
        #ownSetsGrid.cards-grid {
          margin-bottom: 0 !important;
          padding-bottom: 24px !important;
        }

        /* Culprit: prevent the section from forcing extra height */
        main.main-content > .container > section.fade-in-up.delay-2 {
          min-height: auto !important;
          height: auto !important;
          overflow: visible;
        }

        /* Grid itself should not enforce extra height */
        #ownSetsGrid.cards-grid { min-height: auto; }

    </style>
</head>
<body>


    <!-- Header -->
    <header class="header" style="position: relative;">
        <div class="container">
            <div class="header-content">
                <a href="index.html" class="logo-small">
                    <div class="hero-glass-container" style="margin-bottom: 0; display: inline-block;">
                        <div class="hero-glass-card" style="padding: 8px 16px; animation: none;">
                            <h1 class="hero-title" style="margin: 0;">
                                <span class="hero-gradient-text">Snappy</span><span class="hero-cards-text">Cards</span>
                            </h1>
                        </div>
                    </div>
                </a>
                

                <div class="user-info" style="position: relative;">
                    <div class="user-details">
                        <h3 id="userName">Loading...</h3>
                        <p id="userRole">student</p>
                    </div>
                    <div class="user-avatar" id="userAvatar" style="cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" data-i18n-title="dashboard.userMenu" title="Felhasználói menü">Z</div>
                    
                    <!-- User Dropdown Menu -->
                    <div id="userDropdownMenu" style="display: none; position: absolute; top: 100%; right: 0; background: #ffffff; border-radius: 12px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 1000; min-width: 200px; overflow: hidden; border: 1px solid #e5e7eb;">
                        <div onclick="openSettingsModal(); closeUserMenu()" 
                             style="padding: 0 12px; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s ease; height: 40px;"
                             onmouseover="this.style.backgroundColor='#f3f4f6'; this.querySelector('.menu-icon').style.stroke='#111827'"
                             onmouseout="this.style.backgroundColor='transparent'; this.querySelector('.menu-icon').style.stroke='#6b7280'">
                            <i class="menu-icon" data-lucide="settings" style="width: 20px; height: 20px; stroke: #6b7280; stroke-width: 1.75;"></i>
                            <span style="color: #374151; font-weight: 500; font-size: 14px;" data-i18n="dashboard.settings">Beállítások</span>
                        </div>
                        <div onclick="openTagManagerModal(); closeUserMenu()" 
                             style="padding: 0 12px; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s ease; height: 40px;"
                             onmouseover="this.style.backgroundColor='#f3f4f6'; this.querySelector('.menu-icon').style.stroke='#111827'"
                             onmouseout="this.style.backgroundColor='transparent'; this.querySelector('.menu-icon').style.stroke='#6b7280'">
                            <i class="menu-icon" data-lucide="tags" style="width: 20px; height: 20px; stroke: #6b7280; stroke-width: 1.75;"></i>
                            <span style="color: #374151; font-weight: 500; font-size: 14px;" data-i18n="dashboard.tagManager">TAG kezelő</span>
                        </div>
                        <div onclick="logout(); closeUserMenu()" 
                             style="padding: 0 12px; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s ease; height: 40px;"
                             onmouseover="this.style.backgroundColor='#f3f4f6'; this.querySelector('.menu-icon').style.stroke='#111827'"
                             onmouseout="this.style.backgroundColor='transparent'; this.querySelector('.menu-icon').style.stroke='#6b7280'">
                            <i class="menu-icon" data-lucide="log-out" style="width: 20px; height: 20px; stroke: #6b7280; stroke-width: 1.75;"></i>
                            <span style="color: #374151; font-weight: 500; font-size: 14px;" data-i18n="dashboard.logout">Kilépés</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            <!-- Welcome Section -->
            <section class="welcome-section fade-in-up">
                <h1 class="welcome-title" id="welcomeTitle">Üdvözöllek a Dashboard-on!</h1>
                <p class="welcome-subtitle" data-i18n="dashboard.subtitle">Kezeld szókártya szettjeidet és tanulj hatékonyan</p>
            </section>

            <!-- Stats -->
            <section class="stats-grid fade-in-up delay-1">
                <div class="stat-card">
                    <div class="stat-number" id="ownSetsCount">0</div>
                    <div class="stat-label" data-i18n="dashboard.ownSets">Saját szett</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="joinedSetsCount">0</div>
                    <div class="stat-label" data-i18n="dashboard.joinedSets">Csatlakozott szett</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalCards">0</div>
                    <div class="stat-label" data-i18n="dashboard.totalCards">Összes kártya</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="masteredCards">0</div>
                    <div class="stat-label" data-i18n="dashboard.mastered">Elsajátítva</div>
                </div>
            </section>

            <!-- Pending Invitations -->
            <section id="invitationsSection" class="fade-in-up delay-2" style="display: none;">
                <div class="section-header">
                    <h2 class="section-title">📧 Meghívók</h2>
                </div>
                <div id="invitationsList">
                    <!-- Invitations will be loaded here -->
                </div>
            </section>

            <!-- Own Flashcard Sets -->
            <section class="fade-in-up delay-2">
                <div class="section-header">
                    <div class="section-title-row">
                    <h2 class="section-title" data-i18n="dashboard.ownSetsTitle"> Saját szettjeim</h2>
                        <div class="search-container">
                            <!-- Első sor: Keresőmező + Dropdown + Tag input -->
                            <div id="mainSearchRow" style="display: flex; gap: 12px; align-items: center;">
                                <div class="search-input-wrapper" style="flex: 1; min-width: 200px;">
                                    <input 
                                        type="text" 
                                        id="ownSetsSearch" 
                                        class="search-input" 
                                        placeholder="🔍 Keresés szettekben..."
                                        oninput="debounceFilterOwnSets(this.value)"
                                    >
                                    <button class="search-clear" onclick="clearOwnSetsSearch()" style="display: none;">
                                        <svg class="lucide-icon icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M18 6 6 18"/>
                                            <path d="m6 6 12 12"/>
                                        </svg>
                                    </button>
                                </div>
                                <div class="search-mode-selector">
                                    <select id="searchModeSelect" onchange="onSearchModeChange()" style="
                                        padding: 8px 12px;
                                        border: 1px solid #d1d5db;
                                        border-radius: 6px;
                                        font-size: 12px;
                                        background: white;
                                        color: #374151;
                                        cursor: pointer;
                                        outline: none;
                                        transition: border-color 0.2s;
                                        white-space: nowrap;
                                        min-width: 140px;
                                    " onfocus="this.style.borderColor='#3b82f6'" onblur="this.style.borderColor='#d1d5db'">
                                        <option value="all">Összes helyen</option>
                                        <option value="sets">Csak szett nevekben</option>
                                        <option value="cards">Csak kártyákban</option>
                                    </select>
                                </div>
                                <div class="tag-filter-input-container" style="position: relative; min-width: 140px;">
                                    <input 
                                        type="text" 
                                        id="searchTagFilter" 
                                        placeholder="Tag szűrő..."
                                        style="
                                            padding: 8px 32px 8px 12px;
                                            border: 1px solid #d1d5db;
                                            border-radius: 6px;
                                            font-size: 12px;
                                            background: white;
                                            color: #374151;
                                            outline: none;
                                            transition: border-color 0.2s;
                                            width: 100%;
                                            box-sizing: border-box;
                                        "
                                        onfocus="this.style.borderColor='#3b82f6'" 
                                        onblur="this.style.borderColor='#d1d5db'"
                                        oninput="handleTagFilterInput(this.value)"
                                        onkeydown="handleTagFilterKeydown(event)"
                                    >
                                    <button class="tag-filter-clear" onclick="clearTagFilter()" style="display: none; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #9ca3af; cursor: pointer; padding: 2px; border-radius: 3px; transition: all 0.2s;" onmouseover="this.style.color='#ef4444'" onmouseout="this.style.color='#9ca3af'" title="Tag szűrő törlése">
                                        <svg class="lucide-icon icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
                                            <path d="M18 6 6 18"/>
                                            <path d="m6 6 12 12"/>
                                        </svg>
                                    </button>
                                    <div id="tagFilterSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #e2e8f0; max-height: 150px; overflow-y: auto; z-index: 1000; display: none; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                                </div>
                                <button id="clearAllFiltersBtn" onclick="clearAllFilters()" style="
                                    padding: 8px 12px;
                                    border: 1px solid #d1d5db;
                                    border-radius: 6px;
                                    font-size: 12px;
                                    background: white;
                                    color: #9ca3af;
                                    cursor: pointer;
                                    outline: none;
                                    transition: all 0.2s;
                                    white-space: nowrap;
                                    display: flex;
                                    align-items: center;
                                    gap: 6px;
                                " 
                                onmouseover="updateClearAllFiltersBtn(true)" 
                                onmouseout="updateClearAllFiltersBtn(false)" 
                                title="Minden szűrés törlése">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
                                        <path d="M3 6h18"/>
                                        <path d="M19 6v14c0 1-1 2-2 2H7c0-1-1-2-2-2V6"/>
                                        <path d="M8 6V4c0-1 1-2 2-2h4c0 1 1 2 2 2v2"/>
                                        <path d="M10 11v6"/>
                                        <path d="M14 11v6"/>
                                    </svg>
                                    Minden törlése
                                </button>
                            </div>
                            
                            <!-- Második sor: Kiválasztott tag-ek (csak ha vannak) -->
                            <div id="selectedTagsRow" style="display: none; align-items: center; gap: 8px;">
                                <div id="selectedTagFilters" style="display: flex; flex-wrap: wrap; gap: 4px; flex: 1;"></div>
                                <button id="clearAllTagsBtn" onclick="clearTagFilters()" style="display: none; padding: 4px 8px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 10px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#dc2626'" onmouseout="this.style.background='#ef4444'" title="Összes tag törlése">Összes törlése</button>
                            </div>
                        </div>
                    </div>
                    <button class="add-btn" onclick="createNewSet()" data-i18n="dashboard.newSetButton">
                        <span>+</span>
                        Új szett létrehozása
                    </button>
                </div>
                <div class="cards-grid" id="ownSetsGrid">
                    <!-- Own sets will be loaded here -->
                </div>
            </section>

            <!-- Joined Flashcard Sets -->
            <section class="fade-in-up delay-3">
                <div class="section-header">
                    <h2 class="section-title" data-i18n="dashboard.joinedSetsTitle">👥 Csatlakozott szettjeim</h2>
                </div>
                <div class="cards-grid" id="joinedSetsGrid">
                    <!-- Joined sets will be loaded here -->
                </div>
            </section>
        </div>
    </main>

    <!-- Create New Set Modal -->
    <div class="modal-overlay" id="createSetModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Új szókártya szett</h2>
                <p class="modal-subtitle">Hozz létre egy új szókártya szettet a tanuláshoz</p>
            </div>
            
            <form id="createSetForm">
                <div class="form-group">
                    <label class="form-label" for="setTitle">Szett címe *</label>
                    <input type="text" id="setTitle" class="form-input" placeholder="pl. Angol alapszókincs" required>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="setDescription">Leírás</label>
                    <textarea id="setDescription" class="form-input form-textarea" placeholder="Rövid leírás a szett tartalmáról..."></textarea>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                    <div class="form-group">
                        <label class="form-label">A nyelv (forrás) </label>
                        <div id="languageAContainer"></div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">B nyelv (cél) </label>
                        <div id="languageBContainer"></div>
                    </div>
                </div>
                
                <!-- Tag -->
                <div class="form-group">
                    <label class="form-label" for="setTag">Tag</label>
                    <div style="position: relative;">
                        <input type="text" 
                               id="setTag"
                               class="form-input" 
                               placeholder="pl. nyelvek, tudomány, sport" 
                               value=""
                               oninput="handleCreateTagInput(this.value)"
                               onkeydown="handleCreateTagKeydown(event)">
                        <div id="createTagSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #e2e8f0; max-height: 150px; overflow-y: auto; z-index: 1000; display: none; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                    </div>
                    <!-- Tag lista megjelenítés -->
                    <div id="createSelectedTags" style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px;"></div>
                </div>
                
                <div class="modal-actions">
                    <button type="button" class="btn-secondary" onclick="closeCreateSetModal()">Mégse</button>
                    <button type="submit" class="btn-primary" id="createSetBtn">
                        <span></span>
                        Szett létrehozása
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Cards to Set Modal -->
    <div class="modal-overlay" id="addCardsModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Kártyák hozzáadása</h2>
                <p class="modal-subtitle" id="addCardsSetTitle">Új szókártyák hozzáadása a szetthez</p>
            </div>
            
            <div id="addCardsFormContainer" style="flex: 1; overflow-y: auto;">
                <!-- Dynamic form will be injected here -->
            </div>
            
            <!-- FIXED BUTTONS - outside scroll area -->
            <div id="addCardsButtons" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px); border-top: 1px solid rgba(255, 255, 255, 0.2); padding: 20px; display: grid; grid-template-columns: 1fr 1fr; gap: 16px; border-radius: 0 0 24px 24px; margin: 0 -40px -40px -40px;">
                <button type="button" 
                        onclick="approveCard()" 
                        id="approveBtn2"
                        style="padding: 16px 24px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: white; border: none; border-radius: 16px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 8px 32px rgba(34, 197, 94, 0.3);"
                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 12px 40px rgba(34, 197, 94, 0.4)'"
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 8px 32px rgba(34, 197, 94, 0.3)'"
                        disabled>
                    Mentés
                </button>
                <button type="button" 
                        onclick="closeAddCardsModal()" 
                        style="padding: 16px 24px; background: rgba(156, 163, 175, 0.1); color: #6b7280; border: 2px solid rgba(156, 163, 175, 0.2); border-radius: 16px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;"
                        onmouseover="this.style.background='rgba(156, 163, 175, 0.15)'"
                        onmouseout="this.style.background='rgba(156, 163, 175, 0.1)'">
                    Mégse
                </button>
            </div>
        </div>
    </div>

    <!-- SlotMachine Modal -->
    <div class="modal-overlay" id="slotMachineModal" style="display: none; z-index: 2000;">
        <div class="slot-machine-container">
            <!-- Header with title and close button -->
            <div class="slot-machine-header">
                <h2 id="slotMachineTitle" class="slot-machine-title">Tanulás</h2>
                <button onclick="closeSlotMachineModal()" class="close-button">✕</button>
            </div>
            
            <!-- Statistics boxes (2x3 grid) -->
            <div class="statistics-grid">
                <div class="stats-row">
                    <div class="stat-box stat-green">
                        <div class="stat-number" id="statCorrect">0</div>
                        <div class="stat-label">Tudom</div>
                    </div>
                    <div class="stat-box stat-yellow">
                        <div class="stat-number" id="statUncertain">0</div>
                        <div class="stat-label">Bizonytalan</div>
                    </div>
                    <div class="stat-box stat-red">
                        <div class="stat-number" id="statLearning">0</div>
                        <div class="stat-label">Tanulandó</div>
                    </div>
                </div>
                <div class="stats-row">
                    <div class="stat-box stat-blue">
                        <div class="stat-number" id="statProgress">0</div>
                        <div class="stat-label">Haladás</div>
                    </div>
                    <div class="stat-box stat-purple">
                        <div class="stat-number" id="statTime">00:00</div>
                        <div class="stat-label">Idő</div>
                    </div>
                    <div class="stat-box stat-orange">
                        <div class="stat-number" id="statSpeed">0.0s</div>
                        <div class="stat-label">Sebesség</div>
                    </div>
                </div>
            </div>
            
            <!-- 3 Cards Row -->
            <div class="cards-container">
                <div class="card-slot" id="card1">
                    <div class="study-card spinning" id="studyCard1">
                        <div class="card-content">
                            <div class="card-term" id="cardTerm1">Loading...</div>
                            <div class="card-definition" id="cardDef1">Loading...</div>
                        </div>
                    </div>
                </div>
                <div class="card-slot" id="card2">
                    <div class="study-card spinning" id="studyCard2">
                        <div class="card-content">
                            <div class="card-term" id="cardTerm2">Loading...</div>
                            <div class="card-definition" id="cardDef2">Loading...</div>
                        </div>
                    </div>
                </div>
                <div class="card-slot" id="card3">
                    <div class="study-card spinning" id="studyCard3">
                        <div class="card-content">
                            <div class="card-term" id="cardTerm3">Loading...</div>
                            <div class="card-definition" id="cardDef3">Loading...</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Feedback Buttons -->
            <div class="feedback-buttons">
                <button class="feedback-btn feedback-correct" onclick="handleFeedback('correct')">
                    <span class="feedback-icon">✓</span>
                    <span class="feedback-text">Tudom</span>
                </button>
                <button class="feedback-btn feedback-uncertain" onclick="handleFeedback('uncertain')">
                    <span class="feedback-icon">?</span>
                    <span class="feedback-text">Bizonytalan</span>
                </button>
                <button class="feedback-btn feedback-learning" onclick="handleFeedback('learning')">
                    <span class="feedback-icon">✗</span>
                    <span class="feedback-text">Tanulandó</span>
                </button>
            </div>
        </div>
    </div>

    <!-- SCRIPTS_CLEANED_OK (lines 2160-11003) -->
    <script>
        // Supabase client from central configuration
        const supabase = window.supabaseClient;

        let currentUser = null;

        // Dashboard data will be loaded from Supabase
        let dashboardData = {
            ownSets: [],
            joinedSets: [],
            invitations: []
        };

        // TESTING: Check auth status but DON'T redirect yet
        async function initDashboard() {
            console.log('DEBUG: Dashboard init started - checking auth status');
            
            try {
                // Check authentication WITHOUT redirect
                const { data: { user }, error } = await supabase.auth.getUser();
                
                if (error) {
                    console.log('DEBUG: Auth error:', error.message);
                } 
                
                if (!user) {
                    console.log('DEBUG: No user found - redirecting to login');
                    window.location.href = '/login.html';
                    return;
                } else {
                    console.log('DEBUG: Auth successful, user:', user.email);
                    currentUser = user;
                }
                
                updateUserInfo();
                
                // Load dashboard data
                console.log('DEBUG: Loading dashboard data...');
                await loadDashboardData();
                console.log('DEBUG: Dashboard data loaded successfully');
                
                // MAGYAR NYELV RÖGZÍTÉSE
                console.log('DEBUG: Magyar nyelv rögzítése...');
                if (typeof snappyI18n !== 'undefined') {
                    // Biztosítjuk hogy magyar nyelvű legyen
                    localStorage.setItem('snappy_user_language', 'hu');
                    snappyI18n.updateAllTexts();
                    console.log('DEBUG: Magyar nyelv rögzítve és szövegek frissítve');
                } else {
                    console.error('DEBUG: snappyI18n not available');
                }
                
            } catch (error) {
                console.error('DEBUG: Error initializing dashboard:', error);
            }
        }

        // Update user info in header
        function updateUserInfo() {
            if (!currentUser) return;

            const userName = document.getElementById('userName');
            const userRole = document.getElementById('userRole');
            const userAvatar = document.getElementById('userAvatar');
            const welcomeTitle = document.getElementById('welcomeTitle');

            // ✅ HELYES: user_profiles táblából adatok lekérése
            // Ez csak display célra, a dashboard már a helyes user számára van
            const firstName = currentUser.user_metadata?.first_name || 'User';
            const role = 'student'; // ✅ Biztosan diák, mert student-dashboardon van
            
            userName.textContent = firstName;
            // Role translation with proper school_admin support
            let roleText = 'Diák'; // default
            if (role === 'teacher') {
                roleText = 'Tanár';
            } else if (role === 'school_admin') {
                roleText = 'Iskola Admin';
            }
            userRole.textContent = roleText;
            userAvatar.textContent = firstName.charAt(0).toUpperCase();
            
            // Update welcome message with user's name (localized)
            console.log('DEBUG: Setting welcome title for user:', firstName);
            updateWelcomeTitle(firstName);
        }

        // Update welcome title with localized text
        function updateWelcomeTitle(firstName) {
            const welcomeTitle = document.getElementById('welcomeTitle');
            if (welcomeTitle && typeof snappyI18n !== 'undefined') {
                const welcomeText = snappyI18n.t('dashboard.welcome', { name: firstName });
                welcomeTitle.textContent = welcomeText;
                console.log('DEBUG: Welcome title updated:', welcomeText);
            } else {
                // Fallback if i18n not available
                if (welcomeTitle) {
            welcomeTitle.textContent = 'Üdvözöllek a Dashboard-on, ' + firstName + '!';
                    console.log('DEBUG: Welcome title fallback used');
                }
            }
        }

        // Load dashboard data from Supabase
        async function loadDashboardData() {
            try {
                // Load flashcard sets
                await loadFlashcardSets();
                
            // Update stats
                document.getElementById('ownSetsCount').textContent = dashboardData.ownSets.length;
                document.getElementById('joinedSetsCount').textContent = dashboardData.joinedSets.length;
            
                const totalCards = dashboardData.ownSets.reduce((sum, set) => sum + set.cardCount, 0) + 
                                  dashboardData.joinedSets.reduce((sum, set) => sum + set.cardCount, 0);
            document.getElementById('totalCards').textContent = totalCards;
            
                const masteredCards = dashboardData.ownSets.reduce((sum, set) => sum + set.masteredCount, 0) + 
                                     dashboardData.joinedSets.reduce((sum, set) => sum + set.masteredCount, 0);
            document.getElementById('masteredCards').textContent = masteredCards;

            // Load sections
            loadOwnSets();
            loadJoinedSets();
            loadInvitations();
                
            } catch (error) {
                console.error('Error loading dashboard data:', error);
            }
        }

        // Load flashcard sets from Supabase
        async function loadFlashcardSets() {
            try {
                // Get user's own sets and public sets (without broken relationship)
                const [ownSetsResponse, publicSetsResponse] = await Promise.all([
                    // User's own sets - simplified query without broken relationship
                    supabase
                        .from('flashcard_sets')
                        .select('id, title, description, created_at, language_a, language_b, language_a_code, language_b_code, flashcard_set_categories (category_id, categories!flashcard_set_categories_category_id_fkey (id, name))')
                        .eq('user_id', currentUser.id),
                    
                    // Public sets (that user didn't create) - simplified query
                    supabase
                        .from('flashcard_sets')
                        .select('id, title, description, created_at, language_a, language_b, language_a_code, language_b_code, flashcard_set_categories (category_id, categories!flashcard_set_categories_category_id_fkey (id, name))')
                        .eq('is_public', true)
                        .neq('user_id', currentUser.id)
                ]);

                if (ownSetsResponse.error) {
                    console.error('Error loading own sets:', ownSetsResponse.error);
                } else {
                    console.log('🔍 DEBUG - Own sets response:', ownSetsResponse.data);
                    if (ownSetsResponse.data && ownSetsResponse.data.length > 0) {
                        console.log('🔍 DEBUG - First set categories:', ownSetsResponse.data[0].flashcard_set_categories);
                        console.log('🔍 DEBUG - Full first set object:', ownSetsResponse.data[0]);
                    }
                }

                if (publicSetsResponse.error) {
                    console.error('Error loading public sets:', publicSetsResponse.error);
                }

                // Process own sets with mastery calculation
                const ownSets = await Promise.all((ownSetsResponse.data || []).map(async set => {
                    console.log(`🔍 DEBUG SZETT: ${set.title}`);
                    console.log('🔍 Set data:', set);
                    
                    // Get card count manually since relationship is broken
                    const { data: setCards, error: cardsError } = await supabase
                        .from('flashcard_set_cards')
                        .select('card_id', { count: 'exact' })
                        .eq('set_id', set.id);
                    
                    const cardCount = cardsError ? 0 : (setCards?.length || 0);
                    console.log(`🔍 Cards count for "${set.title}":`, cardCount);
                    
                    // Get user progress for this set
                    console.log(`🔍 LEKÉRDEZÉS OWN: user_id=${currentUser.id}, set_id=${set.id}`);
                    const { data: progressData, error: progressError } = await supabase
                        .from('user_card_progress')
                        .select('mastery_level, card_id, last_reviewed')
                        .eq('user_id', currentUser.id)
                        .eq('set_id', set.id);
                    
                    if (progressError) {
                        console.error('❌ OWN Progress lekérdezési hiba:', progressError);
                    }
                    console.log('🔍 OWN Progress data for set:', set.title, progressData);
                    
                    // Get total study time for this set
                    const { data: setProgressData, error: setProgressError } = await supabase
                        .from('user_set_progress')
                        .select('total_time_spent')
                        .eq('user_id', currentUser.id)
                        .eq('set_id', set.id)
                        .maybeSingle();
                    
                    const totalTimeSpent = setProgressData?.total_time_spent || 0;
                    console.log('⏱️ OWN Total time spent for set:', set.title, totalTimeSpent, 'seconds');
                    
                    // 📊 RÉSZLETES STATISZTIKÁK: Feedback típusok szerint
                    const tudokCount = (progressData || []).filter(p => p.mastery_level === 3).length;
                    const bizonytalanCount = (progressData || []).filter(p => p.mastery_level === 2).length;
                    const nemTudomCount = (progressData || []).filter(p => p.mastery_level === 1).length;
                    const masteredCount = tudokCount; // backward compatibility
                    
                    console.log('🔍 RÉSZLETES STATS:', {
                        tudom: tudokCount,
                        bizonytalan: bizonytalanCount, 
                        nemTudom: nemTudomCount,
                        osszesen: (progressData || []).length
                    });
                    
                    return {
                    id: set.id,
                    title: set.title,
                    description: set.description || 'Nincs leírás',
                    cardCount: cardCount,
                        masteredCount: masteredCount,
                        // 📊 RÉSZLETES STATISZTIKÁK a szett kártyához
                        tudokCount: tudokCount,
                        bizonytalanCount: bizonytalanCount,
                        nemTudomCount: nemTudomCount,
                        totalStudied: (progressData || []).length,
                        totalTimeSpent: totalTimeSpent, // ⏱️ Összidő
                    createdAt: new Date(set.created_at).toLocaleDateString('hu-HU'),
                    lastStudied: new Date().toLocaleDateString('hu-HU'),
                    language_a: set.language_a || 'English',
                    language_b: set.language_b || 'Magyar',
                    language_a_code: set.language_a_code || 'en',
                    language_b_code: set.language_b_code || 'hu',
                    flashcard_set_categories: set.flashcard_set_categories || []
                    };
                }));

                // Process public sets as "joined" sets with mastery calculation
                const joinedSets = await Promise.all((publicSetsResponse.data || []).map(async set => {
                    console.log(`🔍 DEBUG JOINED SZETT: ${set.title}`);
                    console.log('🔍 Joined Set data:', set);
                    
                    // Get card count manually for joined sets too
                    const { data: setCards, error: cardsError } = await supabase
                        .from('flashcard_set_cards')
                        .select('card_id', { count: 'exact' })
                        .eq('set_id', set.id);
                    
                    const cardCount = cardsError ? 0 : (setCards?.length || 0);
                    console.log(`🔍 Joined Cards count for "${set.title}":`, cardCount);
                    
                    // Get user progress for this set
                    console.log(`🔍 LEKÉRDEZÉS JOINED: user_id=${currentUser.id}, set_id=${set.id}`);
                    const { data: progressData, error: progressError } = await supabase
                        .from('user_card_progress')
                        .select('mastery_level, card_id, last_reviewed')
                        .eq('user_id', currentUser.id)
                        .eq('set_id', set.id);
                    
                    if (progressError) {
                        console.error('❌ JOINED Progress lekérdezési hiba:', progressError);
                    }
                    console.log('🔍 JOINED Progress data for set:', set.title, progressData);
                    
                    // Get total study time for this set
                    const { data: setProgressData, error: setProgressError } = await supabase
                        .from('user_set_progress')
                        .select('total_time_spent')
                        .eq('user_id', currentUser.id)
                        .eq('set_id', set.id)
                        .maybeSingle();
                    
                    const totalTimeSpent = setProgressData?.total_time_spent || 0;
                    console.log('⏱️ JOINED Total time spent for set:', set.title, totalTimeSpent, 'seconds');
                    
                    // 📊 RÉSZLETES STATISZTIKÁK: Feedback típusok szerint (JOINED)
                    const tudokCount = (progressData || []).filter(p => p.mastery_level === 3).length;
                    const bizonytalanCount = (progressData || []).filter(p => p.mastery_level === 2).length;
                    const nemTudomCount = (progressData || []).filter(p => p.mastery_level === 1).length;
                    const masteredCount = tudokCount; // backward compatibility
                    
                    console.log('🔍 JOINED RÉSZLETES STATS:', {
                        tudom: tudokCount,
                        bizonytalan: bizonytalanCount, 
                        nemTudom: nemTudomCount,
                        osszesen: (progressData || []).length
                    });
                    
                    return {
                    id: set.id,
                    title: set.title,
                    description: set.description || 'Nincs leírás',
                    cardCount: cardCount,
                        masteredCount: masteredCount,
                        // 📊 RÉSZLETES STATISZTIKÁK a szett kártyához (JOINED)
                        tudokCount: tudokCount,
                        bizonytalanCount: bizonytalanCount,
                        nemTudomCount: nemTudomCount,
                        totalStudied: (progressData || []).length,
                        totalTimeSpent: totalTimeSpent, // ⏱️ Összidő
                    createdAt: new Date(set.created_at).toLocaleDateString('hu-HU'),
                    joinedAt: new Date(set.created_at).toLocaleDateString('hu-HU'),
                    language_a: set.language_a || 'English',
                    language_b: set.language_b || 'Magyar',
                    language_a_code: set.language_a_code || 'en',
                    language_b_code: set.language_b_code || 'hu',
                    flashcard_set_categories: set.flashcard_set_categories || []
                    };
                }));

                dashboardData.ownSets = ownSets;
                console.log('🔍 DEBUG - Final ownSets stored:', ownSets);
                if (ownSets.length > 0) {
                    console.log('🔍 DEBUG - First stored set categories:', ownSets[0].flashcard_set_categories);
                }
                dashboardData.joinedSets = joinedSets;
                dashboardData.invitations = []; // TODO: Implement invitations

            } catch (error) {
                console.error('Error loading flashcard sets:', error);
            }
        }

        // Load own flashcard sets
        function loadOwnSets(filteredSets = null) {
            const grid = document.getElementById('ownSetsGrid');
            const setsToShow = filteredSets || dashboardData.ownSets;
            
            if (setsToShow.length === 0) {
                if (filteredSets && dashboardData.ownSets.length > 0) {
                    // Show "no results" message when filtering
                    grid.innerHTML = '<div class="empty-state">' +
                        '<div class="empty-icon">🔍</div>' +
                        '<h3 class="empty-title">Nincs találat</h3>' +
                        '<p class="empty-description">Próbálj meg másik keresési kifejezést!</p>' +
                        '<button class="btn-icon" onclick="clearOwnSetsSearch()">' +
                            '<svg class="lucide-icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">' +
                                '<path d="M18 6 6 18"/>' +
                                '<path d="m6 6 12 12"/>' +
                            '</svg>' +
                            'Keresés törlése' +
                        '</button>' +
                    '</div>';
                } else {
                    // Show "no sets" message when no sets exist
                grid.innerHTML = '<div class="empty-state">' +
                    '<div class="empty-icon"></div>' +
                    '<h3 class="empty-title">Még nincs szettjed</h3>' +
                    '<p class="empty-description">Hozd létre az első szókártya szettjdet!</p>' +
                    '<button class="add-btn" onclick="createNewSet()">' +
                        '<span>+</span>' +
                        'Új szett létrehozása' +
                    '</button>' +
                '</div>';
                }
                return;
            }

            grid.innerHTML = setsToShow.map(set => createSetCard(set, 'own')).join('');
            lucide.createIcons();
        }

        // Debounce timer for search
        let searchTimeout = null;

        // Debounced filter function
        function debounceFilterOwnSets(query) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterOwnSets(query);
                // Update clear all filters button state
                updateClearAllFiltersBtn();
            }, 300); // 300ms delay
        }

        // Handle search mode change
        function onSearchModeChange() {
            const searchInput = document.getElementById('ownSetsSearch');
            const currentQuery = searchInput.value;
            
            // Update placeholder based on selected mode
            const searchMode = document.getElementById('searchModeSelect').value;
            switch (searchMode) {
                case 'all':
                    searchInput.placeholder = '🔍 Keresés szettekben...';
                    break;
                case 'sets':
                    searchInput.placeholder = '🔍 Keresés szett nevekben...';
                    break;
                case 'cards':
                    searchInput.placeholder = '📝 Keresés kártyákban...';
                    break;
            }
            
            // Update clear all filters button state
            updateClearAllFiltersBtn();
            
            // Re-run search if there's a query
            if (currentQuery.trim()) {
                debounceFilterOwnSets(currentQuery);
            }
        }

        // Load sets and cards when TAG filter is active (with optional text search)
        async function loadSetsAndCardsWithTagFilter(filteredSets) {
            const searchQuery = document.getElementById('ownSetsSearch').value.toLowerCase().trim();
            const container = document.getElementById('ownSetsGrid');
            
            console.log('🏷️ TAG szűrés aktív:', selectedTagFiltersList);
            console.log('🔍 Keresési szöveg:', searchQuery || 'nincs');
            
            // Show sets first
            let setsHTML = '';
            if (filteredSets.length > 0) {
                setsHTML = filteredSets.map(set => createSetCard(set, 'own')).join('');
            }
            
            // Collect all cards from filtered sets
            let allCards = [];
            
            for (const set of filteredSets) {
                try {
                    // Get cards for this set with categories
                    const { data: cards, error } = await supabase
                        .from('flashcard_set_cards')
                        .select(`
                            cards (
                                id,
                                title,
                                english_title
                            )
                        `)
                        .eq('set_id', set.id);
                    
                    if (error) {
                        console.error('Error loading cards for set:', set.id, error);
                        continue;
                    }
                    
                    // Add cards with set info - filter by search query and TAG filters
                    if (cards && cards.length > 0) {
                        cards.forEach(cardWrapper => {
                            if (cardWrapper.cards) {
                                const card = cardWrapper.cards;
                                const title = card.title || '';
                                const englishTitle = card.english_title || '';
                                // Check if card matches TAG filters via card_categories junction table
                                let tagMatches = true;
                                if (selectedTagFiltersList.length > 0) {
                                    // We'll implement card tag filtering later when we load card tags
                                    // For now, let all cards through and filter them after loading their tags
                                    tagMatches = true;
                                }
                                
                                // If there's a search query, check if card matches
                                if (searchQuery) {
                                    const titleMatch = title.toLowerCase().includes(searchQuery);
                                    const englishTitleMatch = englishTitle.toLowerCase().includes(searchQuery);
                                    
                                    // Only add card if it matches the search query AND tag filters
                                    if (titleMatch || englishTitleMatch) {
                                        allCards.push({
                                            id: card.id,
                                            title: title || '-',
                                            englishTitle: englishTitle || '-',
                                            setName: set.title,
                                            setId: set.id,
                                            tags: [], // Will be loaded from card_categories
                                            cardId: card.id
                                        });
                                    }
                                } else {
                                    // No search query, add card if it matches tag filters
                                    allCards.push({
                                        id: card.id,
                                        title: title || '-',
                                        englishTitle: englishTitle || '-',
                                        setName: set.title,
                                        setId: set.id,
                                        tags: [], // Will be loaded from card_categories
                                        cardId: card.id
                                    });
                                }
                            }
                        });
                    }
                    
                } catch (error) {
                    console.error('Error loading cards for set:', set.id, error);
                }
            }
            
            // Load tags for all cards and filter by selected tags
            if (allCards.length > 0) {
                const cardIds = allCards.map(card => card.cardId);
                
                // Get all card-category relationships for these cards
                const { data: cardCategories, error: cardCategoriesError } = await supabase
                    .from('card_categories')
                    .select(`
                        card_id,
                        categories (
                            id,
                            name
                        )
                    `)
                    .in('card_id', cardIds);
                
                if (!cardCategoriesError && cardCategories) {
                    // Create a map of card_id -> tags
                    const cardTagsMap = {};
                    cardCategories.forEach(cc => {
                        if (!cardTagsMap[cc.card_id]) {
                            cardTagsMap[cc.card_id] = [];
                        }
                        if (cc.categories) {
                            cardTagsMap[cc.card_id].push(cc.categories.name);
                        }
                    });
                    
                    // Update allCards with their tags and filter by selected tags
                    allCards = allCards.map(card => ({
                        ...card,
                        tags: cardTagsMap[card.cardId] || []
                    })).filter(card => {
                        // Apply tag filtering if tags are selected
                        if (selectedTagFiltersList.length > 0) {
                            return selectedTagFiltersList.some(selectedTag => 
                                card.tags.some(cardTag => cardTag.toLowerCase() === selectedTag.toLowerCase())
                            );
                        }
                        return true;
                    });
                }
            }
            
            // Generate cards table HTML
            let cardsHTML = '';
            if (allCards.length > 0) {
                cardsHTML = `
                    <div style="margin-top: 32px; padding-top: 24px; border-top: 2px solid #e5e7eb;">
                        <h3 style="margin: 0 0 16px 0; color: #374151; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                            📝 Szavak (${allCards.length})
                        </h3>
                        <div style="background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #f8fafc; border-bottom: 2px solid #e5e7eb;">
                                        <th style="padding: 16px 20px; text-align: left; font-weight: 600; color: #374151;">Magyar</th>
                                        <th style="padding: 16px 20px; text-align: left; font-weight: 600; color: #374151;">Angol</th>
                                        <th style="padding: 16px 20px; text-align: left; font-weight: 600; color: #374151;">TAG-ek</th>
                                        <th style="padding: 16px 20px; text-align: left; font-weight: 600; color: #374151;">Szett</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${allCards.map((card, index) => `
                                        <tr style="border-bottom: 1px solid #f1f5f9; transition: background 0.2s ease;" onmouseover="this.style.background='#f8fafc'" onmouseout="this.style.background='white'">
                                            <td style="padding: 12px 20px; color: #374151; font-weight: 500;">${card.title}</td>
                                            <td style="padding: 12px 20px; color: #6b7280;">${card.englishTitle}</td>
                                            <td style="padding: 12px 20px; color: #7c3aed; font-size: 13px; font-weight: 500;">${Array.isArray(card.tags) ? card.tags.join(', ') : (card.tags || '-')}</td>
                                            <td style="padding: 12px 20px; color: #667eea; font-size: 14px;">${card.setName}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            }
            
            // Simple display: just show the sets directly like normal
            if (filteredSets.length > 0) {
                container.innerHTML = setsHTML;
                lucide.createIcons();
            } else {
                const message = searchQuery 
                    ? `Nincs találat a "${searchQuery}" keresésre a választott TAG-ekkel`
                    : `Nincs találat a választott TAG-ekre`;
                    
                container.innerHTML = `
                    <div style="text-align: center; padding: 48px 20px; color: #9ca3af;">
                        <div style="font-size: 48px; margin-bottom: 16px;">🏷️</div>
                        <p style="font-size: 18px; margin: 0 0 8px 0;">${message}</p>
                        <p style="font-size: 14px; margin: 0; opacity: 0.7;">Próbáld meg más TAG-eket vagy keresési kifejezéseket</p>
                    </div>
                `;
            }
        }

        // Filter own sets based on search query, selected mode, and tag filters
        async function filterOwnSets(query) {
            const searchInput = document.getElementById('ownSetsSearch');
            const clearBtn = searchInput.parentElement.querySelector('.search-clear');
            const searchMode = document.getElementById('searchModeSelect').value;
            
            // Show/hide clear button
            if (query.trim()) {
                clearBtn.style.display = 'flex';
            } else {
                clearBtn.style.display = 'none';
            }
            
            // Apply tag filters first
            let setsToSearch = dashboardData.ownSets;
            
            if (selectedTagFiltersList.length > 0) {
                console.log('🏷️ Filtering by tags:', selectedTagFiltersList);
                
                setsToSearch = dashboardData.ownSets.filter(set => {
                    console.log('🔍 Checking set:', set.title, 'categories:', set.flashcard_set_categories);
                    
                    // Check if this set has ALL selected tags
                    if (!set.flashcard_set_categories || set.flashcard_set_categories.length === 0) {
                        console.log('❌ No categories for set:', set.title);
                        return false; // No categories, cannot match any tag filter
                    }
                    
                    const setTagNames = set.flashcard_set_categories
                        .map(cat => cat.categories && cat.categories.name)
                        .filter(name => name); // Remove null/undefined
                    
                    console.log('🏷️ Set tag names:', setTagNames, 'selected:', selectedTagFiltersList);
                    
                    // Check if ALL selected tags are present in this set (AND logic)
                    const matches = selectedTagFiltersList.every(selectedTag => 
                        setTagNames.includes(selectedTag)
                    );
                    console.log('✅ Set matches:', matches);
                    return matches;
                });
                
                console.log(`🏷️ After tag filtering: ${setsToSearch.length} sets`);
            }
            
            // If we have tag filters, always use enhanced filtering (works with or without search query)
            if (selectedTagFiltersList.length > 0) {
                await loadSetsAndCardsWithTagFilter(setsToSearch);
                return;
            }
            
            // If query is empty and no tag filters, show all sets
            if (!query.trim()) {
                loadOwnSets();
                return;
            }
            
            // Normalize query for better search
            const normalizedQuery = query.toLowerCase().trim();
            
            console.log('🔍 Searching for:', normalizedQuery, 'Mode:', searchMode);
            
            let allMatches = [];
            
            // Search based on selected mode
            if (searchMode === 'all' || searchMode === 'sets') {
                // Get sets that match in metadata (search within tag-filtered sets)
                const metadataMatches = setsToSearch.filter(set => {
                    // Search in title
                    const titleMatch = set.title.toLowerCase().includes(normalizedQuery);
                    
                    // Search in description
                    const descriptionMatch = set.description.toLowerCase().includes(normalizedQuery);
                    
                    // Search in language names
                    const languageAMatch = translateLanguageName(set.language_a).toLowerCase().includes(normalizedQuery);
                    const languageBMatch = translateLanguageName(set.language_b).toLowerCase().includes(normalizedQuery);
                    
                    // Search in categories/tags if available
                    const categoriesMatch = set.flashcard_set_categories && 
                        set.flashcard_set_categories.some(cat => 
                            cat.categories && cat.categories.name.toLowerCase().includes(normalizedQuery)
                        );
                    
                    return titleMatch || descriptionMatch || languageAMatch || languageBMatch || categoriesMatch;
                });
                
                allMatches = [...metadataMatches];
                console.log(`Found ${metadataMatches.length} sets in metadata`);
            }
            
            if (searchMode === 'all' || searchMode === 'cards') {
                // Search in cards content
                const cardMatches = [];
                
                for (const set of setsToSearch) {
                    try {
                        // Skip if already matched by metadata (only in 'all' mode)
                        if (searchMode === 'all' && allMatches.includes(set)) continue;
                        
                        // Get cards for this set
                        const { data: cards, error } = await supabase
                            .from('flashcard_set_cards')
                            .select(`
                                cards (
                                    title,
                                    english_title,
                                    title_formatted,
                                    english_title_formatted
                                )
                            `)
                            .eq('set_id', set.id);
                        
                        if (error) {
                            console.error('Error loading cards for set:', set.id, error);
                            continue;
                        }
                        
                        // Check if any card matches the query
                        const hasMatchingCard = cards && cards.some(cardWrapper => {
                            const card = cardWrapper.cards;
                            if (!card) return false;
                            
                            const titleMatch = (card.title || '').toLowerCase().includes(normalizedQuery);
                            const englishTitleMatch = (card.english_title || '').toLowerCase().includes(normalizedQuery);
                            const titleFormattedMatch = (card.title_formatted || '').toLowerCase().includes(normalizedQuery);
                            const englishTitleFormattedMatch = (card.english_title_formatted || '').toLowerCase().includes(normalizedQuery);
                            
                            return titleMatch || englishTitleMatch || titleFormattedMatch || englishTitleFormattedMatch;
                        });
                        
                        if (hasMatchingCard) {
                            console.log('📝 Found cards match in set:', set.title);
                            cardMatches.push(set);
                        }
                        
                    } catch (error) {
                        console.error('Error searching cards in set:', set.id, error);
                    }
                }
                
                // Combine or replace matches based on mode
                if (searchMode === 'all') {
                    allMatches = [...allMatches, ...cardMatches];
                } else {
                    allMatches = cardMatches;
                }
                
                console.log(`📝 Found ${cardMatches.length} sets in cards`);
            }
            
            console.log(`✅ Total found: ${allMatches.length} sets (Mode: ${searchMode})`);
            
            // Load filtered results - if tag filters are active, use enhanced view
            if (selectedTagFiltersList.length > 0) {
                await loadSetsAndCardsWithTagFilter(allMatches);
            } else {
                loadOwnSets(allMatches);
            }
        }

        // Clear search and show all sets
        function clearOwnSetsSearch() {
            const searchInput = document.getElementById('ownSetsSearch');
            const clearBtn = searchInput.parentElement.querySelector('.search-clear');
            
            searchInput.value = '';
            clearBtn.style.display = 'none';
            
            // Update clear all filters button state
            updateClearAllFiltersBtn();
            
            // If we have tag filters, keep them and show filtered results
            if (selectedTagFiltersList.length > 0) {
                filterOwnSets(''); // Will trigger tag-only filtering
            } else {
                loadOwnSets(); // Show all sets
            }
            
            searchInput.focus();
        }

        // Load joined flashcard sets
        function loadJoinedSets() {
            const grid = document.getElementById('joinedSetsGrid');
            
            if (dashboardData.joinedSets.length === 0) {
                grid.innerHTML = `
                    <div class="flashcard-set placeholder-card">
                        <div class="set-header">
                            <div>
                                <h3 class="set-title">🎯 Csatlakozz egy szetthez!</h3>
                            </div>
                        </div>
                        <p class="set-description">Várj meghívóra egy tanártól, vagy kérj hozzáférést egy meglévő szetthez. Itt jelennek majd meg a szettek, amikhez csatlakoztál.</p>
                        <div class="progress-bar">
                            <div class="progress-fill placeholder-progress"></div>
                        </div>
                        <div class="placeholder-actions">
                            <div class="placeholder-tip">💡 Tipp: Kérd meg a tanárod, hogy küldjön meghívót!</div>
                        </div>
                        <div class="set-mini-stats">
                            <span style="color: #94a3b8;">✅ 0 tudom  ⚠️ 0 bizonytalan  ❌ 0 nem tudom</span>
                            <span style="color: #94a3b8;">0/0 tanult</span>
                            <span style="color: #94a3b8;">Várakozás...</span>
                        </div>
                        <div class="set-meta">
                            <span style="color: #94a3b8;">Még nincs csatlakozott szett</span>
                        </div>
                    </div>
                `;
                return;
            }

            grid.innerHTML = dashboardData.joinedSets.map(set => createSetCard(set, 'joined')).join('');
            lucide.createIcons();
        }

        // Load invitations
        function loadInvitations() {
            const section = document.getElementById('invitationsSection');
            const list = document.getElementById('invitationsList');
            
            if (dashboardData.invitations.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            list.innerHTML = dashboardData.invitations.map(createInvitationCard).join('');
        }

        // Helper function to format time from seconds to MM:SS
        function formatTime(seconds) {
            if (!seconds || seconds === 0) return '00:00';
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // Create flashcard set card
        function createSetCard(set, type) {
            const progress = Math.round((set.masteredCount / set.cardCount) * 100);
            


            // Action buttons for own sets
            let actionButtons = '';
            if (type === 'own') {
                actionButtons = 
                        '<button class="action-btn add" onclick="event.stopPropagation(); addCardsToSet(\'' + set.id + '\')" title="Új kártya">' +
                            '<i data-lucide="plus"></i>' +
                        '</button>' +
                        '<button class="action-btn edit" onclick="event.stopPropagation(); editSet(\'' + set.id + '\')" title="Szerkesztés">' +
                            '<i data-lucide="pencil"></i>' +
                        '</button>' +
                        '<button class="action-btn list" onclick="event.stopPropagation(); showCardsList(\'' + set.id + '\')" title="Lista nézet">' +
                            '<i data-lucide="list"></i>' +
                        '</button>' +
                        '<button class="action-btn import" onclick="event.stopPropagation(); importCards(\'' + set.id + '\')" title="Import">' +
                            '<i data-lucide="upload"></i>' +
                        '</button>' +
                        '<button class="action-btn delete" onclick="event.stopPropagation(); deleteSet(\'' + set.id + '\')" title="Törlés">' +
                            '<i data-lucide="trash"></i>' +
                        '</button>';
            } else {
                actionButtons = 
                        '<button class="action-btn list" onclick="event.stopPropagation(); showCardsList(\'' + set.id + '\')" title="Lista nézet">' +
                            '<i data-lucide="list"></i>' +
                        '</button>' +
                        '<button class="action-btn leave" onclick="event.stopPropagation(); leaveSet(\'' + set.id + '\')" title="Szett elhagyása">' +
                            '<i data-lucide="log-out"></i>' +
                        '</button>';
            }

            return '<div class="flashcard-set" data-set-id="' + set.id + '" data-direction="AtoB" tabindex="0" onkeydown="handleCardKeydown(event, \'' + set.id + '\')" onclick="flipCard(this)" style="animation: highlight-flash 0.5s ease-out;">' +
                    '<div class="card-inner">' +
                        '<div class="card-face card-front">' +
                            '<div class="set-header">' +
                                '<div>' +
                                    '<h3 class="set-title">' + set.title + '</h3>' +
                                '</div>' +
                            '</div>' +
                            '<p class="set-description">' + set.description + '</p>' +
                            '<div class="progress-bar">' +
                                '<div class="progress-fill" style="width: ' + progress + '%"></div>' +
                            '</div>' +
                            '<div class="set-actions">' +
                                '<button class="action-btn study" onclick="event.stopPropagation(); openStudyMode(\'' + set.id + '\')" title="Tanulás indítása" aria-label="Tanulás indítása">' +
                                    '<i data-lucide="play-circle"></i>' +
                                '</button>' +
                                actionButtons +
                            '</div>' +
                            '<div class="set-stats-2row">' +
                                '<div class="row1">' +
                                    '<div class="status-indicator green"><i data-lucide="check" width="16" height="16"></i>' + (set.tudokCount || 0) + '</div>' +
                                    '<div class="status-indicator yellow"><i data-lucide="alert-triangle" width="16" height="16"></i>' + (set.bizonytalanCount || 0) + '</div>' +
                                    '<div class="status-indicator red"><i data-lucide="x" width="16" height="16"></i>' + (set.nemTudomCount || 0) + '</div>' +
                                '</div>' +
                                '<div class="row2">' +
                                    '<div class="left">' +
                                        '<button class="language-pair clickable" onclick="event.stopPropagation(); toggleSetDirection(\'' + set.id + '\')" title="Irány váltása" style="background: none; border: none; color: inherit; font: inherit; cursor: pointer; text-decoration: underline;">' + translateLanguageName(set.language_a) + ' → ' + translateLanguageName(set.language_b) + '</button>' +
                                    '</div>' +
                                    '<div class="right">' +
                                        '<span class="progress-text">' + (set.totalStudied || 0) + '/' + set.cardCount + '</span>' +
                                        '<div class="time-indicator"><i data-lucide="clock" width="18" height="18"></i>' + formatTime(set.totalTimeSpent || 0) + '</div>' +
                                        '<span class="study-date">' + (type === 'own' ? set.lastStudied : (set.joinedAt || set.createdAt)) + '</span>' +
                                    '</div>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                        '<div class="card-face card-back">' +
                            '<img class="card-back-image" src="' + (set.image_url || 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=300&fit=crop&crop=face') + '" alt="' + set.title + '">' +
                            '<div class="card-back-title">' + set.title + '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>';
        }

        // 🔄 Toggle direction on set card and refresh statistics  
        async function toggleSetDirection(setId) {
            const setCard = document.querySelector(`[data-set-id="${setId}"]`);
            if (!setCard) return;
            
            const currentDirection = setCard.getAttribute('data-direction');
            const newDirection = currentDirection === 'AtoB' ? 'BtoA' : 'AtoB';
            
            // Update data attribute
            setCard.setAttribute('data-direction', newDirection);
            
            // Get language pair element and set info
            const languagePair = setCard.querySelector('.language-pair');
            const setData = [...(dashboardData.ownSets || []), ...(dashboardData.joinedSets || [])].find(s => s.id === setId);
            
            if (languagePair && setData) {
                // Update language pair text
                if (newDirection === 'AtoB') {
                    languagePair.textContent = translateLanguageName(setData.language_a) + ' → ' + translateLanguageName(setData.language_b);
                } else {
                    languagePair.textContent = translateLanguageName(setData.language_b) + ' → ' + translateLanguageName(setData.language_a);
                }
                
                // Load direction-specific statistics
                await loadDirectionSpecificStats(setId, newDirection, setCard);
            }
        }
        
        // 📊 Load statistics for specific direction
        async function loadDirectionSpecificStats(setId, direction, setCard) {
            try {
                // Get direction-specific progress
                const { data: progressData, error } = await supabase
                    .from('user_card_progress')
                    .select('mastery_level, last_reviewed')
                    .eq('user_id', currentUser.id)
                    .eq('set_id', setId)
                    .eq('direction', direction);
                    
                if (error) throw error;
                
                // Get direction-specific total study time
                const { data: sessionData, error: sessionError } = await supabase
                    .from('study_sessions')
                    .select('total_duration')
                    .eq('user_id', currentUser.id)
                    .eq('set_id', setId)
                    .eq('direction', direction)
                    .not('total_duration', 'is', null);
                    
                if (sessionError) {
                    console.error('Session time lekérdezési hiba:', sessionError);
                }
                
                // Calculate total study time for this direction
                const totalTimeSpent = (sessionData || []).reduce((sum, session) => sum + (session.total_duration || 0), 0);
                
                // Calculate stats
                const tudokCount = progressData?.filter(p => p.mastery_level === 3).length || 0;
                const bizonytalanCount = progressData?.filter(p => p.mastery_level === 2).length || 0;
                const nemTudomCount = progressData?.filter(p => p.mastery_level === 1).length || 0;
                const totalStudied = progressData?.length || 0; // ✅ HELYES: Megnézve = MINDEN amit láttál (tudom+bizonytalan+tanulandó)
                
                // Get set card count
                const setData = [...(dashboardData.ownSets || []), ...(dashboardData.joinedSets || [])].find(s => s.id === setId);
                const totalCards = setData?.cardCount || 0;
                
                // Update UI elements
                const greenIndicator = setCard.querySelector('.status-indicator.green');
                const yellowIndicator = setCard.querySelector('.status-indicator.yellow');
                const redIndicator = setCard.querySelector('.status-indicator.red');
                const progressText = setCard.querySelector('.progress-text');
                const progressBar = setCard.querySelector('.progress-fill');
                const timeIndicator = setCard.querySelector('.time-indicator');
                
                if (greenIndicator) greenIndicator.innerHTML = '<i data-lucide="check" width="16" height="16"></i>' + tudokCount;
                if (yellowIndicator) yellowIndicator.innerHTML = '<i data-lucide="alert-triangle" width="16" height="16"></i>' + bizonytalanCount;
                if (redIndicator) redIndicator.innerHTML = '<i data-lucide="x" width="16" height="16"></i>' + nemTudomCount;
                if (progressText) progressText.textContent = totalStudied + '/' + totalCards;
                if (timeIndicator) timeIndicator.innerHTML = '<i data-lucide="clock" width="18" height="18"></i>' + formatTime(totalTimeSpent);
                
                // Update progress bar
                const progress = totalCards > 0 ? Math.round((tudokCount / totalCards) * 100) : 0;
                if (progressBar) progressBar.style.width = progress + '%';
                
                console.log(`📊 Direction ${direction} stats: ${tudokCount}/${bizonytalanCount}/${nemTudomCount} (${totalStudied}/${totalCards}) ⏱️${totalTimeSpent}s`);
                
            } catch (error) {
                console.error('Direction stats betöltési hiba:', error);
            }
        }

        // Create invitation card
        function createInvitationCard(invitation) {
            return '<div class="invitation-card">' +
                    '<div class="invitation-header">' +
                        '<div>' +
                            '<h4 class="invitation-title">' + invitation.setTitle + '</h4>' +
                            '<p class="invitation-from">Meghívó tőle: ' + invitation.fromTeacher + '</p>' +
                        '</div>' +
                        '<div class="invitation-actions">' +
                            '<button class="accept-btn" onclick="acceptInvitation(' + invitation.id + ')">Elfogadom</button>' +
                            '<button class="decline-btn" onclick="declineInvitation(' + invitation.id + ')">Elutasítom</button>' +
                        '</div>' +
                    '</div>' +
                '</div>';
        }

        // Event handlers
        function createNewSet() {
            openCreateSetModal();
        }
        
        // Make functions globally accessible for onclick events
        // Note: These will be assigned after the functions are defined below

        // Modal functions
        function openCreateSetModal() {
            // Get default languages based on browser language
            const defaults = getDefaultLanguages();
            
            // Initialize language dropdowns
            document.getElementById('languageAContainer').innerHTML = createLanguageDropdown('languageA', defaults.a, 'Keress nyelveket...', false);
            document.getElementById('languageBContainer').innerHTML = createLanguageDropdown('languageB', defaults.b, 'Keress nyelveket...', true);
            
            const modal = document.getElementById('createSetModal');
            modal.classList.add('active');
            document.getElementById('setTitle').focus();
        }

        function closeCreateSetModal() {
            const modal = document.getElementById('createSetModal');
            modal.classList.remove('active');
            
            // Reset form
            document.getElementById('createSetForm').reset();
            
            // Clear tag selection
            createSelectedTagsList = [];
            const selectedTagsContainer = document.getElementById('createSelectedTags');
            if (selectedTagsContainer) {
                selectedTagsContainer.innerHTML = '';
            }
            
            // Hide tag suggestions
            const suggestions = document.getElementById('createTagSuggestions');
            if (suggestions) {
                suggestions.style.display = 'none';
            }
        }

        // Handle form submission
        document.getElementById('createSetForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const submitBtn = document.getElementById('createSetBtn');
            const originalText = submitBtn.innerHTML;
            
            try {
                // Disable button and show loading
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span>⏳</span> Létrehozás...';
                
                const title = document.getElementById('setTitle').value.trim();
                const description = document.getElementById('setDescription').value.trim();
                const languageAName = document.getElementById('languageA').value.trim();
                const languageBName = document.getElementById('languageB').value.trim();
                
                if (!title) {
                    throw new Error('A szett címe kötelező!');
                }

                if (!languageAName) {
                    throw new Error('Az A nyelv kiválasztása kötelező!');
                }
                
                if (!languageBName) {
                    throw new Error('A B nyelv kiválasztása kötelező!');
                }
                
                // Create new flashcard set
                const { data, error } = await supabase
                    .from('flashcard_sets')
                    .insert({
                        title: title,
                        description: description || null,
                        user_id: currentUser.id,
                        is_public: false,
                        language_a: translateToEnglish(languageAName),
                        language_b: translateToEnglish(languageBName)
                    })
                    .select()
                    .single();
                
                if (error) {
                    throw error;
                }
                
                const newSetId = data.id;
                
                // Handle categories (tags) if any were selected
                if (createSelectedTagsList && createSelectedTagsList.length > 0) {
                    console.log('DEBUG - createNewSet: Adding tags:', createSelectedTagsList);
                    
                    // Resolve or create categories
                    const categories = [];
                    for (const tagName of createSelectedTagsList) {
                        let { data: existingCategory, error: searchError } = await supabase
                            .from('categories')
                            .select('id, name')
                            .eq('name', tagName)
                            .maybeSingle();
                        
                        if (searchError && searchError.code !== 'PGRST116') {
                            console.error('Error searching category:', searchError);
                            continue;
                        }
                        
                        let categoryId;
                        if (existingCategory) {
                            categoryId = existingCategory.id;
                            console.log('DEBUG - Using existing category:', existingCategory);
                        } else {
                            // Create new category
                            const { data: newCategory, error: createError } = await supabase
                                .from('categories')
                                .insert({ name: tagName })
                                .select()
                                .single();
                            
                            if (createError) {
                                console.error('Error creating category:', createError);
                                continue;
                            }
                            
                            categoryId = newCategory.id;
                            console.log('DEBUG - Created new category:', newCategory);
                        }
                        
                        categories.push({
                            flashcard_set_id: newSetId,
                            category_id: categoryId
                        });
                    }
                    
                    // Insert flashcard_set_categories relationships
                    if (categories.length > 0) {
                        const { error: categoryError } = await supabase
                            .from('flashcard_set_categories')
                            .insert(categories);
                        
                        if (categoryError) {
                            console.error('Error creating set-category relationships:', categoryError);
                        } else {
                            console.log('DEBUG - Categories associated with set successfully!');
                        }
                    }
                }
                
                // Success feedback
                submitBtn.innerHTML = '<span></span> Létrehozva!';
                
                // Close modal after a brief delay
                setTimeout(() => {
                    closeCreateSetModal();
                    
                    // Reload dashboard data to show new set
                    loadDashboardData();
                    
                    // Show success message
                    showSuccessMessage('"' + title + '" szett sikeresen létrehozva!');
                }, 1000);
                
            } catch (error) {
                console.error('Error creating set:', error);
                
                // Show error message
                showErrorMessage(error.message || 'Hiba történt a szett létrehozásakor');
                
                // Reset button
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalText;
            }
        });

        // Success/Error message functions
        function showSuccessMessage(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                color: white;
                padding: 16px 24px;
                border-radius: 16px;
                box-shadow: 0 8px 32px rgba(34, 197, 94, 0.4);
                z-index: 10000;
                font-weight: 600;
                animation: slideInRight 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function showErrorMessage(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                color: white;
                padding: 16px 24px;
                border-radius: 16px;
                box-shadow: 0 8px 32px rgba(239, 68, 68, 0.4);
                z-index: 10000;
                font-weight: 600;
                animation: slideInRight 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 4000);
        }

        // Close modal when clicking outside
        document.getElementById('createSetModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeCreateSetModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const createModal = document.getElementById('createSetModal');
                const addCardsModal = document.getElementById('addCardsModal');
                
                if (createModal.classList.contains('active')) {
                    closeCreateSetModal();
                } else if (addCardsModal.classList.contains('active')) {
                    closeAddCardsModal();
                }
            }
        });

        // Close add cards modal when clicking outside
        document.getElementById('addCardsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeAddCardsModal();
            }
        });

        function openSet(setId, type) {
            console.log('DEBUG: openSet called with:', { setId, type });
            // Navigate to slot machine page
            window.location.href = 'slot-machine.html?setId=' + setId;
        }

        function openStudyMode(setId) {
            console.log('DEBUG: openStudyMode called with:', { setId });
            window.location.href = 'study.html?setId=' + setId;
        }

        function flipCard(cardElement) {
            if (cardElement.classList.contains('flipped')) {
                cardElement.classList.remove('flipped');
            } else {
                cardElement.classList.add('flipped');
            }
        }

        function handleCardKeydown(event, setId) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                flipCard(event.currentTarget);
            }
        }

        // Helper function to close all dropdowns
        function closeAllDropdowns() {
            document.querySelectorAll('.dropdown-menu.active').forEach(menu => {
                menu.classList.remove('active');
                menu.style.cssText = '';
                menu.removeAttribute('style');
            });
        }

        function showSetOptions(buttonElement, setId, type) {
            // Close all other dropdowns first
            closeAllDropdowns();

            // Toggle the clicked dropdown
            const dropdown = document.getElementById('dropdown-' + setId);
            
            if (dropdown) {
                // Force DOM reflow
                dropdown.offsetHeight;
                
                // Simply add active class - CSS will handle the rest
                dropdown.classList.add('active');
            }
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.set-options')) {
                closeAllDropdowns();
            }
                });

        // Close dropdowns when pressing ESC
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeAllDropdowns();
            }
        });

        // Add cards to set function
        function addCardsToSet(setId) {
            // Close dropdown
            closeAllDropdowns();
            // Open add cards modal
            openAddCardsModal(setId);
        }

        // Add Cards Modal functions
        let currentSetId = null;

        function openAddCardsModal(setId) {
            currentSetId = setId;
            const modal = document.getElementById('addCardsModal');
            const set = dashboardData.ownSets.find(set => set.id === setId);
            
            if (!set) {
                showErrorMessage('Szett nem található!');
                return;
            }
            
            const languageA = translateLanguageName(set.language_a) || 'Magyar';
            const languageB = translateLanguageName(set.language_b) || 'Angol';
            
            document.getElementById('addCardsSetTitle').textContent = 
                'Új szókártyák hozzáadása a "' + set.title + '" szetthez (' + languageA + ' → ' + languageB + ')';
            
            // Generate dynamic form
            generateAddCardsForm(languageA, languageB);
            
            modal.classList.add('active');
            
            // Set higher z-index for edit modal
            const modalContainer = document.getElementById('modalContainer');
            if (modalContainer) {
                modalContainer.style.zIndex = '20000';
            }
            
            // Focus first input after a brief delay
            setTimeout(() => {
                const firstInput = modal.querySelector('input, textarea');
                if (firstInput) firstInput.focus();
            }, 100);
        }

        function generateAddCardsForm(languageA, languageB) {
            const container = document.getElementById('addCardsFormContainer');
            
            container.innerHTML = `
                <form id="addCardsForm" style="max-width: none; padding-bottom: 20px;">
                    <div style="background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.3); padding: 24px; margin-bottom: 16px;">
                        
                        <!-- Card Preview Section -->
                        <div id="cardPreview" style="margin-bottom: 24px; display: none;">
                            
                            <!-- Delete Media Button - fölül középen -->
                            <div style="text-align: center; margin-bottom: 16px;">
                                <button type="button" 
                                        id="deleteMediaBtn"
                                        onclick="deleteUploadedImage()" 
                                        style="display: none; padding: 8px 16px; background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(8px);"
                                        onmouseover="this.style.background='rgba(239, 68, 68, 0.15)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.2)';"
                                        onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                     Média törlése
                                </button>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                                
                                <!-- A Language Card -->
                                <div style="background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(12px); border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 20px; padding: 0; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); position: relative; overflow: hidden;">
                                    
                                    <!-- Media at top -->
                                    <div id="previewMediaContainer" style="position: relative; min-height: 220px; border-bottom: 1px solid rgba(102, 126, 234, 0.1); display: flex; align-items: center; justify-content: center; color: #94a3b8; font-size: 14px; background: rgba(102, 126, 234, 0.02);">
                                        <div style="text-align: center; color: #94a3b8;">
                                            <div style="font-size: 32px; margin-bottom: 8px;">📷</div>
                                            <div style="font-size: 12px;">Kép vagy média</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Text at bottom -->
                                    <div style="padding: 24px; text-align: center;">
                                        <div id="previewWordA" style="font-size: 24px; font-weight: 700; color: #000000; min-height: 40px; line-height: 1.2;">
                                            -
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- B Language Card -->
                                <div style="background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(12px); border: 2px solid rgba(126, 58, 237, 0.2); border-radius: 20px; padding: 0; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); position: relative; overflow: hidden;">
                                    
                                    <!-- Media at top (same as A card) -->
                                    <div id="previewMediaContainerB" style="position: relative; min-height: 220px; border-bottom: 1px solid rgba(126, 58, 237, 0.1); display: flex; align-items: center; justify-content: center; color: #a855f7; font-size: 14px; background: rgba(126, 58, 237, 0.02);">
                                        <div style="text-align: center; color: #a855f7;">
                                            <div style="font-size: 32px; margin-bottom: 8px;">📷</div>
                                            <div style="font-size: 12px;">Kép vagy média</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Text at bottom -->
                                    <div style="padding: 24px; text-align: center;">
                                        <div id="previewWordB" style="font-size: 24px; font-weight: 700; color: #000000; min-height: 40px; line-height: 1.2;">
                                            -
                                        </div>

                                    </div>
                                </div>
                                
                            </div>
                        </div>
                        
                        <!-- First Row: Text Inputs Side by Side -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px;">
                            
                            <!-- Left Column: A Language -->
                            <div class="modern-input-group">
                                <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                    ${languageA} szó/mondat *
                                </label>
                                <div class="rich-text-toolbar" id="toolbarA">
                                    <button type="button" onclick="formatText('singleWordA', 'fontSize', '14px')" class="toolbar-btn" title="Kicsi">S</button>
                                    <button type="button" onclick="formatText('singleWordA', 'fontSize', '18px')" class="toolbar-btn" title="Közepes">M</button>
                                    <button type="button" onclick="formatText('singleWordA', 'fontSize', '24px')" class="toolbar-btn" title="Nagy">L</button>
                                    <div class="toolbar-separator"></div>
                                                                    <button type="button" onclick="formatText('singleWordA', 'bold')" class="toolbar-btn" title="Félkövér"><b>B</b></button>
                                <button type="button" onclick="formatText('singleWordA', 'italic')" class="toolbar-btn" title="Dőlt"><i>I</i></button>
                                <button type="button" onclick="formatText('singleWordA', 'underline')" class="toolbar-btn" title="Aláhúzás"><u>U</u></button>
                                <button type="button" onclick="toggleHighlight('singleWordA')" class="toolbar-btn highlight-btn" title="Sárga kiemelés">H</button>
                                    <div class="toolbar-separator"></div>
                                    <input type="color" onchange="formatText('singleWordA', 'foreColor', this.value)" class="color-picker" title="Szín" value="#000000">
                                    <button type="button" onclick="clearFormatting('singleWordA')" class="toolbar-btn clear-btn" title="Formázás törlése">×</button>
                                </div>
                                <div contenteditable="true" 
                                     id="singleWordA" 
                                     class="rich-text-input" 
                                     data-placeholder="Jelöld ki a szöveget és használd a fenti gombokat a formázáshoz..."
                                     oninput="updatePreview()"
                                     onkeydown="handleRichTextKeydown(event, 'singleWordA')"
                                     onfocus="setActiveEditor(this); updateToolbarState('singleWordA')"
                                     onblur="checkRequired(this)"
                                     onmouseup="updateToolbarState('singleWordA')"
                                     onkeyup="updateToolbarState('singleWordA')"></div>
                            </div>
                            
                            <!-- Right Column: B Language -->
                            <div class="modern-input-group">
                                <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                    ${languageB} jelentés *
                                </label>
                                <div class="rich-text-toolbar" id="toolbarB">
                                    <button type="button" onclick="formatText('singleWordB', 'fontSize', '14px')" class="toolbar-btn" title="Kicsi">S</button>
                                    <button type="button" onclick="formatText('singleWordB', 'fontSize', '18px')" class="toolbar-btn" title="Közepes">M</button>
                                    <button type="button" onclick="formatText('singleWordB', 'fontSize', '24px')" class="toolbar-btn" title="Nagy">L</button>
                                    <div class="toolbar-separator"></div>
                                                                    <button type="button" onclick="formatText('singleWordB', 'bold')" class="toolbar-btn" title="Félkövér"><b>B</b></button>
                                <button type="button" onclick="formatText('singleWordB', 'italic')" class="toolbar-btn" title="Dőlt"><i>I</i></button>
                                <button type="button" onclick="formatText('singleWordB', 'underline')" class="toolbar-btn" title="Aláhúzás"><u>U</u></button>
                                <button type="button" onclick="toggleHighlight('singleWordB')" class="toolbar-btn highlight-btn" title="Sárga kiemelés">H</button>
                                    <div class="toolbar-separator"></div>
                                    <input type="color" onchange="formatText('singleWordB', 'foreColor', this.value)" class="color-picker" title="Szín" value="#000000">
                                    <button type="button" onclick="clearFormatting('singleWordB')" class="toolbar-btn clear-btn" title="Formázás törlése">×</button>
                                </div>
                                <div contenteditable="true" 
                                     id="singleWordB" 
                                     class="rich-text-input" 
                                     data-placeholder="Jelöld ki a szöveget és használd a fenti gombokat a formázáshoz..."
                                     oninput="updatePreview()"
                                     onkeydown="handleRichTextKeydown(event, 'singleWordB')"
                                     onfocus="setActiveEditor(this); updateToolbarState('singleWordB')"
                                     onblur="checkRequired(this)"
                                     onmouseup="updateToolbarState('singleWordB')"
                                     onkeyup="updateToolbarState('singleWordB')"></div>
                            </div>
                            
                        </div>
                        
                        <!-- Second Row: Other Inputs -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 16px;">
                            
                            <!-- Left Column: Tags -->
                            <div class="modern-input-group">
                                <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                    Kategóriák
                                </label>
                                <div style="position: relative;">
                                    <input type="text" 
                                           id="singleTags" 
                                           class="modern-input" 
                                           placeholder="pl. állatok, ételek, utazás (vesszővel elválasztva)" 
                                           oninput="updatePreview(); handleTagInput(this.value)"
                                           onkeydown="handleTagKeydown(event)"
                                           onfocus="updateCategoryPlaceholder()">
                                    <div id="tagSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15); max-height: 150px; overflow-y: auto; z-index: 10000; display: none;"></div>
                                </div>
                                <div style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px;" id="selectedTags"></div>
                            </div>
                            
                            <!-- Right Column: Media Upload and Actions -->
                            <div style="display: flex; flex-direction: column; gap: 20px;">
                                <div class="modern-input-group">
                                    <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                        Média (opcionális)
                                    </label>
                                    <div style="display: flex; gap: 12px; align-items: start;">
                                        <!-- Small square image upload button with delete -->
                                        <div style="flex-shrink: 0; position: relative;">
                                            <input type="file" 
                                                   id="singleMediaFile" 
                                                   accept="image/jpeg,image/jpg,image/png,image/gif,image/webp" 
                                                   style="display: none;" 
                                                   onchange="handleFileUpload(event)">
                                            <button type="button" 
                                                    onclick="document.getElementById('singleMediaFile').click()" 
                                                    title="Kép feltöltése gépről vagy Ctrl+V vágólapról"
                                                    style="width: 60px; height: 60px; padding: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; font-size: 24px; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;"
                                                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(102, 126, 234, 0.3)';"
                                                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                                📷
                                            </button>
                                        </div>
                                        
                                        <!-- Video URL input -->
                                        <div style="flex: 1;">
                                            <input type="url" 
                                                   id="singleVideoUrl" 
                                                   class="modern-input" 
                                                   placeholder="Video URL..." 
                                                   oninput="handleVideoUrlInput(this.value)"
                                                   onkeydown="handleVideoUrlKeydown(event)"
                                                   style="margin-bottom: 0; width: 100%;">
                                        </div>
                                    </div>
                                    <div id="fileStatus" style="margin-top: 12px; font-size: 14px; color: #6b7280; text-align: center;"></div>
                                    <div style="margin-top: 8px; font-size: 12px; color: #9ca3af; text-align: center; font-style: italic;">
                                        💡 Tipp: Ctrl+V-vel is beilleszthetsz képet a vágólapról
                                    </div>
                                </div>
                                

                            </div>
                        </div>
                        

                        

                    </div>
                </form>
                
                <style>
                .modern-input {
                    width: 100%;
                    padding: 20px 24px;
                    border: 2px solid #e2e8f0;
                    background: #ffffff;
                    font-size: 16px;
                    font-weight: 500;
                    color: #374151;
                    transition: all 0.2s ease;
                    outline: none;
                }
                
                .modern-input:focus {
                    border-color: #667eea;
                    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
                }
                
                .modern-input::placeholder {
                    color: #9ca3af;
                    font-weight: 400;
                }

                /* Rich Text Editor Styles */
                .rich-text-toolbar {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    padding: 8px 12px;
                    background: #f8fafc;
                    border: 2px solid #e2e8f0;
                    border-bottom: none;
                    margin-bottom: 0;
                }

                .toolbar-btn {
                    background: transparent;
                    border: 1px solid transparent;
                    padding: 8px 12px;
                    font-size: 13px;
                    font-weight: 600;
                    color: #374151;
                    cursor: pointer;
                    border-radius: 6px;
                    transition: all 0.2s ease;
                    min-width: 34px;
                    height: 34px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .toolbar-btn:hover {
                    background: #e2e8f0;
                    border-color: #cbd5e1;
                    transform: translateY(-1px);
                }

                .toolbar-btn:active {
                    transform: translateY(0);
                    background: #cbd5e1;
                }

                .toolbar-btn.active {
                    background: #667eea;
                    color: white;
                    border-color: #667eea;
                    box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
                }

                .highlight-btn.active {
                    background: #fbbf24 !important;
                    color: #92400e !important;
                    border-color: #f59e0b !important;
                    box-shadow: 0 2px 4px rgba(251, 191, 36, 0.3) !important;
                }

                .highlight-btn {
                    background: #fef3c7;
                    color: #92400e;
                    border-color: #fcd34d;
                }

                .highlight-btn:hover {
                    background: #fbbf24;
                }

                .clear-btn {
                    color: #ef4444;
                    font-size: 16px;
                    font-weight: 700;
                }

                .clear-btn:hover {
                    background: #fee2e2;
                    border-color: #fca5a5;
                }

                .toolbar-separator {
                    width: 1px;
                    height: 24px;
                    background: #d1d5db;
                    margin: 0 8px;
                }

                .color-picker {
                    width: 36px;
                    height: 34px;
                    padding: 0;
                    border: 1px solid #d1d5db;
                    border-radius: 6px;
                    cursor: pointer;
                    background: none;
                }

                .rich-text-input {
                    width: 100%;
                    min-height: 60px;
                    padding: 20px 24px;
                    border: 2px solid #e2e8f0;
                    border-top: none;
                    background: #ffffff;
                    font-size: 24px;
                    font-weight: 500;
                    color: #000000;
                    transition: all 0.2s ease;
                    outline: none;
                    overflow-wrap: break-word;
                    line-height: 1.5;
                }

                .rich-text-input:focus {
                    border-color: #667eea;
                    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
                }

                .rich-text-input:empty:before {
                    content: attr(data-placeholder);
                    color: #9ca3af;
                    font-weight: 400;
                    pointer-events: none;
                }

                .rich-text-input.required-error {
                    border-color: #ef4444;
                    box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
                }
                
                .tag-chip {
                    display: inline-flex;
                    align-items: center;
                    padding: 6px 12px;
                    background: #f3f4f6;
                    border: 1px solid #d1d5db;
                    font-size: 12px;
                    font-weight: 500;
                    color: #374151;
                    gap: 6px;
                }
                
                .tag-chip .remove {
                    cursor: pointer;
                    color: #ef4444;
                    font-weight: 600;
                }
                
                .tag-suggestion {
                    padding: 12px 16px;
                    cursor: pointer;
                    border-bottom: 1px solid #f3f4f6;
                    font-size: 14px;
                }
                
                .tag-suggestion:hover {
                    background: #f8fafc;
                }
                
                .tag-suggestion.selected {
                    background: #667eea;
                    color: white;
                }
                
                @media (max-width: 1024px) {
                    .modal {
                        width: 95%;
                        max-width: none;
                        margin: 20px;
                    }
                    
                    /* Make all input grids single column on mobile */
                    #addCardsFormContainer > form > div:first-child > div:nth-child(2),
                    #addCardsFormContainer > form > div:first-child > div:nth-child(3) {
                        grid-template-columns: 1fr !important;
                        gap: 24px !important;
                    }
                    
                    /* Preview cards responsive */
                    #cardPreview > div {
                        grid-template-columns: 1fr !important;
                        gap: 16px !important;
                    }
                    
                    /* Adjust card heights for mobile */
                    #previewMediaContainer,
                    #previewMediaContainerB {
                        min-height: 150px !important;
                    }
                    
                    /* Media input responsive */
                    .modern-input-group > div > div:first-child > button {
                        width: 50px !important;
                        height: 50px !important;
                        font-size: 20px !important;
                    }
                    
                    /* Video URL input responsive */
                    .modern-input-group > div > div:nth-child(2) > input {
                        max-width: 200px !important;
                    }
                    
                    /* Action buttons responsive */
                    .modern-input-group > div > div:nth-child(2) > button {
                        width: 35px !important;
                        height: 35px !important;
                        font-size: 14px !important;
                    }
                }
                </style>
            `;
            
            // Initialize
            initializeTagSystem();
            updatePreview();
            // Button is now part of the media container
            
            // Add file upload listener
            document.getElementById('singleMediaFile').addEventListener('change', handleFileUpload);
            
            // Add paste listener for clipboard images
            document.addEventListener('paste', handlePasteImage);
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('#singleTags') && !e.target.closest('#tagSuggestions')) {
                    const tagSuggestions = document.getElementById('tagSuggestions');
                    if (tagSuggestions) {
                        tagSuggestions.style.display = 'none';
                    }
                }
            });
        }

        // Handle video URL input
        function handleVideoUrlInput(url) {
            if (url.trim()) {
                // Clear file upload if video URL is entered  
                const mediaFileInput = document.getElementById('singleMediaFile');
                if (mediaFileInput) mediaFileInput.value = '';
                
                // Clear status in both modals (whichever exists)
                const fileStatus = document.getElementById('fileStatus');
                const editFileStatus = document.getElementById('editFileStatus');
                if (fileStatus) fileStatus.textContent = '';
                if (editFileStatus) editFileStatus.textContent = '';
                
                // Store video URL and detect type
                window.currentMediaUrl = url.trim();
                window.currentMediaType = detectMediaTypeFromUrl(url);
            } else {
                // If URL is cleared and no file uploaded, clear media data
                if (!window.currentMediaUrl || !window.currentMediaUrl.includes('supabase')) {
                    window.currentMediaUrl = null;
                    window.currentMediaType = null;
                }
            }
            
            updatePreview();
        }
        
        // Detect media type from URL
        function detectMediaTypeFromUrl(url) {
            if (url.includes('youtube.com') || url.includes('youtu.be')) {
                return 'youtube';
            } else if (url.match(/\.(mp4|avi|mov|wmv|flv|webm)$/i)) {
                return 'video';
            } else if (url.match(/\.(gif)$/i)) {
                return 'gif';
            } else if (url.match(/\.(jpg|jpeg|png|webp|bmp|svg)$/i)) {
                return 'image';
            }
            return 'video'; // default for unknown video URLs
        }
        
        // Handle video URL field keydown for TAB navigation
        function handleVideoUrlKeydown(event) {
            if (event.key === 'Tab') {
                if (event.shiftKey) {
                    // Shift+TAB -> go back to tags field
                    event.preventDefault();
                    document.getElementById('singleTags').focus();
                } else {
                    // TAB -> let it naturally go to the approve button
                    // (don't prevent default to allow natural tab order)
                }
            }
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            const statusElement = document.getElementById('fileStatus');
            
            if (!file) {
                statusElement.textContent = '';
                // Clear stored media data
                window.currentMediaUrl = null;
                window.currentMediaType = null;
                updatePreview();
                // Button is now part of the media container
                return;
            }
            
            try {
                // Clear video URL input when file is uploaded
                document.getElementById('singleVideoUrl').value = '';
                
                statusElement.textContent = '⏳ Feltöltés...';
                statusElement.style.color = '#667eea';
                
                // Upload to Supabase Storage
                const fileExt = file.name.split('.').pop();
                const fileName = Date.now() + '_' + Math.random().toString(36).substring(2) + '.' + fileExt;
                const filePath = currentUser.id + '/cards/' + fileName;
                
                const { data, error } = await supabase.storage
                    .from('media')
                    .upload(filePath, file);
                
                if (error) {
                    throw error;
                }
                
                // Get public URL
                const { data: publicURL } = supabase.storage
                    .from('media')
                    .getPublicUrl(filePath);
                
                // Store media data in global variables
                window.currentMediaUrl = publicURL.publicUrl;
                window.currentMediaType = detectMediaTypeFromFile(file);
                
                statusElement.textContent = ' Feltöltve: ' + file.name + '';
                statusElement.style.color = '#16a34a';
                
                // Update preview
                updatePreview();
                
                // Show delete button
                // Button is now part of the media container
                
            } catch (error) {
                console.error('File upload error:', error);
                statusElement.textContent = ' Hiba: ' + error.message + '';
                statusElement.style.color = '#ef4444';
                
                // If storage doesn't exist, create it
                if (error.message.includes('Bucket not found') || error.message.includes('The resource was not found')) {
                    statusElement.textContent = '🔄 Storage bucket létrehozása...';
                    try {
                        await createStorageBucket();
                        // Retry upload
                        setTimeout(() => handleFileUpload(event), 1000);
                    } catch (createError) {
                        statusElement.textContent = ' Storage hiba: ' + createError.message + '';
                    }
                }
            }
        }

        // Handle paste from clipboard (images)
        async function handlePasteImage(event) {

            
            // Only handle paste when ANY card modal is open (add OR edit)
            const addModal = document.getElementById('addCardsModal');
            const editModal = document.getElementById('editCardModalContainer');
            
            const isAddModalOpen = addModal && addModal.classList.contains('active');
            const isEditModalOpen = editModal && editModal.style.display === 'block';
            

            
            if (!isAddModalOpen && !isEditModalOpen) {

                return;
            }
            

            
            const items = event.clipboardData.items;

            
            // Use the appropriate status element based on which modal is open
            const statusElement = isEditModalOpen ? 
                document.getElementById('editFileStatus') : 
                document.getElementById('fileStatus');
            
            if (!statusElement) {
                return;
            }
            
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                
                // Check if the item is an image
                if (item.type.indexOf('image') !== -1) {
                    event.preventDefault(); // Prevent default paste behavior
                    
                    const file = item.getAsFile();
                    if (!file) continue;
                    
                    try {
                        // Clear video URL input when image is pasted (only in the active modal)
                        const videoInput = isEditModalOpen ? 
                            document.querySelector('#editCardModalContainer #singleVideoUrl') :
                            document.querySelector('#addCardsModal #singleVideoUrl');
                        if (videoInput) videoInput.value = '';
                        
                        statusElement.textContent = '⏳ Vágólapról feltöltés...';
                        statusElement.style.color = '#667eea';
                        
                        // Upload to Supabase Storage
                        const fileExt = file.type.split('/')[1] || 'png';
                        const fileName = 'clipboard_' + Date.now() + '_' + Math.random().toString(36).substring(2) + '.' + fileExt;
                        const filePath = currentUser.id + '/cards/' + fileName;
                        
                        const { data, error } = await supabase.storage
                            .from('media')
                            .upload(filePath, file);
                        
                        if (error) {
                            throw error;
                        }
                        
                        // Get public URL
                        const { data: publicURL } = supabase.storage
                            .from('media')
                            .getPublicUrl(filePath);
                        

                        
                        statusElement.textContent = ' Vágólapról feltöltve: ' + fileName + '';
                        statusElement.style.color = '#16a34a';
                        
                        // Handle media storage differently for edit vs add modal
                        if (isEditModalOpen) {
                            // Edit modal: update card data directly in database
                            try {
                                const { error: updateError } = await supabase
                                    .from('cards')
                                    .update({
                                        image_url: publicURL.publicUrl,
                                        media_type: detectMediaTypeFromFile(file)
                                    })
                                    .eq('id', currentEditCardId);
                                

                                
                                if (updateError) {
                                    console.error('Error updating card media:', updateError);
                                    statusElement.textContent = '❌ Hiba a kép mentésekor!';
                                    statusElement.style.color = '#ef4444';
                                } else {
                                    statusElement.textContent = '✅ Kép sikeresen mentve!';
                                    statusElement.style.color = '#16a34a';
                                    
                                    // Note: Video URL field stays empty for images (only used for YouTube videos)
                                    
                                    // Update preview in edit modal
                                    // Set global variables for updatePreview to work
                                    window.currentMediaUrl = publicURL.publicUrl;
                                    window.currentMediaType = detectMediaTypeFromFile(file);
                                    updatePreview();
                                }
                            } catch (dbError) {
                                console.error('Database update error:', dbError);
                                statusElement.textContent = '❌ Adatbázis hiba!';
                                statusElement.style.color = '#ef4444';
                            }
                        } else {
                            // Add modal: store in global variables (existing behavior)
                            window.currentMediaUrl = publicURL.publicUrl;
                            window.currentMediaType = detectMediaTypeFromFile(file);
                            
                            // Update preview
                            updatePreview();
                        }
                        
                        // Show delete button
                        // Button is now part of the media container
                        
                        break; // Only handle the first image found
                        
                    } catch (error) {
                        console.error('Clipboard image upload error:', error);
                        statusElement.textContent = ' Vágólap hiba: ' + error.message + '';
                        statusElement.style.color = '#ef4444';
                        
                        // If storage doesn't exist, create it
                        if (error.message.includes('Bucket not found') || error.message.includes('The resource was not found')) {
                            statusElement.textContent = '🔄 Storage bucket létrehozása...';
                            try {
                                await createStorageBucket();
                                // Retry paste upload
                                setTimeout(() => handlePasteImage(event), 1000);
                            } catch (createError) {
                                statusElement.textContent = ' Storage hiba: ' + createError.message + '';
                            }
                        }
                    }
                }
            }
        }

        function detectMediaTypeFromFile(file) {
            const type = file.type.toLowerCase();
            
            if (type.startsWith('image/')) {
                if (type === 'image/gif') {
                    return 'gif';
                }
                return 'image';
            } else if (type.startsWith('video/')) {
                return 'video';
            }
            
            return null;
        }

        async function createStorageBucket() {
            try {
                // Create the media bucket
                const { data, error } = await supabase.storage.createBucket('media', {
                    public: true,
                    allowedMimeTypes: ['image/*', 'video/*'],
                    fileSizeLimit: 52428800 // 50MB
                });
                
                if (error && !error.message.includes('already exists')) {
                    throw error;
                }
                
                console.log(' Storage bucket created or already exists');
                return true;
                
            } catch (error) {
                console.error('Error creating storage bucket:', error);
                throw error;
            }
        }

        function closeAddCardsModal() {
            const modal = document.getElementById('addCardsModal');
            modal.classList.remove('active');
            
            // Reset z-index back to normal
            const modalContainer = document.getElementById('modalContainer');
            if (modalContainer) {
                modalContainer.style.zIndex = '10000';
            }
            
            // Clear container and reset arrays
            document.getElementById('addCardsFormContainer').innerHTML = '';
            cardsToAdd = [];

            currentTagsData = [];
            currentSetId = null;
        }

        // Edit Card Modal functions
        let currentEditCardId = null;

        async function openEditCardModal(cardId) {
            currentEditCardId = cardId;
            
            try {
                // Load card data from database
                const { data: cardData, error } = await supabase
                    .from('cards')
                    .select('*')
                    .eq('id', cardId)
                    .single();
                
                if (error) {
                    console.error('Error loading card:', error);
                    showErrorMessage('❌ Hiba a kártya betöltése során!');
                    return;
                }
                
                // Get the card's categories
                const { data: cardCategories, error: catError } = await supabase
                    .from('card_categories')
                    .select('category_id')
                    .eq('card_id', cardId);
                
                if (!catError && cardCategories && cardCategories.length > 0) {
                    // Get category names
                    const categoryIds = cardCategories.map(cc => cc.category_id);
                    const { data: categories } = await supabase
                        .from('categories')
                        .select('id, name')
                        .in('id', categoryIds);
                    
                    cardData.categories = categories || [];
                } else {
                    cardData.categories = [];
                }
                
                // Get the set data separately
                const { data: linkData, error: linkError } = await supabase
                    .from('flashcard_set_cards')
                    .select('set_id')
                    .eq('card_id', cardId)
                    .single();
                
                if (linkError) {
                    console.error('Error loading card link:', linkError);
                    showErrorMessage('❌ Hiba a kártya szett kapcsolat betöltése során!');
                    return;
                }
                
                const { data: setData, error: setError } = await supabase
                    .from('flashcard_sets')
                    .select('*')
                    .eq('id', linkData.set_id)
                    .single();
                
                if (setError) {
                    console.error('Error loading set:', setError);
                    showErrorMessage('❌ Hiba a szett betöltése során!');
                    return;
                }
                const languageA = translateLanguageName(setData.language_a) || 'Magyar';
                const languageB = translateLanguageName(setData.language_b) || 'Angol';
                
                // Use dedicated edit modal container with the SAME structure as addCardsModal
                const editModalContainer = document.getElementById('editCardModalContainer');
                
                // Generate modal structure and buttons COMPLETELY SEPARATE
                editModalContainer.innerHTML = `
                    <div class="modal-overlay active" style="z-index: 20000;">
                        <div class="modal" style="max-height: 85vh; overflow-y: auto; margin-bottom: 100px;">
                            <div class="modal-header">
                                <h2 class="modal-title">Kártya szerkesztése</h2>
                                <p class="modal-subtitle">Kártya szerkesztése a "${setData.title}" szettben (${languageA} → ${languageB})</p>
                            </div>
                            
                            <div id="editCardFormContainer">
                                <!-- Form will be generated here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- COMPLETELY SEPARATE buttons - OUTSIDE modal -->
                    <div style="position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px); border-top: 1px solid rgba(255, 255, 255, 0.2); padding: 20px; display: grid; grid-template-columns: 1fr 1fr; gap: 16px; z-index: 22000; max-width: 1400px; width: 95%; border-radius: 24px 24px 0 0;">
                        <button type="button" 
                                onclick="saveEditedCard()" 
                                id="saveEditBtn"
                                style="padding: 16px 24px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: white; border: none; border-radius: 16px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 8px 32px rgba(34, 197, 94, 0.3);"
                                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 12px 40px rgba(34, 197, 94, 0.4)'"
                                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 8px 32px rgba(34, 197, 94, 0.3)'">
                            💾 Mentés
                        </button>
                        <button type="button" 
                                onclick="closeEditCardModal()" 
                                style="padding: 16px 24px; background: rgba(156, 163, 175, 0.1); color: #6b7280; border: 2px solid rgba(156, 163, 175, 0.2); border-radius: 16px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;"
                                onmouseover="this.style.background='rgba(156, 163, 175, 0.15)'"
                                onmouseout="this.style.background='rgba(156, 163, 175, 0.1)'">
                            Mégse
                        </button>
                    </div>
                `;
                
                // Generate the EXACT SAME form as for new cards, but with edit mode
                generateEditCardForm(languageA, languageB, cardData);
                
                // Load existing tags into the form
                if (cardData.categories && cardData.categories.length > 0) {
                    // Clear selected tags list first
                    selectedTagsList = [];
                    const selectedTagsContainer = document.getElementById('selectedTags');
                    if (selectedTagsContainer) {
                        selectedTagsContainer.innerHTML = '';
                    }
                    
                    // Add each category as a tag
                    cardData.categories.forEach(category => {
                        if (category && category.name) {
                            // Add to selectedTagsList for saving
                            if (!selectedTagsList.includes(category.name)) {
                                selectedTagsList.push(category.name);
                            }
                            
                            // Create visual tag element
                            const tagElement = document.createElement('div');
                            tagElement.style.cssText = 'display: inline-flex; align-items: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 12px; border-radius: 20px; font-size: 14px; font-weight: 500;';
                            tagElement.innerHTML = `
                                ${category.name}
                                <button type="button" onclick="removeTag('${category.name}')" style="margin-left: 8px; background: none; border: none; color: white; cursor: pointer; font-size: 16px; line-height: 1; padding: 0;">×</button>
                            `;
                            selectedTagsContainer.appendChild(tagElement);
                        }
                    });
                }
                
                // Show the edit modal
                editModalContainer.style.display = 'block';
                
                // Focus first input after a brief delay
                setTimeout(() => {
                    const firstInput = editModalContainer.querySelector('input, textarea, [contenteditable]');
                    if (firstInput) firstInput.focus();
                }, 100);
                
            } catch (error) {
                console.error('Error opening edit modal:', error);
                showErrorMessage('❌ Hiba a szerkesztő ablak megnyitása során!');
            }
        }

        function generateEditCardForm(languageA, languageB, cardData) {
            const container = document.getElementById('editCardFormContainer');
            
            container.innerHTML = `
                <form id="editCardForm" style="max-width: none; padding-bottom: 20px;">
                    <div style="background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.3); padding: 24px; margin-bottom: 16px;">
                        
                        <!-- Card Preview Section -->
                        <div id="cardPreview" style="margin-bottom: 24px; display: block;">
                            
                            <!-- Delete Media Button - fölül középen -->
                            <div style="text-align: center; margin-bottom: 16px;">
                                <button type="button" 
                                        id="deleteMediaBtn"
                                        onclick="deleteUploadedImage()" 
                                        style="display: none; padding: 8px 16px; background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(8px);"
                                        onmouseover="this.style.background='rgba(239, 68, 68, 0.15)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.2)';"
                                        onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                     Média törlése
                                </button>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                                
                                <!-- A Language Card -->
                                <div style="background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(12px); border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 20px; padding: 0; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); position: relative; overflow: hidden;">
                                    
                                    <!-- Media at top -->
                                    <div id="previewMediaContainer" style="position: relative; min-height: 220px; border-bottom: 1px solid rgba(102, 126, 234, 0.1); display: flex; align-items: center; justify-content: center; color: #94a3b8; font-size: 14px; background: rgba(102, 126, 234, 0.02);">
                                        <div style="text-align: center; color: #94a3b8;">
                                            <div style="font-size: 32px; margin-bottom: 8px;">📷</div>
                                            <div style="font-size: 12px;">Kép vagy média</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Text at bottom -->
                                    <div style="padding: 24px; text-align: center;">
                                        <div id="previewWordA" style="font-size: 24px; font-weight: 700; color: #000000; min-height: 40px; line-height: 1.2;">
                                            ${cardData.title || '-'}
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- B Language Card -->
                                <div style="background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(12px); border: 2px solid rgba(126, 58, 237, 0.2); border-radius: 20px; padding: 0; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); position: relative; overflow: hidden;">
                                    
                                    <!-- Media at top (same as A card) -->
                                    <div id="previewMediaContainerB" style="position: relative; min-height: 220px; border-bottom: 1px solid rgba(126, 58, 237, 0.1); display: flex; align-items: center; justify-content: center; color: #a855f7; font-size: 14px; background: rgba(126, 58, 237, 0.02);">
                                        <div style="text-align: center; color: #a855f7;">
                                            <div style="font-size: 32px; margin-bottom: 8px;">📷</div>
                                            <div style="font-size: 12px;">Kép vagy média</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Text at bottom -->
                                    <div style="padding: 24px; text-align: center;">
                                        <div id="previewWordB" style="font-size: 24px; font-weight: 700; color: #000000; min-height: 40px; line-height: 1.2;">
                                            ${cardData.english_title || '-'}
                                        </div>

                                    </div>
                                </div>
                                
                            </div>
                        </div>
                        
                        <!-- First Row: Text Inputs Side by Side -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px;">
                            
                            <!-- Left Column: A Language -->
                            <div class="modern-input-group">
                                <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                    ${languageA} szó/mondat *
                                </label>
                                <div class="rich-text-toolbar" id="toolbarA">
                                    <button type="button" onclick="formatText('singleWordA', 'fontSize', '14px')" class="toolbar-btn" title="Kicsi">S</button>
                                    <button type="button" onclick="formatText('singleWordA', 'fontSize', '18px')" class="toolbar-btn" title="Közepes">M</button>
                                    <button type="button" onclick="formatText('singleWordA', 'fontSize', '24px')" class="toolbar-btn" title="Nagy">L</button>
                                    <div class="toolbar-separator"></div>
                                    <button type="button" onclick="formatText('singleWordA', 'bold')" class="toolbar-btn" title="Félkövér"><b>B</b></button>
                                    <button type="button" onclick="formatText('singleWordA', 'italic')" class="toolbar-btn" title="Dőlt"><i>I</i></button>
                                    <button type="button" onclick="formatText('singleWordA', 'underline')" class="toolbar-btn" title="Aláhúzás"><u>U</u></button>
                                    <button type="button" onclick="toggleHighlight('singleWordA')" class="toolbar-btn highlight-btn" title="Sárga kiemelés">H</button>
                                    <div class="toolbar-separator"></div>
                                    <input type="color" onchange="formatText('singleWordA', 'foreColor', this.value)" class="color-picker" title="Szín" value="#000000">
                                    <button type="button" onclick="clearFormatting('singleWordA')" class="toolbar-btn clear-btn" title="Formázás törlése">×</button>
                                </div>
                                <div contenteditable="true" 
                                     id="singleWordA" 
                                     class="rich-text-input" 
                                     data-placeholder="Jelöld ki a szöveget és használd a fenti gombokat a formázáshoz..."
                                     oninput="updatePreview()"
                                     onkeydown="handleRichTextKeydown(event, 'singleWordA')"
                                     onfocus="setActiveEditor(this); updateToolbarState('singleWordA')"
                                     onblur="checkRequired(this)"
                                     onmouseup="updateToolbarState('singleWordA')"
                                     onkeyup="updateToolbarState('singleWordA')">${cardData.title || ''}</div>
                            </div>
                            
                            <!-- Right Column: B Language -->
                            <div class="modern-input-group">
                                <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                    ${languageB} jelentés *
                                </label>
                                <div class="rich-text-toolbar" id="toolbarB">
                                    <button type="button" onclick="formatText('singleWordB', 'fontSize', '14px')" class="toolbar-btn" title="Kicsi">S</button>
                                    <button type="button" onclick="formatText('singleWordB', 'fontSize', '18px')" class="toolbar-btn" title="Közepes">M</button>
                                    <button type="button" onclick="formatText('singleWordB', 'fontSize', '24px')" class="toolbar-btn" title="Nagy">L</button>
                                    <div class="toolbar-separator"></div>
                                    <button type="button" onclick="formatText('singleWordB', 'bold')" class="toolbar-btn" title="Félkövér"><b>B</b></button>
                                    <button type="button" onclick="formatText('singleWordB', 'italic')" class="toolbar-btn" title="Dőlt"><i>I</i></button>
                                    <button type="button" onclick="formatText('singleWordB', 'underline')" class="toolbar-btn" title="Aláhúzás"><u>U</u></button>
                                    <button type="button" onclick="toggleHighlight('singleWordB')" class="toolbar-btn highlight-btn" title="Sárga kiemelés">H</button>
                                    <div class="toolbar-separator"></div>
                                    <input type="color" onchange="formatText('singleWordB', 'foreColor', this.value)" class="color-picker" title="Szín" value="#000000">
                                    <button type="button" onclick="clearFormatting('singleWordB')" class="toolbar-btn clear-btn" title="Formázás törlése">×</button>
                                </div>
                                <div contenteditable="true" 
                                     id="singleWordB" 
                                     class="rich-text-input" 
                                     data-placeholder="Jelöld ki a szöveget és használd a fenti gombokat a formázáshoz..."
                                     oninput="updatePreview()"
                                     onkeydown="handleRichTextKeydown(event, 'singleWordB')"
                                     onfocus="setActiveEditor(this); updateToolbarState('singleWordB')"
                                     onblur="checkRequired(this)"
                                     onmouseup="updateToolbarState('singleWordB')"
                                     onkeyup="updateToolbarState('singleWordB')">${cardData.english_title || ''}</div>
                            </div>
                            
                        </div>
                        
                        <!-- Second Row: Other Inputs -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 16px;">
                            
                            <!-- Left Column: Tags -->
                            <div class="modern-input-group">
                                <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                    Kategóriák
                                </label>
                                <div style="position: relative;">
                                    <input type="text" 
                                           id="singleTags" 
                                           class="modern-input" 
                                           placeholder="pl. állatok, ételek, utazás (vesszővel elválasztva)" 
                                           oninput="updatePreview(); handleTagInput(this.value)"
                                           onkeydown="handleTagKeydown(event)"
                                           onfocus="updateCategoryPlaceholder()">
                                    <div id="tagSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15); max-height: 150px; overflow-y: auto; z-index: 10000; display: none;"></div>
                                </div>
                                <div style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px;" id="selectedTags"></div>
                            </div>
                            
                            <!-- Right Column: Media Upload and Actions -->
                            <div style="display: flex; flex-direction: column; gap: 20px;">
                                <div class="modern-input-group">
                                    <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                        Média (opcionális)
                                    </label>
                                    <div style="display: flex; gap: 12px; align-items: start;">
                                        <!-- Small square image upload button with delete -->
                                        <div style="flex-shrink: 0; position: relative;">
                                            <input type="file" 
                                                   id="singleMediaFile" 
                                                   accept="image/jpeg,image/jpg,image/png,image/gif,image/webp" 
                                                   style="display: none;" 
                                                   onchange="handleFileUpload(event)">
                                            <button type="button" 
                                                    onclick="document.getElementById('singleMediaFile').click()" 
                                                    title="Kép feltöltése gépről vagy Ctrl+V vágólapról"
                                                    style="width: 60px; height: 60px; padding: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; font-size: 24px; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;"
                                                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(102, 126, 234, 0.3)';"
                                                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                                📷
                                            </button>
                                        </div>
                                        
                                        <!-- Video URL input -->
                                        <div style="flex: 1;">
                                            <input type="url" 
                                                   id="singleVideoUrl" 
                                                   class="modern-input" 
                                                   placeholder="Video URL..." 
                                                   oninput="handleVideoUrlInput(this.value)"
                                                   onkeydown="handleVideoUrlKeydown(event)"
                                                   style="margin-bottom: 0; width: 100%;"
                                                   value="${cardData.media_url || ''}">
                                        </div>
                                    </div>
                                    <div id="editFileStatus" style="margin-top: 12px; font-size: 14px; color: #6b7280; text-align: center;"></div>
                                    <div style="margin-top: 8px; font-size: 12px; color: #9ca3af; text-align: center; font-style: italic;">
                                        💡 Tipp: Ctrl+V-vel is beilleszthetsz képet a vágólapról
                                    </div>
                                </div>
                                

                            </div>
                        </div>
                        

                        

                    </div>
                </form>
                
                <style>
                .modern-input {
                    width: 100%;
                    padding: 20px 24px;
                    border: 2px solid #e2e8f0;
                    background: #ffffff;
                    font-size: 16px;
                    font-weight: 500;
                    color: #374151;
                    transition: all 0.2s ease;
                    outline: none;
                }
                
                .modern-input:focus {
                    border-color: #667eea;
                    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
                }
                
                .modern-input::placeholder {
                    color: #9ca3af;
                    font-weight: 400;
                }

                /* Rich Text Editor Styles */
                .rich-text-toolbar {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    padding: 8px 12px;
                    background: #f8fafc;
                    border: 2px solid #e2e8f0;
                    border-bottom: none;
                    margin-bottom: 0;
                }

                .toolbar-btn {
                    background: transparent;
                    border: 1px solid transparent;
                    padding: 8px 12px;
                    font-size: 13px;
                    font-weight: 600;
                    color: #374151;
                    cursor: pointer;
                    border-radius: 6px;
                    transition: all 0.2s ease;
                    min-width: 34px;
                    height: 34px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .toolbar-btn:hover {
                    background: #e2e8f0;
                    border-color: #cbd5e1;
                    transform: translateY(-1px);
                }

                .toolbar-btn:active {
                    transform: translateY(0);
                    background: #cbd5e1;
                }

                .toolbar-btn.active {
                    background: #667eea;
                    color: white;
                    border-color: #667eea;
                    box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
                }

                .highlight-btn.active {
                    background: #fbbf24 !important;
                    color: #92400e !important;
                    border-color: #f59e0b !important;
                    box-shadow: 0 2px 4px rgba(251, 191, 36, 0.3) !important;
                }

                .highlight-btn {
                    background: #fef3c7;
                    color: #92400e;
                    border-color: #fcd34d;
                }

                .highlight-btn:hover {
                    background: #fbbf24;
                }

                .clear-btn {
                    color: #ef4444;
                    font-size: 16px;
                    font-weight: 700;
                }

                .clear-btn:hover {
                    background: #fee2e2;
                    border-color: #fca5a5;
                }

                .toolbar-separator {
                    width: 1px;
                    height: 24px;
                    background: #d1d5db;
                    margin: 0 8px;
                }

                .color-picker {
                    width: 36px;
                    height: 34px;
                    padding: 0;
                    border: 1px solid #d1d5db;
                    border-radius: 6px;
                    cursor: pointer;
                    background: none;
                }

                .rich-text-input {
                    width: 100%;
                    min-height: 60px;
                    padding: 20px 24px;
                    border: 2px solid #e2e8f0;
                    border-top: none;
                    background: #ffffff;
                    font-size: 24px;
                    font-weight: 500;
                    color: #000000;
                    transition: all 0.2s ease;
                    outline: none;
                    overflow-wrap: break-word;
                    line-height: 1.5;
                }

                .rich-text-input:focus {
                    border-color: #667eea;
                    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
                }

                .rich-text-input:empty:before {
                    content: attr(data-placeholder);
                    color: #9ca3af;
                    font-weight: 400;
                    pointer-events: none;
                }

                .rich-text-input.required-error {
                    border-color: #ef4444;
                    box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
                }
                
                .tag-chip {
                    display: inline-flex;
                    align-items: center;
                    padding: 6px 12px;
                    background: #f3f4f6;
                    border: 1px solid #d1d5db;
                    font-size: 12px;
                    font-weight: 500;
                    color: #374151;
                    gap: 6px;
                }
                
                .tag-chip .remove {
                    cursor: pointer;
                    color: #ef4444;
                    font-weight: 600;
                }
                
                .tag-suggestion {
                    padding: 12px 16px;
                    cursor: pointer;
                    border-bottom: 1px solid #f3f4f6;
                    font-size: 14px;
                }
                
                .tag-suggestion:hover {
                    background: #f8fafc;
                }
                
                .tag-suggestion.selected {
                    background: #667eea;
                    color: white;
                }
                </style>
            `;
            
            // Initialize - same as new card
            initializeTagSystem();
            updatePreview();
            
            // Pre-fill existing media if present
            if (cardData.image_url) {
                setTimeout(() => {
                    handleVideoUrlInput(cardData.image_url);
                }, 100);
            }
            
            // Add file upload listener
            document.getElementById('singleMediaFile').addEventListener('change', handleFileUpload);
            
            // Add paste listener for clipboard images
            document.addEventListener('paste', handlePasteImage);
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('#singleTags') && !e.target.closest('#tagSuggestions')) {
                    const tagSuggestions = document.getElementById('tagSuggestions');
                    if (tagSuggestions) {
                        tagSuggestions.style.display = 'none';
                    }
                }
            });
            
            // Enable save button since we have data
            setTimeout(() => {
                const saveBtn = document.getElementById('saveEditBtn');
                if (saveBtn) {
                    saveBtn.disabled = false;
                }
            }, 100);
            
            // Load existing categories for this card
            loadCardCategories(cardData.id);
        }
        
        // Load and display existing categories for card editing
        async function loadCardCategories(cardId) {
            try {
                const { data: cardCategories, error } = await supabase
                    .from('card_categories')
                    .select(`
                        categories (
                            name
                        )
                    `)
                    .eq('card_id', cardId);
                
                if (error) {
                    console.error('Error loading card categories:', error);
                    return;
                }
                
                // Clear previous tags first
                selectedTagsList = [];
                
                // Extract category names and set them in the input field AND selectedTagsList
                if (cardCategories && cardCategories.length > 0) {
                    const categoryNames = cardCategories
                        .map(cc => cc.categories.name)
                        .filter(name => name);
                    
                    // Add to selectedTagsList for processing
                    selectedTagsList = [...categoryNames];
                    
                    // Keep input field empty for adding new tags
                    const tagsInput = document.getElementById('singleTags');
                    if (tagsInput) {
                        tagsInput.value = '';  // Always keep input empty
                    }
                    
                    // Display the tag chips
                    displaySelectedTags();
                }
                
            } catch (error) {
                console.error('Error loading card categories:', error);
            }
        }





        async function saveEditedCard() {
            const titleA = document.getElementById('singleWordA').innerHTML.trim();
            const titleB = document.getElementById('singleWordB').innerHTML.trim();
            const videoUrl = document.getElementById('singleVideoUrl').value.trim();
            const tagsInput = document.getElementById('singleTags').value.trim();
            
            // Add any text input tags to selectedTagsList
            if (tagsInput) {
                const inputTags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
                for (const tagName of inputTags) {
                    if (!selectedTagsList.includes(tagName)) {
                        selectedTagsList.push(tagName);
                    }
                }
            }
            
            if (!titleA || !titleB) {
                showErrorMessage('❌ Kérlek töltsd ki mindkét nyelvi mezőt!');
                return;
            }
            
            try {
                // Update the card in database
                const { error } = await supabase
                    .from('cards')
                    .update({
                        title: titleA,
                        english_title: titleB,
                        media_url: videoUrl || null
                    })
                    .eq('id', currentEditCardId);
                
                if (error) {
                    console.error('Error updating card:', error);
                    showErrorMessage('❌ Hiba a kártya mentése során!');
                    return;
                }
                
                // Handle categories/tags update - use selectedTagsList
                await updateCardCategoriesFromList(currentEditCardId, selectedTagsList);
                
                showSuccessMessage('✅ Kártya sikeresen frissítve!');
                
                // Close modal and refresh list if it's open
                closeEditCardModal();
                
                // Refresh the list view if it's currently displayed
                if (window.currentListCards && window.currentListSet) {
                    // Reload the list to show updated data
                    showSimpleCardsList(window.currentListSet, await reloadCardsList());
                }
                
            } catch (error) {
                console.error('Error saving card:', error);
                showErrorMessage('❌ Hiba a kártya mentése során!');
            }
        }

        async function reloadCardsList() {
            if (!window.currentListSet) return [];
            
            try {
                // First get card IDs from junction table
                const { data: setCards, error: junctionError } = await supabase
                    .from('flashcard_set_cards')
                    .select('card_id')
                    .eq('set_id', window.currentListSet.id);
                
                if (junctionError) throw junctionError;
                
                if (!setCards || setCards.length === 0) {
                    window.currentListCards = [];
                    return [];
                }
                
                // Get the actual cards
                const cardIds = setCards.map(sc => sc.card_id);
                const { data: cards, error } = await supabase
                    .from('cards')
                    .select('*')
                    .in('id', cardIds);
                
                if (error) throw error;
                
                // Load categories for each card
                for (const card of cards) {
                    const { data: cardCategories } = await supabase
                        .from('card_categories')
                        .select('category_id')
                        .eq('card_id', card.id);
                    
                    if (cardCategories && cardCategories.length > 0) {
                        const categoryIds = cardCategories.map(cc => cc.category_id);
                        const { data: categories } = await supabase
                            .from('categories')
                            .select('id, name')
                            .in('id', categoryIds);
                        
                        card.categories = categories || [];
                    } else {
                        card.categories = [];
                    }
                }
                
                window.currentListCards = cards;
                return cards;
                
            } catch (error) {
                console.error('Error reloading cards:', error);
                return window.currentListCards || [];
            }
        }

        function closeEditCardModal() {
            const editModalContainer = document.getElementById('editCardModalContainer');
            if (editModalContainer) {
                editModalContainer.style.display = 'none';
                editModalContainer.innerHTML = '';
            }
            
            currentEditCardId = null;
        }

        // New card system variables
        let cardsToAdd = []; // Legacy - not used in new system

        let currentTagsData = []; // Store available tags
        // Global variable for currently selected tags (no let/const = global scope)
        selectedTagsList = [];

        // LEGACY FUNCTIONS - NOT USED IN NEW SYSTEM
        // These are kept for compatibility but redirected to new system

        // NEW SYSTEM FUNCTIONS

        // Initialize tag system - categories are now loaded dynamically from database
        async function initializeTagSystem() {
            // No initialization needed - categories are loaded on-demand via autocomplete
            // Don't clear selectedTagsList here - it breaks tag processing in new cards
        }

        // Rich Text Editor Functions
        let activeEditor = null;

        function setActiveEditor(editor) {
            activeEditor = editor;
        }
        
        // Handle TAB navigation between rich text editors
        function handleTabNavigation(event, currentEditorId) {
            if (event.key === 'Tab') {
                event.preventDefault();
                
                if (event.shiftKey) {
                    // Shift+TAB (backward navigation)
                    if (currentEditorId === 'singleWordB') {
                        // Shift+TAB from B field -> go to A field
                        document.getElementById('singleWordA').focus();
                    } else if (currentEditorId === 'singleWordA') {
                        // Do nothing or could go to a previous field if needed
                        return;
                    }
                } else {
                    // TAB (forward navigation)
                    if (currentEditorId === 'singleWordA') {
                        // TAB from A field -> go to B field
                        document.getElementById('singleWordB').focus();
                    } else if (currentEditorId === 'singleWordB') {
                        // TAB from B field -> go to tags field
                        document.getElementById('singleTags').focus();
                    }
                }
            }
        }

        function formatText(editorId, command, value = null) {
            const editor = document.getElementById(editorId);
            editor.focus();
            
            try {
                // Modern DOM manipulation for complex formatting
                if (command === 'fontSize') {
                    applyStyleToSelection(editor, 'fontSize', value);
                } else if (command === 'foreColor') {
                    applyStyleToSelection(editor, 'color', value);
                } else {
                    // Use execCommand for simple formatting (bold, italic, underline)
                    document.execCommand(command, false, value);
                }
            } catch (error) {
                console.warn('Format command failed:', error);
                // Fallback to execCommand
                try {
                    document.execCommand(command, false, value);
                } catch (fallbackError) {
                    console.error('Fallback format failed:', fallbackError);
                }
            }
            
            updatePreview();
            updateToolbarState(editorId);
        }

        // Apply style to selected text with proper handling of existing formatting
        function applyStyleToSelection(editor, styleProperty, styleValue) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            if (range.collapsed) return;

            // Get selected content
            const selectedContent = range.extractContents();
            
            // Create wrapper span
            const span = document.createElement('span');
            span.style[styleProperty] = styleValue;
            span.appendChild(selectedContent);
            
            // Insert the wrapped content
            range.insertNode(span);
            
            // Restore selection
            const newRange = document.createRange();
            newRange.selectNodeContents(span);
            selection.removeAllRanges();
            selection.addRange(newRange);
        }

        // Toggle highlight with proper on/off functionality
        function toggleHighlight(editorId) {
            const editor = document.getElementById(editorId);
            editor.focus();
            
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            if (range.collapsed) return;

            // Check if selection is already highlighted
            const isHighlighted = isSelectionHighlighted(range);
            
            if (isHighlighted) {
                // Remove highlight
                removeHighlightFromSelection(range);
            } else {
                // Add highlight
                const selectedContent = range.extractContents();
                const span = document.createElement('span');
                span.style.backgroundColor = 'yellow';
                span.style.padding = '2px 4px';
                span.style.borderRadius = '3px';
                span.appendChild(selectedContent);
                range.insertNode(span);
                
                // Restore selection
                const newRange = document.createRange();
                newRange.selectNodeContents(span);
                selection.removeAllRanges();
                selection.addRange(newRange);
            }
            
            updatePreview();
            updateToolbarState(editorId);
        }

        // Check if the selection contains highlighted text
        function isSelectionHighlighted(range) {
            const container = range.commonAncestorContainer;
            
            // Check if we're inside a highlighted span
            let parent = container.nodeType === 3 ? container.parentNode : container;
            while (parent && parent.tagName !== 'DIV') {
                if (parent.tagName === 'SPAN' && parent.style.backgroundColor === 'yellow') {
                    return true;
                }
                parent = parent.parentNode;
            }
            
            return false;
        }

        // Remove highlight from selection
        function removeHighlightFromSelection(range) {
            const container = range.commonAncestorContainer;
            let parent = container.nodeType === 3 ? container.parentNode : container;
            
            // Find the highlighted span
            while (parent && parent.tagName !== 'DIV') {
                if (parent.tagName === 'SPAN' && parent.style.backgroundColor === 'yellow') {
                    // Replace the span with its contents
                    const parentNode = parent.parentNode;
                    while (parent.firstChild) {
                        parentNode.insertBefore(parent.firstChild, parent);
                    }
                    parentNode.removeChild(parent);
                    break;
                }
                parent = parent.parentNode;
            }
        }

        // Update toolbar button states based on current selection
        function updateToolbarState(editorId) {
            const toolbarId = editorId === 'singleWordA' ? 'toolbarA' : 'toolbarB';
            const toolbar = document.getElementById(toolbarId);
            if (!toolbar) return;

            // Reset all button states
            const buttons = toolbar.querySelectorAll('.toolbar-btn');
            buttons.forEach(btn => btn.classList.remove('active'));

            // Check current formatting at cursor/selection
            try {
                if (document.queryCommandState('bold')) {
                    const boldBtn = toolbar.querySelector('[title="Félkövér"]');
                    if (boldBtn) boldBtn.classList.add('active');
                }
                
                if (document.queryCommandState('italic')) {
                    const italicBtn = toolbar.querySelector('[title="Dőlt"]');
                    if (italicBtn) italicBtn.classList.add('active');
                }
                
                if (document.queryCommandState('underline')) {
                    const underlineBtn = toolbar.querySelector('[title="Aláhúzás"]');
                    if (underlineBtn) underlineBtn.classList.add('active');
                }

                // Check for highlighting
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    if (isSelectionHighlighted(range)) {
                        const highlightBtn = toolbar.querySelector('.highlight-btn');
                        if (highlightBtn) highlightBtn.classList.add('active');
                    }
                }
            } catch (error) {
                console.warn('Error updating toolbar state:', error);
            }
        }

        function clearFormatting(editorId) {
            const editor = document.getElementById(editorId);
            editor.focus();
            
            const selection = window.getSelection();
            
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                
                if (!range.collapsed) {
                    // Clear formatting for selected text only
                    try {
                        document.execCommand('removeFormat', false);
                    } catch (error) {
                        // Fallback: replace with plain text
                        const selectedText = range.toString();
                        range.deleteContents();
                        range.insertNode(document.createTextNode(selectedText));
                    }
                } else {
                    // Clear all formatting in the editor
                    const plainText = editor.textContent;
                    editor.innerHTML = '';
                    editor.appendChild(document.createTextNode(plainText));
                }
            } else {
                // Clear all formatting in the editor
                const plainText = editor.textContent;
                editor.innerHTML = '';
                editor.appendChild(document.createTextNode(plainText));
            }
            
            // Visual feedback
            editor.style.borderColor = '#ef4444';
            setTimeout(() => {
                editor.style.borderColor = '#e2e8f0';
            }, 300);
            
            updatePreview();
        }

        function updateToolbarState(editorId) {
            // Add visual feedback when formatting is applied
            const editor = document.getElementById(editorId);
            const selection = window.getSelection();
            
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const commonAncestor = range.commonAncestorContainer;
                
                // Check if we're inside formatted text
                let element = commonAncestor.nodeType === Node.TEXT_NODE 
                    ? commonAncestor.parentElement 
                    : commonAncestor;
                
                // Add temporary highlight to show the formatting worked
                editor.style.borderColor = '#10b981';
                setTimeout(() => {
                    editor.style.borderColor = '#667eea';
                }, 300);
            }
        }

        function handleRichTextKeydown(event, currentEditorId = null) {
            const editorId = currentEditorId || event.target.id;
            
            // Handle TAB navigation
            if (event.key === 'Tab') {
                handleTabNavigation(event, editorId);
                return;
            }
            
            // Handle keyboard shortcuts
            if (event.ctrlKey || event.metaKey) {
                switch (event.key.toLowerCase()) {
                    case 'b':
                        event.preventDefault();
                        formatText(editorId, 'bold');
                        break;
                    case 'i':
                        event.preventDefault();
                        formatText(editorId, 'italic');
                        break;
                    case 'u':
                        event.preventDefault();
                        formatText(editorId, 'underline');
                        break;
                }
            }
            
            // Update toolbar state after any key press
            setTimeout(() => updateToolbarState(editorId), 10);
        }

        function checkRequired(editor) {
            const content = editor.textContent.trim();
            if (!content) {
                editor.classList.add('required-error');
            } else {
                editor.classList.remove('required-error');
            }
        }

        function getRichTextContent(editorId) {
            const editor = document.getElementById(editorId);
            return editor.innerHTML;
        }

        function setRichTextContent(editorId, content) {
            const editor = document.getElementById(editorId);
            editor.innerHTML = content;
        }

        function getRichTextPlainText(editorId) {
            const editor = document.getElementById(editorId);
            return editor.textContent.trim();
        }

        // Update card preview
        function updatePreview() {
            const wordA = getRichTextPlainText('singleWordA');
            const wordB = getRichTextPlainText('singleWordB');
            const mediaUrl = window.currentMediaUrl || '';
            const mediaType = window.currentMediaType || 'image';
            
            // Show/hide preview section
            const preview = document.getElementById('cardPreview');
            if (wordA || wordB || mediaUrl || selectedTagsList.length > 0) {
                preview.style.display = 'block';
                
                // Update A language card content
                const previewWordA = document.getElementById('previewWordA');
                const wordAContent = getRichTextContent('singleWordA');
                if (wordAContent && wordAContent.trim() !== '') {
                    previewWordA.innerHTML = wordAContent;
                } else {
                    previewWordA.innerHTML = '<span style="color: #9ca3af; font-style: italic;">Nincs szöveg</span>';
                }
                
                // Update B language card content
                const previewWordB = document.getElementById('previewWordB');
                const wordBContent = getRichTextContent('singleWordB');
                if (wordBContent && wordBContent.trim() !== '') {
                    previewWordB.innerHTML = wordBContent;
                } else {
                    previewWordB.innerHTML = '<span style="color: #000000; font-style: italic;">Nincs fordítás</span>';
                }
                

                // Update media preview
                updateMediaPreview(mediaUrl, mediaType);
                
                // Enable approve button if both words are filled
                const approveBtn = document.getElementById('approveBtn');
                const approveBtn2 = document.getElementById('approveBtn2');
                
                if (wordA && wordB) {
                    if (approveBtn) {
                    approveBtn.disabled = false;
                    approveBtn.style.opacity = '1';
                    }
                    if (approveBtn2) {
                        approveBtn2.disabled = false;
                        approveBtn2.style.opacity = '1';
                    }
                } else {
                    if (approveBtn) {
                    approveBtn.disabled = true;
                    approveBtn.style.opacity = '0.5';
                    }
                    if (approveBtn2) {
                        approveBtn2.disabled = true;
                        approveBtn2.style.opacity = '0.5';
                    }
                }
                
            } else {
                preview.style.display = 'none';
            }
        }

        // Update media preview in both cards
        function updateMediaPreview(mediaUrl, mediaType) {
            const containerA = document.getElementById('previewMediaContainer');
            const containerB = document.getElementById('previewMediaContainerB');
            const deleteMediaBtn = document.getElementById('deleteMediaBtn');
            
            if (!mediaUrl) {
                // Default state for A card (blue theme)
                containerA.innerHTML = `
                    <div style="text-align: center; color: #94a3b8; padding: 60px 20px;">
                        <div style="font-size: 32px; margin-bottom: 8px;">📷</div>
                        <div style="font-size: 12px;">Kép vagy média</div>
                    </div>
                `;
                containerA.style.background = 'rgba(102, 126, 234, 0.02)';
                
                // Default state for B card (purple theme)
                containerB.innerHTML = `
                    <div style="text-align: center; color: #a855f7; padding: 60px 20px;">
                        <div style="font-size: 32px; margin-bottom: 8px;">📷</div>
                        <div style="font-size: 12px;">Kép vagy média</div>
                    </div>
                `;
                containerB.style.background = 'rgba(126, 58, 237, 0.02)';
                
                // Hide delete button
                if (deleteMediaBtn) {
                    deleteMediaBtn.style.display = 'none';
                }
                
                return;
            }
            
            // Set background and content for both containers
            containerA.style.background = '#ffffff';
            containerB.style.background = '#ffffff';
            
            let content = '';
            switch (mediaType) {
                case 'image':
                case 'gif':
                    content = '<img src="' + mediaUrl + '" style="width: 100%; height: 100%; object-fit: cover;" alt="Preview">';
                    break;
                case 'video':
                    content = '<video src="' + mediaUrl + '" style="width: 100%; height: 100%; object-fit: cover;" controls></video>';
                    break;
                case 'youtube':
                    let embedUrl = mediaUrl;
                                if (mediaUrl.includes('youtube.com/watch?v=')) {
                const videoId = mediaUrl.split('v=')[1].split('&')[0];
                embedUrl = window.SNAPPY_CONFIG.external.youtube.embedBase + videoId;
            } else if (mediaUrl.includes('youtu.be/')) {
                const videoId = mediaUrl.split('youtu.be/')[1].split('?')[0];
                embedUrl = window.SNAPPY_CONFIG.external.youtube.embedBase + videoId;
            }
                    content = '<iframe src="' + embedUrl + '" style="width: 100%; height: 100%;" frameborder="0" allowfullscreen></iframe>';
                    break;
                default:
                    content = `
                        <div style="text-align: center; color: #667eea;">
                            <div style="font-size: 32px; margin-bottom: 8px;">🎬</div>
                            <div style="font-size: 12px;">Média tartalom</div>
                        </div>
                    `;
            }
            
            // Apply content to both cards
            containerA.innerHTML = content;
            containerB.innerHTML = content;
            
            // Show delete button
            if (deleteMediaBtn) {
                deleteMediaBtn.style.display = 'inline-block';
            }
        }

        // Handle tag input with autocomplete from categories table
        async function handleTagInput(value) {
            console.log('🏷️ handleTagInput called with:', value);
            const suggestions = document.getElementById('tagSuggestions');
            console.log('🏷️ suggestions element found:', !!suggestions);
            
            if (!value.trim()) {
                suggestions.style.display = 'none';
                return;
            }
            
            // Process completed tags (before the last comma) in real-time
            const tags = value.split(',');
            const completedTags = tags.slice(0, -1); // All except the last one
            const currentTag = tags[tags.length - 1].trim().toLowerCase();
            
            // Add completed tags to selectedTagsList if they're not already there
            let tagsAdded = false;
            for (const tag of completedTags) {
                const trimmedTag = tag.trim();
                if (trimmedTag && !selectedTagsList.includes(trimmedTag)) {
                    selectedTagsList.push(trimmedTag);
                    tagsAdded = true;
                }
            }
            
            // If we added new tags, update the display and input field
            if (tagsAdded) {
                displaySelectedTags();
                updateCategoryPlaceholder();
                
                // Update input to show only the current (incomplete) tag
                const input = document.getElementById('singleTags');
                if (input && input.value !== currentTag) {
                    input.value = tags[tags.length - 1]; // Keep original spacing
                }
            }
            
            if (currentTag.length < 1) {
                suggestions.style.display = 'none';
                return;
            }
            
            try {
                // Search categories from database
                console.log('🔍 Searching for tags containing:', currentTag);
                const { data: categories, error } = await supabase
                    .from('categories')
                    .select('name')
                    .ilike('name', '%' + currentTag + '%')
                    .limit(10);
                
                console.log('🔍 Database results:', categories, error);
                
                if (error) {
                    console.error('Error loading categories:', error);
                    suggestions.style.display = 'none';
                    return;
                }
                
                // Filter out already selected tags
                const matches = categories
                    .map(cat => cat.name)
                    .filter(name => !selectedTagsList.includes(name));
                    
                console.log('🔍 Filtered matches:', matches);
                
                const exactMatch = matches.find(name => name.toLowerCase() === currentTag);
                
                let suggestionsHTML = '';
                
                // Show matching categories
                if (matches.length > 0) {
                    suggestionsHTML += matches.map(tag => 
                        `<div class="tag-suggestion" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f5f9; transition: all 0.2s ease; display: flex; align-items: center; justify-content: space-between;" 
                             onmouseover="this.style.background='#f8fafc'" 
                             onmouseout="this.style.background='white'"
                             onclick="selectTag('${tag}')">
                            <span>${tag}</span>
                            <span style="color: #64748b; font-size: 12px;">meglévő</span>
                        </div>`
                    ).join('');
                }
                
                // Add "Create new" option if not exact match
                if (!exactMatch && currentTag.length >= 2) {
                    suggestionsHTML += `
                        <div class="tag-suggestion" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f5f9; transition: all 0.2s ease; display: flex; align-items: center; justify-content: space-between; background: rgba(102, 126, 234, 0.05);" 
                             onmouseover="this.style.background='rgba(102, 126, 234, 0.1)'" 
                             onmouseout="this.style.background='rgba(102, 126, 234, 0.05)'"
                             onclick="selectTag('${currentTag}')">
                            <span><strong>+ "${currentTag}"</strong></span>
                            <span style="color: #667eea; font-size: 12px; font-weight: 600;">új létrehozása</span>
                        </div>`;
                }
                
                if (suggestionsHTML) {
                    suggestions.innerHTML = suggestionsHTML;
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error in tag autocomplete:', error);
                suggestions.style.display = 'none';
            }
        }

        // Handle category keydown (Enter, Tab)
        function handleTagKeydown(event) {
            const input = event.target;
            const value = input.value.trim();
            
            if (event.key === 'Tab') {
                // Handle TAB navigation
                if (value) {
                                    // Add single tag (no comma support)
                event.preventDefault();
                const category = value.trim();
                
                // Add category if not already selected and not empty
                if (category && !selectedTagsList.includes(category)) {
                    selectedTagsList.push(category);
                }
                    
                    // Clear input and update display
                    input.value = '';
                    const tagSuggestions = document.getElementById('tagSuggestions');
                    if (tagSuggestions) {
                        tagSuggestions.style.display = 'none';
                    }
                    displaySelectedTags();
                    updatePreview();
                    updateCategoryPlaceholder();
                    
                    // Then navigate to next field
                    setTimeout(() => {
                        if (event.shiftKey) {
                            // Shift+TAB -> go back to B field
                            document.getElementById('singleWordB').focus();
                        } else {
                            // TAB -> go to video URL field
                            document.getElementById('singleVideoUrl').focus();
                        }
                    }, 0);
                } else {
                    // No text, just navigate (keep existing categories)
                    if (event.shiftKey) {
                        // Shift+TAB -> go back to B field
                        event.preventDefault();
                        document.getElementById('singleWordB').focus();
                    } else {
                        // TAB -> go to video URL field
                        event.preventDefault();
                        document.getElementById('singleVideoUrl').focus();
                    }
                }
            } else if (event.key === 'Enter' && value) {
                event.preventDefault();
                
                // Add single tag (no comma support)
                const category = value.trim();
                
                // Add category if not already selected and not empty
                if (category && !selectedTagsList.includes(category)) {
                    selectedTagsList.push(category);
                }
                
                // Clear input and update display
                input.value = '';
                document.getElementById('tagSuggestions').style.display = 'none';
                displaySelectedTags();
                updatePreview();
                updateCategoryPlaceholder();
            } else if (event.key === 'Escape') {
                // Clear input but keep selected categories
                event.preventDefault();
                input.value = '';
                document.getElementById('tagSuggestions').style.display = 'none';
            }
        }

        // Update category placeholder based on selection
        function updateCategoryPlaceholder() {
            const input = document.getElementById('singleTags');
            if (selectedTagsList.length > 0) {
                if (selectedTagsList.length === 1) {
                    input.placeholder = 'Kiválasztott: ' + selectedTagsList[0] + ' - Adj hozzá újat';
                } else {
                    input.placeholder = '' + selectedTagsList.length + ' kategória kiválasztva - Adj hozzá újat';
                }
            } else {
                input.placeholder = 'pl. állatok, ételek, utazás (vesszővel elválasztva)';
            }
        }
        
        // Select category from suggestions
        function selectTag(tag) {
            if (!selectedTagsList.includes(tag)) {
                selectedTagsList.push(tag); // Add to existing categories
            }
            displaySelectedTags();
            updatePreview();
            
            document.getElementById('singleTags').value = '';
            document.getElementById('tagSuggestions').style.display = 'none';
            updateCategoryPlaceholder();
        }

        // Display selected tags as chips
        function displaySelectedTags() {
            const container = document.getElementById('selectedTags');
            container.innerHTML = selectedTagsList.map((tag, index) => 
                `<span class="tag-chip">
                    ${tag}
                    <span class="remove" onclick="removeTag(${index})">×</span>
                </span>`
            ).join('');
        }

        // Remove tag
        function removeTag(index) {
            selectedTagsList.splice(index, 1);
            displaySelectedTags();
            updatePreview();
            updateCategoryPlaceholder();
        }

        // Approve and save current card to database
        async function approveCard() {
            const wordA = getRichTextPlainText('singleWordA');
            const wordB = getRichTextPlainText('singleWordB');
            const wordAFormatted = getRichTextContent('singleWordA');
            const wordBFormatted = getRichTextContent('singleWordB');
            const mediaType = window.currentMediaType || null;
            const mediaUrl = window.currentMediaUrl || null;
            const tagsInput = document.getElementById('singleTags').value.trim();
            
            // Parse comma-separated tags and add them to selectedTagsList
            if (tagsInput) {
                const tagNames = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
                for (const tagName of tagNames) {
                    if (!selectedTagsList.includes(tagName)) {
                        selectedTagsList.push(tagName);
                    }
                }
            }
            
            if (!wordA || !wordB) {
                showErrorMessage('Mindkét nyelvi mező kitöltése kötelező!');
                return;
            }
            
            const approveBtn = document.getElementById('approveBtn');
            const approveBtn2 = document.getElementById('approveBtn2');
            const originalContent = approveBtn ? approveBtn.innerHTML : '';
            const originalContent2 = approveBtn2 ? approveBtn2.innerHTML : '';
            
            try {
                // Update button state
                if (approveBtn) {
                approveBtn.disabled = true;
                approveBtn.innerHTML = '⏳';
                }
                if (approveBtn2) {
                    approveBtn2.disabled = true;
                    approveBtn2.innerHTML = '⏳';
                }
                
                const card = {
                    title: wordA, // Plain text for search/indexing
                    english_title: wordB, // Plain text for search/indexing
                    title_formatted: wordAFormatted, // Rich text for display
                    english_title_formatted: wordBFormatted, // Rich text for display
                    media_type: mediaType,
                    media_url: mediaUrl || null, // Don't add default URL
                    image_url: mediaUrl || null, // Don't add default URL
                    image_alt: wordA + ' - ' + wordB,
                    category_id: null, // Will be set if tags are selected
                    difficulty_level: 1
                };
                
                // Save to database
                await saveSingleCardToDatabase(currentSetId, card);
                
                // Success state
                if (approveBtn) approveBtn.innerHTML = '';
                if (approveBtn2) approveBtn2.innerHTML = '';
                showSuccessMessage(` Kártya sikeresen mentve az adatbázisba!`);
                
                // Clear form and close modal after short delay
                setTimeout(() => {
                    clearForm();
                    if (approveBtn) {
                    approveBtn.disabled = false;
                    approveBtn.innerHTML = originalContent;
                    }
                    if (approveBtn2) {
                        approveBtn2.disabled = false;
                        approveBtn2.innerHTML = originalContent2;
                    }
                    // Close the add cards modal
                    closeAddCardsModal();
                    // Reload dashboard data to update card counts
                    loadDashboardData();
                }, 1500);
                
            } catch (error) {
                console.error('Error saving card:', error);
                showErrorMessage(error.message || 'Hiba történt a kártya mentésekor');
                
                // Reset button
                if (approveBtn) {
                approveBtn.disabled = false;
                approveBtn.innerHTML = originalContent;
                }
                if (approveBtn2) {
                    approveBtn2.disabled = false;
                    approveBtn2.innerHTML = originalContent2;
                }
            }
        }
        
        // Save single card to database with categories
        async function saveSingleCardToDatabase(setId, cardData) {
            // Insert card to cards table first
            const { data: card, error: cardError } = await supabase
                .from('cards')
                .insert(cardData)
                .select()
                .single();
            
            if (cardError) {
                throw new Error('Kártya mentési hiba: ' + cardError.message + '');
            }
            
            // Link card to flashcard set
            const { error: linkError } = await supabase
                .from('flashcard_set_cards')
                .insert({
                    set_id: setId,
                    card_id: card.id
                });
            
            if (linkError) {
                console.error('Error linking card to set:', linkError);
                throw new Error('Kártya összekapcsolási hiba: ' + linkError.message + '');
            }
            
            // Handle categories if any are selected - create many-to-many relationships
            if (selectedTagsList.length > 0) {
                const cardCategories = [];
                for (const tagName of selectedTagsList) {
                    // Get or create category
                    const categoryId = await getOrCreateCategory(tagName);
                    cardCategories.push({
                        card_id: card.id,
                        category_id: categoryId
                    });
                }
                
                // Insert all card-category relationships
                const { error: categoryError } = await supabase
                    .from('card_categories')
                    .insert(cardCategories);
                
                if (categoryError) {
                    console.error('Error linking card to categories:', categoryError);
                    // Don't throw - the card was created successfully
                }
            }
            
            return card;
        }
        
        // Get existing category or create new one
        async function getOrCreateCategory(categoryName) {
            const trimmedName = categoryName.trim().toLowerCase();
            
            // Try to find existing category (using ilike for better Unicode support)
            const { data: existingCategories, error: findError } = await supabase
                .from('categories')
                .select('id, name')
                .ilike('name', trimmedName)
                .limit(1);
            
            // Check for exact match
            const existingCategory = existingCategories?.find(cat => 
                cat.name.toLowerCase() === trimmedName
            );
            
            if (existingCategory) {
                return existingCategory.id;
            }
            
            // Handle search errors
            if (findError) {
                console.warn('Category search error (non-critical):', findError.message);
            }
            
            // Create new category if not found
            const { data: newCategory, error: createError } = await supabase
                .from('categories')
                .insert({
                    name: trimmedName,
                    description: 'Automatikusan létrehozott kategória: ' + trimmedName + ''
                })
                .select('id')
                .single();
            
            if (createError) {
                throw new Error('Kategória létrehozási hiba: ' + createError.message + '');
            }
            
            return newCategory.id;
        }
        
        // Update card categories - delete old ones and add new ones
        async function updateCardCategories(cardId, tagsInput) {
            try {
                // Parse comma-separated tags
                const tagNames = tagsInput ? 
                    tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0) : 
                    [];
                
                // Delete existing card-category relationships
                const { error: deleteError } = await supabase
                    .from('card_categories')
                    .delete()
                    .eq('card_id', cardId);
                
                if (deleteError) {
                    console.error('Error deleting old categories:', deleteError);
                    // Don't throw - continue with adding new ones
                }
                
                // Add new categories if any
                if (tagNames.length > 0) {
                    const cardCategories = [];
                    for (const tagName of tagNames) {
                        // Get or create category
                        const categoryId = await getOrCreateCategory(tagName);
                        cardCategories.push({
                            card_id: cardId,
                            category_id: categoryId
                        });
                    }
                    
                    // Insert all card-category relationships
                    const { error: insertError } = await supabase
                        .from('card_categories')
                        .insert(cardCategories);
                    
                    if (insertError) {
                        console.error('Error adding new categories:', insertError);
                        // Don't throw - the card was updated successfully
                    }
                }
                
            } catch (error) {
                console.error('Error updating card categories:', error);
                // Don't throw - the card update was successful
            }
        }
        
        // Update card categories from selectedTagsList
        async function updateCardCategoriesFromList(cardId, tagsList) {
            console.log('🏷️ updateCardCategoriesFromList called with:', cardId, tagsList);
            try {
                // Create service role client for admin operations
                const { createClient } = window.supabase;
                const serviceSupabase = createClient(
                    'https://aeijlzokobuqcyznljvn.supabase.co',
                    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFlaWpsem9rb2J1cWN5em5sanZuIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDU2NjA1NiwiZXhwIjoyMDcwMTQyMDU2fQ.wwrrCv8xd3uECT24fBKasPk5MJPz3hlS_32jzJebbhs'
                );
                
                // Delete existing card-category relationships using service role
                const { error: deleteError } = await serviceSupabase
                    .from('card_categories')
                    .delete()
                    .eq('card_id', cardId);
                
                if (deleteError) {
                    console.error('Error deleting old categories:', deleteError);
                    // Don't throw - continue with adding new ones
                }
                
                // Add new categories if any
                if (tagsList && tagsList.length > 0) {
                    console.log('🏷️ Adding tags to card:', tagsList);
                    const cardCategories = [];
                    for (const tagName of tagsList) {
                        // Get or create category
                        const categoryId = await getOrCreateCategory(tagName);
                        console.log('🏷️ Category ID for', tagName, ':', categoryId);
                        cardCategories.push({
                            card_id: cardId,
                            category_id: categoryId
                        });
                    }
                    
                    // Insert all card-category relationships using service role
                    console.log('🏷️ Inserting card-category relationships:', cardCategories);
                    const { error: insertError } = await serviceSupabase
                        .from('card_categories')
                        .insert(cardCategories);
                    
                    if (insertError) {
                        console.error('❌ Error adding new categories:', insertError);
                        // Don't throw - the card was updated successfully
                    } else {
                        console.log('✅ Categories successfully linked to card!');
                    }
                }
            } catch (error) {
                console.error('Error updating card categories:', error);
            }
        }

        // Clear form
        function clearForm() {
            // Clear rich text editors
            setRichTextContent('singleWordA', '');
            setRichTextContent('singleWordB', '');
            
            // Clear other fields
            document.getElementById('singleTags').value = '';
            document.getElementById('singleMediaFile').value = '';
            document.getElementById('singleVideoUrl').value = '';
            document.getElementById('fileStatus').textContent = '';
            document.getElementById('tagSuggestions').style.display = 'none';
            
            // Clear media data
            window.currentMediaUrl = null;
            window.currentMediaType = null;
            
            // Hide image delete button
            // Button is now part of the media container
            
            // Remove error states
            document.getElementById('singleWordA').classList.remove('required-error');
            document.getElementById('singleWordB').classList.remove('required-error');
            
            selectedTagsList = [];
            displaySelectedTags();
            updatePreview();
            updateCategoryPlaceholder();
        }

        // Image delete button functions (now using top button)
        function showImageDeleteButton() {
            const deleteMediaBtn = document.getElementById('deleteMediaBtn');
            if (deleteMediaBtn) {
                deleteMediaBtn.style.display = 'inline-block';
            }
        }

        function hideImageDeleteButton() {
            const deleteMediaBtn = document.getElementById('deleteMediaBtn');
            if (deleteMediaBtn) {
                deleteMediaBtn.style.display = 'none';
            }
        }

        // Delete uploaded image
        function deleteUploadedImage() {
            // Clear the file input
            const fileInput = document.getElementById('singleMediaFile');
            if (fileInput) {
                fileInput.value = '';
            }
            
            // Clear video URL input
            const videoInput = document.getElementById('singleVideoUrl');
            if (videoInput) {
                videoInput.value = '';
            }
            
            // Clear media data
            window.currentMediaUrl = null;
            window.currentMediaType = null;
            
            // Clear status
            const statusElement = document.getElementById('fileStatus');
            if (statusElement) {
                statusElement.textContent = '';
            }
            
            // Hide delete buttons
            // Button is now part of the media container
            
            // Update preview to remove image
            updatePreview();
            
            // Show success message
            showSuccessMessage(' Média sikeresen törölve');
        }





        function getDefaultMediaUrl(mediaType) {
            switch(mediaType) {
                case 'image':
                case 'gif':
                    return 'https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=300&fit=crop';
                case 'video':
                    return 'https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4';
                case 'youtube':
                    return 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';
                default:
                    return 'https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=300&fit=crop';
            }
        }





        // Add cards to database
        async function addCardsToDatabase(setId, cards) {
            const results = [];
            
            for (let cardData of cards) {
                // Insert card
                const { data: card, error: cardError } = await supabase
                    .from('cards')
                    .insert(cardData)
                    .select()
                    .single();
                
                if (cardError) {
                    console.error('Error creating card:', cardError);
                    continue;
                }
                
                // Link card to set
                const { error: linkError } = await supabase
                    .from('flashcard_set_cards')
                    .insert({
                        set_id: setId,
                        card_id: card.id,
                        position: results.length + 1
                    });
                
                if (linkError) {
                    console.error('Error linking card to set:', linkError);
                    // Try to clean up the orphaned card
                    await supabase.from('cards').delete().eq('id', card.id);
                    continue;
                }
                
                results.push(card);
            }
            
            return results;
        }

        // Set management functions
        async function editSet(setId) {
            closeAllDropdowns();
            
            // Find the set data
            const set = dashboardData.ownSets.find(s => s.id === setId);
            if (!set) {
                showErrorMessage('Szett nem található!');
                return;
            }
            
            // Show edit modal
            showEditSetModal(set);
        }

        // Multilingual language database - languages in different languages
        const worldLanguagesMultilingual = {
            en: {
                'Afrikaans': 'Afrikaans', 'Albanian': 'Albanian', 'Amharic': 'Amharic', 'Arabic': 'Arabic', 'Armenian': 'Armenian', 'Assamese': 'Assamese', 'Azerbaijani': 'Azerbaijani',
                'Basque': 'Basque', 'Belarusian': 'Belarusian', 'Bengali': 'Bengali', 'Bhojpuri': 'Bhojpuri', 'Bosnian': 'Bosnian', 'Bulgarian': 'Bulgarian', 'Burmese': 'Burmese',
                'Catalan': 'Catalan', 'Cebuano': 'Cebuano', 'Cherokee': 'Cherokee', 'Chinese': 'Chinese', 'Corsican': 'Corsican', 'Croatian': 'Croatian', 'Czech': 'Czech',
                'Danish': 'Danish', 'Dhivehi': 'Dhivehi', 'Dutch': 'Dutch', 'Dzongkha': 'Dzongkha',
                'English': 'English', 'Esperanto': 'Esperanto', 'Estonian': 'Estonian', 'Ewe': 'Ewe',
                'Faroese': 'Faroese', 'Fijian': 'Fijian', 'Filipino': 'Filipino', 'Finnish': 'Finnish', 'French': 'French', 'Frisian': 'Frisian', 'Fulah': 'Fulah',
                'Galician': 'Galician', 'Ganda': 'Ganda', 'Georgian': 'Georgian', 'German': 'German', 'Greek': 'Greek', 'Gujarati': 'Gujarati', 'Guarani': 'Guarani',
                'Haitian Creole': 'Haitian Creole', 'Hausa': 'Hausa', 'Hawaiian': 'Hawaiian', 'Hebrew': 'Hebrew', 'Hindi': 'Hindi', 'Hmong': 'Hmong', 'Hungarian': 'Hungarian',
                'Icelandic': 'Icelandic', 'Igbo': 'Igbo', 'Indonesian': 'Indonesian', 'Inuktitut': 'Inuktitut', 'Irish': 'Irish', 'Italian': 'Italian',
                'Japanese': 'Japanese', 'Javanese': 'Javanese', 'Kannada': 'Kannada', 'Kashmiri': 'Kashmiri', 'Kazakh': 'Kazakh', 'Khmer': 'Khmer', 'Kinyarwanda': 'Kinyarwanda', 'Korean': 'Korean', 'Kurdish': 'Kurdish', 'Kyrgyz': 'Kyrgyz',
                'Lao': 'Lao', 'Latin': 'Latin', 'Latvian': 'Latvian', 'Lingala': 'Lingala', 'Lithuanian': 'Lithuanian', 'Luxembourgish': 'Luxembourgish',
                'Macedonian': 'Macedonian', 'Malagasy': 'Malagasy', 'Malay': 'Malay', 'Malayalam': 'Malayalam', 'Maltese': 'Maltese', 'Maori': 'Maori', 'Marathi': 'Marathi', 'Mongolian': 'Mongolian',
                'Nepali': 'Nepali', 'Norwegian': 'Norwegian', 'Odia': 'Odia', 'Oromo': 'Oromo',
                'Pashto': 'Pashto', 'Persian': 'Persian', 'Polish': 'Polish', 'Portuguese': 'Portuguese', 'Punjabi': 'Punjabi',
                'Quechua': 'Quechua', 'Romanian': 'Romanian', 'Russian': 'Russian',
                'Samoan': 'Samoan', 'Sanskrit': 'Sanskrit', 'Scots Gaelic': 'Scots Gaelic', 'Serbian': 'Serbian', 'Sesotho': 'Sesotho', 'Shona': 'Shona', 'Sindhi': 'Sindhi', 'Sinhala': 'Sinhala', 'Slovak': 'Slovak', 'Slovenian': 'Slovenian', 'Somali': 'Somali', 'Spanish': 'Spanish', 'Sundanese': 'Sundanese', 'Swahili': 'Swahili', 'Swedish': 'Swedish',
                'Tagalog': 'Tagalog', 'Tajik': 'Tajik', 'Tamil': 'Tamil', 'Tatar': 'Tatar', 'Telugu': 'Telugu', 'Thai': 'Thai', 'Tibetan': 'Tibetan', 'Tigrinya': 'Tigrinya', 'Tongan': 'Tongan', 'Turkish': 'Turkish', 'Turkmen': 'Turkmen',
                'Ukrainian': 'Ukrainian', 'Urdu': 'Urdu', 'Uyghur': 'Uyghur', 'Uzbek': 'Uzbek',
                'Vietnamese': 'Vietnamese', 'Welsh': 'Welsh', 'Wolof': 'Wolof',
                'Xhosa': 'Xhosa', 'Yiddish': 'Yiddish', 'Yoruba': 'Yoruba', 'Zulu': 'Zulu'
            },
            hu: {
                'Afrikaans': 'Afrikaans', 'Albanian': 'Albán', 'Amharic': 'Amhara', 'Arabic': 'Arab', 'Armenian': 'Örmény', 'Assamese': 'Asszámi', 'Azerbaijani': 'Azeri',
                'Basque': 'Baszk', 'Belarusian': 'Belarusz', 'Bengali': 'Bengáli', 'Bhojpuri': 'Bhojpuri', 'Bosnian': 'Bosnyák', 'Bulgarian': 'Bolgár', 'Burmese': 'Burmai',
                'Catalan': 'Katalán', 'Cebuano': 'Cebuano', 'Cherokee': 'Cseroki', 'Chinese': 'Kínai', 'Corsican': 'Korzikai', 'Croatian': 'Horvát', 'Czech': 'Cseh',
                'Danish': 'Dán', 'Dhivehi': 'Divehi', 'Dutch': 'Holland', 'Dzongkha': 'Dzongkha',
                'English': 'Angol', 'Esperanto': 'Eszperantó', 'Estonian': 'Észt', 'Ewe': 'Ewe',
                'Faroese': 'Feröeri', 'Fijian': 'Fidzsi', 'Filipino': 'Filipino', 'Finnish': 'Finn', 'French': 'Francia', 'Frisian': 'Fríz', 'Fulah': 'Fulah',
                'Galician': 'Galíciai', 'Ganda': 'Ganda', 'Georgian': 'Grúz', 'German': 'Német', 'Greek': 'Görög', 'Gujarati': 'Gudzsaráti', 'Guarani': 'Guarani',
                'Haitian Creole': 'Haiti kreol', 'Hausa': 'Hausza', 'Hawaiian': 'Hawaii', 'Hebrew': 'Héber', 'Hindi': 'Hindi', 'Hmong': 'Hmong', 'Hungarian': 'Magyar',
                'Icelandic': 'Izlandi', 'Igbo': 'Igbo', 'Indonesian': 'Indonéz', 'Inuktitut': 'Inuktitut', 'Irish': 'Ír', 'Italian': 'Olasz',
                'Japanese': 'Japán', 'Javanese': 'Jávai', 'Kannada': 'Kannada', 'Kashmiri': 'Kasmíri', 'Kazakh': 'Kazah', 'Khmer': 'Khmer', 'Kinyarwanda': 'Kinyarwanda', 'Korean': 'Koreai', 'Kurdish': 'Kurd', 'Kyrgyz': 'Kirgiz',
                'Lao': 'Lao', 'Latin': 'Latin', 'Latvian': 'Lett', 'Lingala': 'Lingala', 'Lithuanian': 'Litván', 'Luxembourgish': 'Luxemburgi',
                'Macedonian': 'Macedón', 'Malagasy': 'Malagasy', 'Malay': 'Maláj', 'Malayalam': 'Malayalam', 'Maltese': 'Máltai', 'Maori': 'Maori', 'Marathi': 'Marathi', 'Mongolian': 'Mongol',
                'Nepali': 'Nepáli', 'Norwegian': 'Norvég', 'Odia': 'Odia', 'Oromo': 'Oromo',
                'Pashto': 'Pastu', 'Persian': 'Perzsa', 'Polish': 'Lengyel', 'Portuguese': 'Portugál', 'Punjabi': 'Pandzsábi',
                'Quechua': 'Kecsua', 'Romanian': 'Román', 'Russian': 'Orosz',
                'Samoan': 'Szamoai', 'Sanskrit': 'Szanszkrit', 'Scots Gaelic': 'Skót gael', 'Serbian': 'Szerb', 'Sesotho': 'Sesotho', 'Shona': 'Shona', 'Sindhi': 'Sindhi', 'Sinhala': 'Szingaléz', 'Slovak': 'Szlovák', 'Slovenian': 'Szlovén', 'Somali': 'Szomáli', 'Spanish': 'Spanyol', 'Sundanese': 'Szundanéz', 'Swahili': 'Szuahéli', 'Swedish': 'Svéd',
                'Tagalog': 'Tagalog', 'Tajik': 'Tadzsik', 'Tamil': 'Tamil', 'Tatar': 'Tatár', 'Telugu': 'Telugu', 'Thai': 'Thai', 'Tibetan': 'Tibeti', 'Tigrinya': 'Tigrinja', 'Tongan': 'Tongai', 'Turkish': 'Török', 'Turkmen': 'Türkmén',
                'Ukrainian': 'Ukrán', 'Urdu': 'Urdu', 'Uyghur': 'Ujgur', 'Uzbek': 'Üzbég',
                'Vietnamese': 'Vietnami', 'Welsh': 'Walesi', 'Wolof': 'Wolof',
                'Xhosa': 'Xhosa', 'Yiddish': 'Jiddis', 'Yoruba': 'Joruba', 'Zulu': 'Zulu'
            },
            cs: {
                'Afrikaans': 'Afrikánština', 'Albanian': 'Albánština', 'Arabic': 'Arabština', 'Armenian': 'Arménština', 'Azerbaijani': 'Ázerbájdžánština',
                'Basque': 'Baskičtina', 'Belarusian': 'Běloruština', 'Bengali': 'Bengálština', 'Bosnian': 'Bosenština', 'Bulgarian': 'Bulharština',
                'Catalan': 'Katalánština', 'Chinese': 'Čínština', 'Croatian': 'Chorvatština', 'Czech': 'Čeština',
                'Danish': 'Dánština', 'Dutch': 'Nizozemština', 'English': 'Angličtina', 'Estonian': 'Estonština',
                'Finnish': 'Finština', 'French': 'Francouzština', 'Georgian': 'Gruzínština', 'German': 'Němčina', 'Greek': 'Řečtina',
                'Hebrew': 'Hebrejština', 'Hindi': 'Hindština', 'Hungarian': 'Maďarština', 'Icelandic': 'Islandština', 'Indonesian': 'Indonéština',
                'Irish': 'Irština', 'Italian': 'Italština', 'Japanese': 'Japonština', 'Korean': 'Korejština', 'Latvian': 'Lotyština',
                'Lithuanian': 'Litevština', 'Macedonian': 'Makedonština', 'Malay': 'Malajština', 'Norwegian': 'Norština',
                'Persian': 'Perština', 'Polish': 'Polština', 'Portuguese': 'Portugalština', 'Romanian': 'Rumunština', 'Russian': 'Ruština',
                'Serbian': 'Srbština', 'Slovak': 'Slovenština', 'Slovenian': 'Slovinština', 'Spanish': 'Španělština', 'Swedish': 'Švédština',
                'Thai': 'Thajština', 'Turkish': 'Turečtina', 'Ukrainian': 'Ukrajinština', 'Vietnamese': 'Vietnamština', 'Welsh': 'Welština'
            },
            de: {
                'Afrikaans': 'Afrikaans', 'Albanian': 'Albanisch', 'Arabic': 'Arabisch', 'Armenian': 'Armenisch', 'Azerbaijani': 'Aserbaidschanisch',
                'Basque': 'Baskisch', 'Belarusian': 'Weißrussisch', 'Bengali': 'Bengalisch', 'Bosnian': 'Bosnisch', 'Bulgarian': 'Bulgarisch',
                'Catalan': 'Katalanisch', 'Chinese': 'Chinesisch', 'Croatian': 'Kroatisch', 'Czech': 'Tschechisch',
                'Danish': 'Dänisch', 'Dutch': 'Niederländisch', 'English': 'Englisch', 'Estonian': 'Estnisch',
                'Finnish': 'Finnisch', 'French': 'Französisch', 'Georgian': 'Georgisch', 'German': 'Deutsch', 'Greek': 'Griechisch',
                'Hebrew': 'Hebräisch', 'Hindi': 'Hindi', 'Hungarian': 'Ungarisch', 'Icelandic': 'Isländisch', 'Indonesian': 'Indonesisch',
                'Irish': 'Irisch', 'Italian': 'Italienisch', 'Japanese': 'Japanisch', 'Korean': 'Koreanisch', 'Latvian': 'Lettisch',
                'Lithuanian': 'Litauisch', 'Macedonian': 'Mazedonisch', 'Malay': 'Malaiisch', 'Norwegian': 'Norwegisch',
                'Persian': 'Persisch', 'Polish': 'Polnisch', 'Portuguese': 'Portugiesisch', 'Romanian': 'Rumänisch', 'Russian': 'Russisch',
                'Serbian': 'Serbisch', 'Slovak': 'Slowakisch', 'Slovenian': 'Slowenisch', 'Spanish': 'Spanisch', 'Swedish': 'Schwedisch',
                'Thai': 'Thailändisch', 'Turkish': 'Türkisch', 'Ukrainian': 'Ukrainisch', 'Vietnamese': 'Vietnamesisch', 'Welsh': 'Walisisch'
            },
            fr: {
                'Afrikaans': 'Afrikaans', 'Albanian': 'Albanais', 'Arabic': 'Arabe', 'Armenian': 'Arménien', 'Azerbaijani': 'Azéri',
                'Basque': 'Basque', 'Belarusian': 'Biélorusse', 'Bengali': 'Bengali', 'Bosnian': 'Bosniaque', 'Bulgarian': 'Bulgare',
                'Catalan': 'Catalan', 'Chinese': 'Chinois', 'Croatian': 'Croate', 'Czech': 'Tchèque',
                'Danish': 'Danois', 'Dutch': 'Néerlandais', 'English': 'Anglais', 'Estonian': 'Estonien',
                'Finnish': 'Finnois', 'French': 'Français', 'Georgian': 'Géorgien', 'German': 'Allemand', 'Greek': 'Grec',
                'Hebrew': 'Hébreu', 'Hindi': 'Hindi', 'Hungarian': 'Hongrois', 'Icelandic': 'Islandais', 'Indonesian': 'Indonésien',
                'Irish': 'Irlandais', 'Italian': 'Italien', 'Japanese': 'Japonais', 'Korean': 'Coréen', 'Latvian': 'Letton',
                'Lithuanian': 'Lituanien', 'Macedonian': 'Macédonien', 'Malay': 'Malais', 'Norwegian': 'Norvégien',
                'Persian': 'Persan', 'Polish': 'Polonais', 'Portuguese': 'Portugais', 'Romanian': 'Roumain', 'Russian': 'Russe',
                'Serbian': 'Serbe', 'Slovak': 'Slovaque', 'Slovenian': 'Slovène', 'Spanish': 'Espagnol', 'Swedish': 'Suédois',
                'Thai': 'Thaï', 'Turkish': 'Turc', 'Ukrainian': 'Ukrainien', 'Vietnamese': 'Vietnamien', 'Welsh': 'Gallois'
            }
        };

        // Get user's preferred language (from settings or browser)
        function getBrowserLanguage() {
            // TODO: Integrate with snappyI18n later
            const userLang = 'hu'; // Default to Hungarian for now
            return worldLanguagesMultilingual.hasOwnProperty(userLang) ? userLang : 'en'; // Default to English if not supported
        }

        // Get localized language list based on browser language
        function getLocalizedLanguages() {
            const browserLang = getBrowserLanguage();
            const languageSet = worldLanguagesMultilingual[browserLang];
            console.log('Browser language detected: ' + navigator.language + ' -> using: ' + browserLang);
            console.log('Language set keys:', Object.keys(languageSet));
            console.log('Using ' + Object.keys(languageSet).length + ' languages');
            return Object.values(languageSet).sort();
        }

        // Convert English language name to localized name
        function translateLanguageName(englishName) {
            const browserLang = getBrowserLanguage();
            const languageSet = worldLanguagesMultilingual[browserLang];
            
            // Find the English key that matches
            for (const [key, value] of Object.entries(worldLanguagesMultilingual.en)) {
                if (value === englishName) {
                    return languageSet[key] || englishName;
                }
            }
            
            // If not found, return original
            return englishName;
        }

        // Convert localized language name back to English (for database storage)
        function translateToEnglish(localizedName) {
            const browserLang = getBrowserLanguage();
            const languageSet = worldLanguagesMultilingual[browserLang];
            
            // Find the localized value that matches
            for (const [key, value] of Object.entries(languageSet)) {
                if (value === localizedName) {
                    return worldLanguagesMultilingual.en[key] || localizedName;
                }
            }
            
            // If not found, return original
            return localizedName;
        }

        //  Központi lokalizációs motor használata (lib/i18n.js-ből)

        //  Törölve - központi translations objektum a lib/i18n.js-ben van
        /*const translations = {
            hu: {
                dashboard: {
                    newSet: "Új szett",
                    settings: "Beállítások", 
                    logout: "Kilépés",
                    userMenu: "Felhasználói menü",
                    loading: "Betöltés...",
                    noSets: "Még nincsenek szettjeid. Készíts egyet!",
                    cardCount: "kártya",
                    masteredCount: "elsajátítva",
                    subtitle: "Kezeld szókártya szettjeidet és tanulj hatékonyan",
                    ownSets: "Saját szett",
                    joinedSets: "Csatlakozott szett", 
                    totalCards: "Összes kártya",
                    mastered: "Elsajátítva",
                    ownSetsTitle: " Saját szettjeim",
                    joinedSetsTitle: "👥 Csatlakozott szettjeim",
                    newSetButton: "Új szett létrehozása"
                },
                sets: {
                    edit: "Szerkesztés",
                    delete: "Törlés", 
                    leave: "Elhagyás",
                    study: "Tanulás"
                },
                newSet: {
                    title: " Új szett létrehozása",
                    name: "Szett neve",
                    description: "Leírás",
                    languageA: "A nyelv neve",
                    languageB: "B nyelv neve",
                    createButton: " Szett létrehozása"
                },
                settings: {
                    title: " Beállítások",
                    interfaceLanguage: " Snappy Cards felületi nyelve",
                    interfaceDescription: "Ez a beállítás határozza meg, hogy milyen nyelven jelenjen meg a Snappy Cards felülete.",
                    browserLanguage: "📱 Böngésző nyelve:",
                    currentSetting: " Jelenlegi beállítás:",
                    detectBrowser: " Böngésző nyelvének automatikus felismerése",
                    close: "Bezárás",
                    languageUpdated: "Megjelenési nyelv frissítve: {lang}",
                    languageDetected: "Böngésző nyelve felismerve: {lang}",
                    languageNotSupported: "A böngésző nyelve ({lang}) nem támogatott. Válassz a listából!"
                }
            },
            en: {
                dashboard: {
                    newSet: "New Set",
                    settings: "Settings",
                    logout: "Logout",
                    userMenu: "User Menu",
                    loading: "Loading...",
                    noSets: "You don't have any sets yet. Create one!",
                    cardCount: "cards",
                    masteredCount: "mastered",
                    subtitle: "Manage your flashcard sets and learn efficiently",
                    ownSets: "Own Sets",
                    joinedSets: "Joined Sets",
                    totalCards: "Total Cards", 
                    mastered: "Mastered",
                    ownSetsTitle: " My Sets",
                    joinedSetsTitle: "👥 Joined Sets",
                    newSetButton: "Create New Set"
                },
                sets: {
                    edit: "Edit",
                    delete: "Delete",
                    leave: "Leave",
                    study: "Study"
                },
                newSet: {
                    title: " Create New Set",
                    name: "Set Name",
                    description: "Description",
                    languageA: "Language A Name",
                    languageB: "Language B Name",
                    createButton: " Create Set"
                },
                settings: {
                    title: " Settings",
                    interfaceLanguage: " Snappy Cards Interface Language",
                    interfaceDescription: "This setting determines the language of the Snappy Cards interface.",
                    browserLanguage: "📱 Browser Language:",
                    currentSetting: " Current Setting:",
                    detectBrowser: " Auto-detect Browser Language",
                    close: "Close",
                    languageUpdated: "Interface language updated: {lang}",
                    languageDetected: "Browser language detected: {lang}",
                    languageNotSupported: "Browser language ({lang}) is not supported. Please choose from the list!"
                }
            },
            th: {
                dashboard: {
                    newSet: "สร้างชุดใหม่",
                    settings: "การตั้งค่า",
                    logout: "ออกจากระบบ",
                    userMenu: "เมนูผู้ใช้",
                    loading: "กำลังโหลด...",
                    noSets: "คุณยังไม่มีชุดการ์ด สร้างชุดแรกของคุณ!",
                    cardCount: "การ์ด",
                    masteredCount: "เรียนรู้แล้ว",
                    subtitle: "จัดการชุดการ์ดแฟลชและเรียนรู้อย่างมีประสิทธิภาพ",
                    ownSets: "ชุดของฉัน",
                    joinedSets: "ชุดที่เข้าร่วม",
                    totalCards: "การ์ดทั้งหมด",
                    mastered: "เรียนรู้แล้ว",
                    ownSetsTitle: " ชุดของฉัน",
                    joinedSetsTitle: "👥 ชุดที่เข้าร่วม",
                    newSetButton: "สร้างชุดใหม่"
                },
                sets: {
                    edit: "แก้ไข",
                    delete: "ลบ",
                    leave: "ออกจากชุด",
                    study: "เรียน"
                },
                newSet: {
                    title: " สร้างชุดใหม่",
                    name: "ชื่อชุด",
                    description: "คำอธิบาย",
                    languageA: "ชื่อภาษา A",
                    languageB: "ชื่อภาษา B",
                    createButton: " สร้างชุด"
                },
                settings: {
                    title: " การตั้งค่า",
                    interfaceLanguage: " ภาษาของ Snappy Cards",
                    interfaceDescription: "การตั้งค่านี้กำหนดภาษาที่ใช้แสดงในอินเทอร์เฟซของ Snappy Cards",
                    browserLanguage: "📱 ภาษาเบราว์เซอร์:",
                    currentSetting: " การตั้งค่าปัจจุบัน:",
                    detectBrowser: " ตรวจจับภาษาเบราว์เซอร์อัตโนมัติ",
                    close: "ปิด",
                    languageUpdated: "อัปเดตภาษาแสดงผลแล้ว: {lang}",
                    languageDetected: "ตรวจพบภาษาเบราว์เซอร์: {lang}",
                    languageNotSupported: "ภาษาเบราว์เซอร์ ({lang}) ไม่รองรับ กรุณาเลือกจากรายการ!"
                }
            }
        */
        //};  Objektum végét bezártam kommentben

        //  Duplikált t() függvény törölve - snappyI18n.t() használata

        //  Duplikált updateAllTexts() törölve - snappyI18n.updateAllTexts() használata
        
        // 🔄 Welcome title frissítése (központi motorral integrálva)
        function updateWelcomeTitle() {
            const welcomeTitle = document.getElementById('welcomeTitle');
            const userName = document.getElementById('userName');
            if (welcomeTitle && userName) {
                const firstName = userName.textContent || 'User';
                const lang = snappyI18n.currentLanguage;
                if (lang === 'en') {
                    welcomeTitle.textContent = 'Welcome to Dashboard, ' + firstName + '!';
                } else if (lang === 'th') {
                    welcomeTitle.textContent = 'ยินดีต้อนรับสู่แดชบอร์ด ' + firstName + '!';
                } else {
                    welcomeTitle.textContent = 'Üdvözöllek a Dashboard-on, ' + firstName + '!';
                }
            }
        }

        // Open settings modal
        function openSettingsModal() {
            const currentLang = snappyI18n?.currentLanguage || 'hu'; // Get current language from i18n
            const container = document.getElementById('modalContainer');
            
            container.innerHTML = `
                <div class="modal-overlay active" onclick="closeModal()">
                    <div class="modal" onclick="event.stopPropagation()" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h2 style="margin: 0; color: #667eea; font-size: 24px; font-weight: 700;">
                                Beállítások
                            </h2>
                            <button onclick="closeModal()" style="position: absolute; top: 20px; right: 20px; background: none; border: none; font-size: 24px; color: #64748b; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(100, 116, 139, 0.1)'" onmouseout="this.style.background='none'">×</button>
                        </div>
                        
                        <!-- Személyes Profil -->
                        <div style="background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.3); padding: 20px; margin-bottom: 16px; border-radius: 12px;">
                            <h3 style="margin: 0 0 16px 0; color: #374151; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                Személyes profil
                            </h3>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                                <div>
                                    <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151; font-size: 14px;">Keresztnév</label>
                                    <input type="text" id="profileFirstName" style="width: 100%; padding: 12px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 8px; font-size: 14px;" placeholder="Adja meg keresztnevét">
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151; font-size: 14px;">Vezetéknév</label>
                                    <input type="text" id="profileLastName" style="width: 100%; padding: 12px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 8px; font-size: 14px;" placeholder="Adja meg vezetéknevét">
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 16px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151; font-size: 14px;">Email cím</label>
                                <input type="email" id="profileEmail" style="width: 100%; padding: 12px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 8px; font-size: 14px;" placeholder="email@example.com" readonly>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                                <div>
                                    <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151; font-size: 14px;">Telefonszám</label>
                                    <input type="tel" id="profilePhone" style="width: 100%; padding: 12px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 8px; font-size: 14px;" placeholder="+36-XX-XXX-XXXX">
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151; font-size: 14px;">Anyanyelv</label>
                                    <select id="profileNativeLanguage" style="width: 100%; padding: 12px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 8px; font-size: 14px;">
                                        <option value="hu">Magyar</option>
                                        <option value="en">English</option>
                                        <option value="de">Deutsch</option>
                                        <option value="es">Español</option>
                                        <option value="fr">Français</option>
                                        <option value="it">Italiano</option>
                                        <option value="th">ไทย</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 16px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151; font-size: 14px;">Mit tanulsz vagy szeretnél tanulni?</label>
                                
                                <!-- Language input with autocomplete -->
                                <div style="position: relative; margin-bottom: 8px;">
                                    <input type="text" id="learningLanguageInput" 
                                           placeholder="Keress nyelvet..."
                                           style="width: 100%; padding: 12px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 8px; font-size: 14px;"
                                           oninput="filterLearningLanguages(this.value)"
                                           onfocus="showLearningLanguageOptions()"
                                           onblur="setTimeout(() => hideLearningLanguageOptions(), 150)">
                                    
                                    <!-- Language options dropdown -->
                                    <div id="learningLanguageOptions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid rgba(102, 126, 234, 0.2); border-top: none; border-radius: 0 0 8px 8px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);">
                                        <!-- Options will be populated dynamically -->
                                    </div>
                                </div>
                                
                                <!-- Selected languages (like tags) - now below input -->
                                <div id="selectedLearningLanguages" style="display: flex; flex-wrap: wrap; gap: 6px; min-height: 20px;">
                                    <!-- Selected language badges will appear here -->
                                </div>
                            </div>
                            
                        </div>
                        
                        <!-- Nyelvi beállítások -->
                        <div style="background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.3); padding: 20px; margin-bottom: 16px; border-radius: 12px;">
                            <h3 style="margin: 0 0 16px 0; color: #374151; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                🌍 Snappy Cards felületi nyelve
                            </h3>
                            <p style="font-size: 14px; color: #64748b; margin-bottom: 16px; line-height: 1.5;">
                                Ez a beállítás határozza meg, hogy milyen nyelven jelenjen meg a Snappy Cards felülete.
                            </p>
                            
                            <div style="background: rgba(102, 126, 234, 0.05); border: 1px solid rgba(102, 126, 234, 0.2); border-radius: 12px; padding: 12px; margin-bottom: 16px; font-size: 13px; color: #64748b;">
                                <strong>Böngésző nyelve:</strong> ${navigator.language} (${navigator.language.slice(0, 2)})<br>
                                <strong>Jelenlegi UI nyelv:</strong> <span id="currentUILanguageDisplay">Magyar</span>
                            </div>
                            
                            <!-- UI Language dropdown selection -->
                            <div style="position: relative; margin-bottom: 16px;">
                                <input type="text" id="uiLanguageInput" 
                                       placeholder="Válassz felületi nyelvet..."
                                       readonly
                                       style="width: 100%; padding: 12px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 8px; font-size: 14px; cursor: pointer; background: white;"
                                       onclick="toggleUILanguageDropdown()">
                                
                                <!-- UI Language options dropdown -->
                                <div id="uiLanguageOptions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid rgba(102, 126, 234, 0.2); border-top: none; border-radius: 0 0 8px 8px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);">
                                    <!-- Options will be populated dynamically -->
                                </div>
                            </div>
                            
                        </div>
                        
                        <div style="display: flex; gap: 16px; justify-content: flex-end;">
                            <button onclick="closeModal()" 
                                    style="padding: 12px 24px; background: #f1f5f9; border: 2px solid #e2e8f0; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; font-size: 16px; color: #64748b; font-weight: 600;"
                                    onmouseover="this.style.background='#e2e8f0'"
                                    onmouseout="this.style.background='#f1f5f9'">
                                Mégse
                            </button>
                            <button onclick="saveAllSettings()" 
                                    style="padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;"
                                    onmouseover="this.style.transform='scale(1.02)'"
                                    onmouseout="this.style.transform='scale(1)'">
                                Mentés
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            container.style.display = 'block';
            
            // Load languages and profile data
            loadAvailableLanguages();
            loadProfileSettings();
            loadUserLearningLanguages();
            loadCurrentUILanguage();
        }

        // Get supported languages from i18n.js or use fallback
        function getSupportedLanguages() {
            return window.snappyI18n?.getSupportedLanguages() || {
                'hu': '🇭🇺 Magyar',
                'en': '🇺🇸 English',
                'th': '🇹🇭 ไทย'
            };
        }

        // Global variables for language management
        let availableLanguages = [];
        let selectedLearningLanguages = [];

        // Load all available languages from database with translations
        async function loadAvailableLanguages() {
            try {
                // Get user's native language (fallback to Hungarian)
                const userLang = currentUser?.user_metadata?.language || 'hu';
                
                const { data: languages, error } = await supabase
                    .from('languages')
                    .select(`
                        id,
                        code,
                        name,
                        flag_emoji,
                        is_active,
                        language_translations!inner(
                            translated_name
                        )
                    `)
                    .eq('is_active', true)
                    .eq('language_translations.display_language_code', userLang);
                
                if (error) {
                    console.error('Error loading languages with translations:', error);
                    // Fallback to original names if translations fail
                    const { data: fallbackLanguages, error: fallbackError } = await supabase
                        .from('languages')
                        .select('*')
                        .eq('is_active', true)
                        .order('name');
                    
                    availableLanguages = fallbackLanguages || [];
                } else {
                    // Process languages with translations
                    availableLanguages = languages.map(lang => ({
                        id: lang.id,
                        code: lang.code,
                        name: lang.name, // Original name as fallback
                        display_name: lang.language_translations?.[0]?.translated_name || lang.name,
                        flag_emoji: lang.flag_emoji,
                        is_active: lang.is_active
                    }));
                    
                    // Sort by translated name
                    availableLanguages.sort((a, b) => a.display_name.localeCompare(b.display_name));
                }
                
                console.log('✅ Available languages loaded:', availableLanguages.length, 'for user lang:', userLang);
            } catch (error) {
                console.error('Error loading available languages:', error);
            }
        }

        // Load user's selected learning languages with translations
        async function loadUserLearningLanguages() {
            try {
                if (!currentUser) return;
                
                // Get user's native language for translations
                const userLang = currentUser?.user_metadata?.language || 'hu';
                
                const { data: userLanguages, error } = await supabase
                    .from('user_learning_languages')
                    .select(`
                        id,
                        languages (
                            id,
                            name,
                            code,
                            flag_emoji,
                            language_translations!left (
                                translated_name
                            )
                        )
                    `)
                    .eq('user_id', currentUser.id)
                    .eq('languages.language_translations.display_language_code', userLang);
                
                if (error) {
                    console.error('Error loading user learning languages:', error);
                    return;
                }
                
                selectedLearningLanguages = userLanguages?.map(ul => {
                    const lang = ul.languages;
                    return {
                        id: lang.id,
                        name: lang.name,
                        code: lang.code,
                        flag_emoji: lang.flag_emoji,
                        display_name: lang.language_translations?.[0]?.translated_name || lang.name
                    };
                }) || [];
                
                renderSelectedLearningLanguages();
                console.log('✅ User learning languages loaded:', selectedLearningLanguages.length, 'for user lang:', userLang);
            } catch (error) {
                console.error('Error loading user learning languages:', error);
            }
        }

        // Render selected learning languages as badges
        function renderSelectedLearningLanguages() {
            const container = document.getElementById('selectedLearningLanguages');
            if (!container) return;
            
            container.innerHTML = selectedLearningLanguages.map(lang => {
                const displayName = lang.display_name || lang.name;
                return `
                    <div style="display: inline-flex; align-items: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 500; gap: 6px;">
                        <span>${lang.flag_emoji}</span>
                        <span>${displayName}</span>
                        <button onclick="removeLearningLanguage('${lang.id}')" 
                                style="background: none; border: none; color: white; cursor: pointer; padding: 0; margin: 0; font-size: 14px; line-height: 1; opacity: 0.8; transition: opacity 0.2s ease;"
                                onmouseover="this.style.opacity='1'"
                                onmouseout="this.style.opacity='0.8'">×</button>
                    </div>
                `;
            }).join('');
        }

        // Filter and show learning language options
        function filterLearningLanguages(searchTerm) {
            const optionsContainer = document.getElementById('learningLanguageOptions');
            if (!optionsContainer) return;
            
            const filtered = availableLanguages.filter(lang => {
                const searchText = searchTerm.toLowerCase();
                const displayName = lang.display_name || lang.name;
                return (
                    displayName.toLowerCase().includes(searchText) ||
                    lang.name.toLowerCase().includes(searchText)
                ) && !selectedLearningLanguages.find(selected => selected.id === lang.id);
            });
            
            optionsContainer.innerHTML = filtered.slice(0, 10).map(lang => {
                const displayName = lang.display_name || lang.name;
                return `
                    <div onclick="addLearningLanguage('${lang.id}', '${displayName}', '${lang.code}', '${lang.flag_emoji}')"
                         style="padding: 12px 16px; cursor: pointer; display: flex; align-items: center; gap: 8px; border-bottom: 1px solid rgba(0,0,0,0.05); font-size: 14px; color: #374151; transition: background 0.2s ease;"
                         onmouseover="this.style.background='rgba(102, 126, 234, 0.1)'"
                         onmouseout="this.style.background='none'">
                        <span>${lang.flag_emoji}</span>
                        <span>${displayName}</span>
                    </div>
                `;
            }).join('');
            
            optionsContainer.style.display = filtered.length > 0 ? 'block' : 'none';
        }

        // Show learning language options
        function showLearningLanguageOptions() {
            const input = document.getElementById('learningLanguageInput');
            filterLearningLanguages(input.value);
        }

        // Hide learning language options
        function hideLearningLanguageOptions() {
            const optionsContainer = document.getElementById('learningLanguageOptions');
            if (optionsContainer) {
                optionsContainer.style.display = 'none';
            }
        }

        // Add learning language
        async function addLearningLanguage(langId, displayName, langCode, flagEmoji) {
            try {
                if (!currentUser) return;
                
                // Check if already selected
                if (selectedLearningLanguages.find(lang => lang.id === langId)) {
                    return;
                }
                
                // Add to database
                const { error } = await supabase
                    .from('user_learning_languages')
                    .insert({
                        user_id: currentUser.id,
                        language_id: langId
                    });
                
                if (error) {
                    console.error('Error adding learning language:', error);
                    return;
                }
                
                // Find the original language name from availableLanguages
                const originalLang = availableLanguages.find(lang => lang.id === langId);
                
                // Add to local array
                selectedLearningLanguages.push({
                    id: langId,
                    name: originalLang?.name || displayName, // Keep original name for database compatibility
                    code: langCode,
                    flag_emoji: flagEmoji,
                    display_name: displayName // Use localized name for display
                });
                
                renderSelectedLearningLanguages();
                
                // Clear input and hide options
                const input = document.getElementById('learningLanguageInput');
                if (input) {
                    input.value = '';
                }
                hideLearningLanguageOptions();
                
                console.log('✅ Learning language added:', displayName);
            } catch (error) {
                console.error('Error adding learning language:', error);
            }
        }

        // Remove learning language
        async function removeLearningLanguage(langId) {
            try {
                if (!currentUser) return;
                
                // Remove from database
                const { error } = await supabase
                    .from('user_learning_languages')
                    .delete()
                    .match({
                        user_id: currentUser.id,
                        language_id: langId
                    });
                
                if (error) {
                    console.error('Error removing learning language:', error);
                    return;
                }
                
                // Remove from local array
                selectedLearningLanguages = selectedLearningLanguages.filter(lang => lang.id !== langId);
                renderSelectedLearningLanguages();
                
                console.log('✅ Learning language removed');
            } catch (error) {
                console.error('Error removing learning language:', error);
            }
        }

        // UI Language Management Functions
        let currentUILanguage = null;

        // Load and display current UI language
        async function loadCurrentUILanguage() {
            try {
                // Get browser language (default) or saved preference
                const browserLang = navigator.language.slice(0, 2);
                const savedLang = localStorage.getItem('snappy_ui_language');
                const currentLang = savedLang || browserLang || 'hu';
                
                console.log('🌐 Browser language:', browserLang);
                console.log('💾 Saved UI language:', savedLang);
                console.log('🎯 Using language:', currentLang);
                
                // Get language name in browser language (or Hungarian if not English)
                const displayLang = browserLang === 'en' ? 'en' : 'hu';
                
                const { data: languages, error } = await supabase
                    .from('languages')
                    .select(`
                        id, code, name, flag_emoji, is_active,
                        language_translations!inner(translated_name)
                    `)
                    .eq('is_active', true)
                    .eq('code', currentLang)
                    .eq('language_translations.display_language_code', displayLang);
                
                if (error) {
                    console.error('Error loading current UI language:', error);
                    return;
                }
                
                let langInfo = null;
                let translatedName = 'Magyar'; // fallback
                
                if (languages && languages.length > 0) {
                    langInfo = languages[0];
                    translatedName = langInfo.language_translations[0]?.translated_name || langInfo.name;
                }
                
                currentUILanguage = {
                    code: currentLang,
                    name: langInfo?.name || 'Hungarian',
                    display_name: translatedName,
                    flag_emoji: langInfo?.flag_emoji || '🇭🇺'
                };
                
                // Set input field value to show selected language (browser language names)
                const input = document.getElementById('uiLanguageInput');
                if (input && currentUILanguage) {
                    input.value = `${currentUILanguage.flag_emoji} ${currentUILanguage.display_name}`;
                }
                
                updateUILanguageDisplay();
                
                console.log(`✅ Current UI language loaded: ${currentUILanguage.display_name} (displayed in ${displayLang})`);
                
            } catch (error) {
                console.error('Error loading current UI language:', error);
                // Fallback
                const input = document.getElementById('uiLanguageInput');
                if (input) {
                    input.value = '🇭🇺 Magyar';
                }
            }
        }

        // Update UI language display in info box
        function updateUILanguageDisplay() {
            const displayElement = document.getElementById('currentUILanguageDisplay');
            if (displayElement && currentUILanguage) {
                displayElement.textContent = `${currentUILanguage.flag_emoji} ${currentUILanguage.display_name}`;
            }
        }

        // Render selected UI language as badge
        function renderSelectedUILanguage() {
            const container = document.getElementById('selectedUILanguage');
            if (!container || !currentUILanguage) return;
            
            container.innerHTML = `
                <div style="display: inline-flex; align-items: center; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 500; gap: 8px;">
                    <span>${currentUILanguage.flag_emoji}</span>
                    <span>${currentUILanguage.display_name}</span>
                    <span style="opacity: 0.7; font-size: 12px;">(UI nyelv)</span>
                </div>
            `;
        }

        // Toggle UI language dropdown
        function toggleUILanguageDropdown() {
            const optionsContainer = document.getElementById('uiLanguageOptions');
            if (!optionsContainer) return;
            
            // If dropdown is visible, hide it
            if (optionsContainer.style.display === 'block') {
                hideUILanguageOptions();
                return;
            }
            
            // Get user's browser language to determine display language for matrix
            const browserLang = navigator.language.slice(0, 2);
            const displayLang = browserLang === 'en' ? 'en' : 'hu'; // Show in English if browser is English
            
            console.log(`🌐 Showing language matrix in: ${displayLang} (based on browser: ${browserLang})`);
            
            // Load all languages from matrix using display language
            loadUILanguageOptions(displayLang);
        }
        
        // Load UI language options from 20x20 matrix
        async function loadUILanguageOptions(displayLang = 'hu') {
            try {
                const { data: languages, error } = await supabase
                    .from('languages')
                    .select(`
                        id, code, name, flag_emoji, is_active,
                        language_translations!inner(translated_name)
                    `)
                    .eq('is_active', true)
                    .eq('language_translations.display_language_code', displayLang);
                
                if (error) {
                    console.error('Error loading UI languages:', error);
                    return;
                }
                
                const optionsContainer = document.getElementById('uiLanguageOptions');
                if (!optionsContainer) return;
                
                optionsContainer.innerHTML = languages.map(lang => {
                    const translatedName = lang.language_translations[0]?.translated_name || lang.name;
                    const isSelected = lang.code === currentUILanguage?.code;
                    
                    return `
                        <div onclick="selectUILanguage('${lang.code}', '${translatedName}', '${lang.flag_emoji}')"
                             style="padding: 12px 16px; cursor: pointer; display: flex; align-items: center; gap: 8px; border-bottom: 1px solid rgba(0,0,0,0.05); font-size: 14px; color: #374151; transition: background 0.2s ease; ${isSelected ? 'background: rgba(16, 185, 129, 0.1); font-weight: 600;' : ''}"
                             onmouseover="this.style.background='rgba(16, 185, 129, 0.15)'"
                             onmouseout="this.style.background='${isSelected ? 'rgba(16, 185, 129, 0.1)' : 'none'}'">
                            <span>${lang.flag_emoji}</span>
                            <span>${translatedName}</span>
                            ${isSelected ? '<span style="color: #10b981; font-size: 12px; margin-left: auto;">✓ Kiválasztva</span>' : ''}
                        </div>
                    `;
                }).join('');
                
                optionsContainer.style.display = 'block';
                console.log(`✅ Loaded ${languages.length} UI language options in ${displayLang}`);
                
            } catch (error) {
                console.error('Error loading UI language options:', error);
            }
        }

        // Show UI language options
        function showUILanguageOptions() {
            const input = document.getElementById('uiLanguageInput');
            filterUILanguages(input.value);
        }

        // Hide UI language options
        function hideUILanguageOptions() {
            const optionsContainer = document.getElementById('uiLanguageOptions');
            if (optionsContainer) {
                optionsContainer.style.display = 'none';
            }
        }

        // Select UI language (save to localStorage, but don't change UI yet)
        function selectUILanguage(langCode, displayName, flagEmoji) {
            try {
                // Update current UI language (but don't save yet - only on modal save)
                currentUILanguage = {
                    code: langCode,
                    name: displayName,
                    display_name: displayName,
                    flag_emoji: flagEmoji
                };
                
                // Update input field to show selected language
                const input = document.getElementById('uiLanguageInput');
                if (input) {
                    input.value = `${flagEmoji} ${displayName}`;
                }
                
                updateUILanguageDisplay();
                hideUILanguageOptions();
                
                // Show success message (but don't actually change UI yet)
                showSuccessMessage(`✅ UI nyelv beállítva: ${displayName} (következő betöltéskor aktiválódik)`);
                
                console.log('✅ UI language saved:', displayName, '(not applied to current UI yet)');
            } catch (error) {
                console.error('Error selecting UI language:', error);
                showErrorMessage('❌ Hiba történt a UI nyelv mentése során');
            }
        }

        // Detect browser language for UI
        async function detectBrowserLanguageForUI() {
            const browserLang = navigator.language.slice(0, 2);
            console.log(`🌐 Detecting browser language: ${browserLang}`);
            
            try {
                // Get browser language name in the current display language
                const displayLang = browserLang === 'en' ? 'en' : 'hu';
                
                const { data: languages, error } = await supabase
                    .from('languages')
                    .select(`
                        id, code, name, flag_emoji, is_active,
                        language_translations!inner(translated_name)
                    `)
                    .eq('is_active', true)
                    .eq('code', browserLang)
                    .eq('language_translations.display_language_code', displayLang);
                
                if (error) {
                    console.error('Error detecting browser language:', error);
                    return;
                }
                
                if (languages && languages.length > 0) {
                    const lang = languages[0];
                    const translatedName = lang.language_translations[0]?.translated_name || lang.name;
                    
                    selectUILanguage(lang.code, translatedName, lang.flag_emoji);
                    showSuccessMessage(`✅ Böngésző nyelve felismerve: ${translatedName}`);
                } else {
                    showErrorMessage(`❌ Böngésző nyelve (${browserLang}) nem támogatott. Válassz a listából!`);
                }
            } catch (error) {
                console.error('Error detecting browser language:', error);
                showErrorMessage('❌ Hiba történt a böngésző nyelvének felismerése során');
            }
        }
        
        // Save all settings (profile and UI language)
        async function saveAllSettings() {
            try {
                // Save profile settings
                await saveProfileSettings();
                
                // Save UI language to localStorage (only when explicitly saved)
                if (currentUILanguage) {
                    localStorage.setItem('snappy_ui_language', currentUILanguage.code);
                    console.log(`💾 UI language saved to localStorage: ${currentUILanguage.code}`);
                }
                
                showSuccessMessage('✅ Minden beállítás sikeresen mentve!');
                setTimeout(() => {
                    closeModal();
                }, 1500);
                
            } catch (error) {
                console.error('Error saving all settings:', error);
                showErrorMessage('❌ Hiba történt a beállítások mentése során');
            }
        }

        // Load profile settings from database
        async function loadProfileSettings() {
            try {
                if (!currentUser) return;
                
                const { data: profile, error } = await supabase
                    .from('user_profiles')
                    .select('first_name, last_name, email, phone, language')
                    .eq('id', currentUser.id)
                    .single();
                
                if (error && error.code !== 'PGRST116') {
                    console.error('Error loading profile:', error);
                    return;
                }
                
                // Fill the form with current data
                if (profile) {
                    document.getElementById('profileFirstName').value = profile.first_name || '';
                    document.getElementById('profileLastName').value = profile.last_name || '';
                    document.getElementById('profileEmail').value = profile.email || currentUser.email || '';
                    document.getElementById('profilePhone').value = profile.phone || '';
                    
                    const nativeSelect = document.getElementById('profileNativeLanguage');
                    if (profile.language && nativeSelect) {
                        nativeSelect.value = profile.language;
                    }
                } else {
                    // New profile, fill with auth data
                    document.getElementById('profileFirstName').value = currentUser.user_metadata?.first_name || '';
                    document.getElementById('profileLastName').value = currentUser.user_metadata?.last_name || '';
                    document.getElementById('profileEmail').value = currentUser.email || '';
                }
                
            } catch (error) {
                console.error('Error loading profile settings:', error);
            }
        }

        // Save profile settings to database
        async function saveProfileSettings() {
            try {
                if (!currentUser) return;
                
                const firstName = document.getElementById('profileFirstName').value.trim();
                const lastName = document.getElementById('profileLastName').value.trim();
                const phone = document.getElementById('profilePhone').value.trim();
                const nativeLanguage = document.getElementById('profileNativeLanguage').value;
                
                // Validate required fields
                if (!firstName) {
                    showErrorMessage('❌ A keresztnév megadása kötelező!');
                    return;
                }
                
                const profileData = {
                    id: currentUser.id,
                    first_name: firstName,
                    last_name: lastName,
                    email: currentUser.email,
                    phone: phone,
                    language: nativeLanguage,
                    user_role: 'student',
                    updated_at: new Date().toISOString()
                };
                
                // Upsert (insert or update) profile
                const { error } = await supabase
                    .from('user_profiles')
                    .upsert(profileData, { onConflict: 'id' });
                
                if (error) {
                    console.error('Error saving profile:', error);
                    showErrorMessage('❌ Hiba a profil mentése során!');
                    return;
                }
                
                // Update the UI with the new first name
                const userName = document.getElementById('userName');
                const userAvatar = document.getElementById('userAvatar');
                if (userName) userName.textContent = firstName;
                if (userAvatar) userAvatar.textContent = firstName.charAt(0).toUpperCase();
                
                // Update welcome title
                updateWelcomeTitle(firstName);
                
                showSuccessMessage('✅ Profil sikeresen mentve!');
                
            } catch (error) {
                console.error('Error saving profile settings:', error);
                showErrorMessage('❌ Hiba a profil mentése során!');
            }
        }

        // Update language setting
        function updateLanguageSetting() {
            const select = document.getElementById('interfaceLanguageSelect');
            const newLang = select.value;
            
            console.log('DEBUG: Updating language to:', newLang);
            
            // Set language via snappyI18n
            if (typeof snappyI18n !== 'undefined') {
                snappyI18n.setLanguage(newLang);
                console.log('DEBUG: snappyI18n.setLanguage() called successfully');
            } else {
                console.error('DEBUG: snappyI18n not available');
            }
            
            // Update welcome title with new language
            if (currentUser) {
                const firstName = currentUser.user_metadata?.first_name || document.getElementById('userName')?.textContent || 'User';
                updateWelcomeTitle(firstName);
            }
            
            // Show confirmation
            showSuccessMessage('✅ Nyelv frissítve: ' + (getSupportedLanguages()[newLang] || newLang) + '!');
        }

        // Detect and set browser language
        function detectBrowserLanguage() {
            const browserLang = navigator.language.slice(0, 2);
            const select = document.getElementById('interfaceLanguageSelect');
            
            console.log('DEBUG: Browser language detected:', browserLang);
            
            if (['hu', 'en', 'th'].includes(browserLang)) {
                select.value = browserLang;
                
                // Set language via snappyI18n
                if (typeof snappyI18n !== 'undefined') {
                    snappyI18n.setLanguage(browserLang);
                    console.log('DEBUG: snappyI18n.setLanguage() called with browser language:', browserLang);
                } else {
                    console.error('DEBUG: snappyI18n not available');
                }
                
                showSuccessMessage(' Böngésző nyelve felismerve: ' + browserLang + '!');
                
                // Update welcome title with new language
                if (currentUser) {
                    const firstName = currentUser.user_metadata?.first_name || 'User';
                    updateWelcomeTitle(firstName);
                }
                
                // Close modal
                setTimeout(() => {
                    closeModal();
                    // No need to reload dashboard data anymore  
                }, 1500);
            } else {
                showErrorMessage(' Böngésző nyelve (' + browserLang + ') nem támogatott!');
            }
        }

        // Open TAG Manager modal
        function openTagManagerModal() {
            const container = document.getElementById('modalContainer');
            
            container.innerHTML = `
                <div class="modal-overlay active" onclick="closeModal()">
                    <div class="modal" onclick="event.stopPropagation()" style="max-width: 600px;">
                        <div class="modal-header">
                            <h2 style="margin: 0; color: #667eea; font-size: 24px; font-weight: 700;">
                                🏷️ TAG Kezelő
                            </h2>
                            <button onclick="closeModal()" style="position: absolute; top: 20px; right: 20px; background: none; border: none; font-size: 24px; color: #64748b; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(100, 116, 139, 0.1)'" onmouseout="this.style.background='none'">×</button>
                        </div>
                        
                        <!-- TAG létrehozása -->
                        <div style="background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.3); padding: 20px; margin-bottom: 16px; border-radius: 12px;">
                            <h3 style="margin: 0 0 16px 0; color: #374151; font-size: 18px; font-weight: 600;">
                                📝 Új TAG létrehozása
                            </h3>
                            <div style="display: flex; gap: 12px; align-items: center;">
                                <input 
                                    type="text" 
                                    id="newTagInput" 
                                    placeholder="TAG neve (pl. nyelvek, tudomány, sport)"
                                    style="flex: 1; padding: 12px 16px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 12px; font-size: 14px; outline: none; transition: all 0.3s ease;"
                                    onfocus="this.style.borderColor='#667eea'"
                                    onblur="this.style.borderColor='rgba(102, 126, 234, 0.2)'"
                                    onkeydown="if(event.key==='Enter') createNewTag()"
                                >
                                <button 
                                    onclick="createNewTag()"
                                    style="padding: 12px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; white-space: nowrap;"
                                    onmouseover="this.style.transform='scale(1.05)'"
                                    onmouseout="this.style.transform='scale(1)'"
                                >
                                    + Létrehozás
                                </button>
                            </div>
                        </div>

                        <!-- Meglévő TAG-ek listája -->
                        <div style="background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.3); padding: 20px; border-radius: 12px;">
                            <h3 style="margin: 0 0 16px 0; color: #374151; font-size: 18px; font-weight: 600;">
                                📋 Meglévő TAG-ek
                            </h3>
                            <div id="tagsList" style="min-height: 200px; max-height: 300px; overflow-y: auto;">
                                <div style="text-align: center; color: #64748b; padding: 40px 0;">
                                    🔄 TAG-ek betöltése...
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Show the modal with higher z-index than list modal
            container.style.display = 'block';
            container.style.zIndex = '20000';
            
            // Load existing tags
            loadExistingTags();
        }

        // Create new tag
        async function createNewTag() {
            const input = document.getElementById('newTagInput');
            const tagName = input.value.trim();
            
            if (!tagName) {
                showErrorMessage('❌ Kérlek add meg a TAG nevét!');
                return;
            }
            
            try {
                // Check if tag already exists
                const { data: existingTags, error: checkError } = await supabase
                    .from('categories')
                    .select('name')
                    .eq('name', tagName)
                    .single();
                
                if (existingTags) {
                    showErrorMessage('❌ Ez a TAG már létezik!');
                    return;
                }
                
                // Create new tag
                const { data, error } = await supabase
                    .from('categories')
                    .insert([{ name: tagName }])
                    .select();
                
                if (error) {
                    console.error('Error creating tag:', error);
                    showErrorMessage('❌ Hiba a TAG létrehozása során!');
                    return;
                }
                
                showSuccessMessage('✅ TAG sikeresen létrehozva: ' + tagName);
                input.value = '';
                loadExistingTags(); // Reload the tags list
                
            } catch (error) {
                console.error('Error creating tag:', error);
                showErrorMessage('❌ Hiba a TAG létrehozása során!');
            }
        }

        // Load existing tags
        async function loadExistingTags() {
            const tagsList = document.getElementById('tagsList');
            
            try {
                const { data: tags, error } = await supabase
                    .from('categories')
                    .select('id, name')
                    .order('name', { ascending: true });
                
                if (error) {
                    console.error('Error loading tags:', error);
                    tagsList.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">❌ Hiba a TAG-ek betöltése során</div>';
                    return;
                }
                
                if (!tags || tags.length === 0) {
                    tagsList.innerHTML = '<div style="text-align: center; color: #64748b; padding: 20px;">📝 Még nincsenek TAG-ek létrehozva</div>';
                    return;
                }
                
                const tagsHTML = tags.map(tag => `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: rgba(102, 126, 234, 0.05); border: 1px solid rgba(102, 126, 234, 0.1); border-radius: 10px; margin-bottom: 8px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(102, 126, 234, 0.1)'" onmouseout="this.style.background='rgba(102, 126, 234, 0.05)'">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="color: #374151; font-weight: 500;">${tag.name}</span>
                        </div>
                        <button 
                            onclick="deleteTag('${tag.id}', '${tag.name}')"
                            style="background: #ef4444; color: white; border: none; padding: 6px 10px; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;"
                            onmouseover="this.style.background='#dc2626'"
                            onmouseout="this.style.background='#ef4444'"
                            title="TAG törlése"
                        >
                            <i data-lucide="trash" style="width: 10px; height: 10px; margin-right: 4px;"></i>
                            Törlés
                        </button>
                    </div>
                `).join('');
                
                tagsList.innerHTML = tagsHTML;
                
            } catch (error) {
                console.error('Error loading tags:', error);
                tagsList.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">❌ Hiba a TAG-ek betöltése során</div>';
            }
        }

        // Delete tag
        async function deleteTag(tagId, tagName) {
            if (!confirm(`Biztosan törölni szeretnéd ezt a TAG-et: "${tagName}"?\\n\\nFigyelem: Ez a művelet nem vonható vissza!`)) {
                return;
            }
            
            try {
                const { error } = await supabase
                    .from('categories')
                    .delete()
                    .eq('id', tagId);
                
                if (error) {
                    console.error('Error deleting tag:', error);
                    showErrorMessage('❌ Hiba a TAG törlése során!');
                    return;
                }
                
                showSuccessMessage('✅ TAG sikeresen törölve: ' + tagName);
                loadExistingTags(); // Reload the tags list
                
            } catch (error) {
                console.error('Error deleting tag:', error);
                showErrorMessage('❌ Hiba a TAG törlése során!');
            }
        }

        // User menu toggle functions
        function toggleUserMenu() {
            const menu = document.getElementById('userDropdownMenu');
            const isVisible = menu.style.display !== 'none';
            
            if (isVisible) {
                closeUserMenu();
            } else {
                // Close any other open menus first
                closeAllDropdowns();
                
                menu.style.display = 'block';
                
                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', handleClickOutsideUserMenu);
                }, 10);
            }
        }

        function closeUserMenu() {
            const menu = document.getElementById('userDropdownMenu');
            menu.style.display = 'none';
            document.removeEventListener('click', handleClickOutsideUserMenu);
        }

        function handleClickOutsideUserMenu(event) {
            const menu = document.getElementById('userDropdownMenu');
            const avatar = document.getElementById('userAvatar');
            
            if (!menu.contains(event.target) && !avatar.contains(event.target)) {
                closeUserMenu();
            }
        }

        // Get default languages based on browser language
        function getDefaultLanguages() {
            const browserLang = getBrowserLanguage();
            const languageSet = worldLanguagesMultilingual[browserLang];
            
            switch(browserLang) {
                case 'hu':
                    return { a: languageSet['Hungarian'], b: languageSet['English'] }; // Magyar + Angol
                case 'cs':
                    return { a: languageSet['Czech'], b: languageSet['English'] }; // Čeština + Angličtina
                case 'de':
                    return { a: languageSet['German'], b: languageSet['English'] }; // Deutsch + Englisch
                case 'fr':
                    return { a: languageSet['French'], b: languageSet['English'] }; // Français + Anglais
                default:
                    return { a: languageSet['English'], b: languageSet['Hungarian'] }; // English + Hungarian
            }
        }

        // Create searchable language dropdown
        function createLanguageDropdown(id, currentValue, placeholder, isSecondary = false) {
            const borderColor = isSecondary ? 'rgba(126, 58, 237, 0.2)' : 'rgba(102, 126, 234, 0.2)';
            const focusColor = isSecondary ? '#7c3aed' : '#667eea';
            const focusShadow = isSecondary ? 'rgba(126, 58, 237, 0.1)' : 'rgba(102, 126, 234, 0.1)';
            
            return '<div class="language-dropdown" style="position: relative; width: 100%;">' +
                    '<input type="text" ' +
                           'id="' + id + '" ' +
                           'value="' + (currentValue || '') + '"' +
                           'placeholder="' + placeholder + '" ' +
                           'autocomplete="off"' +
                           'style="width: 100%; padding: 16px 20px; border: 2px solid ' + borderColor + '; border-radius: 16px; font-size: 16px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(8px); transition: all 0.3s ease; outline: none; color: #000000;" ' +
                           'onfocus="showLanguageOptions(\'' + id + '\'); this.style.borderColor=\'' + focusColor + '\'; this.style.boxShadow=\'0 0 0 3px ' + focusShadow + '\'"' +
                           'onblur="setTimeout(() => hideLanguageOptions(\'' + id + '\'), 150); this.style.borderColor=\'' + borderColor + '\'; this.style.boxShadow=\'none\'"' +
                           'oninput="filterLanguageOptions(\'' + id + '\', this.value)">' +
                    '<div id="' + id + '-options" class="language-options" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid ' + borderColor + '; border-top: none; border-radius: 0 0 16px 16px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);">' +
                    '</div>' +
                '</div>';
        }

        // Show language options
        function showLanguageOptions(inputId) {
            const optionsDiv = document.getElementById(inputId + '-options');
            if (optionsDiv) {
                optionsDiv.style.display = 'block';
                filterLanguageOptions(inputId, document.getElementById(inputId).value);
            }
        }

        // Hide language options
        function hideLanguageOptions(inputId) {
            const optionsDiv = document.getElementById(inputId + '-options');
            if (optionsDiv) {
                optionsDiv.style.display = 'none';
            }
        }

        // Filter and display language options
        function filterLanguageOptions(inputId, searchTerm) {
            const optionsDiv = document.getElementById(inputId + '-options');
            if (!optionsDiv) return;

            const localizedLanguages = getLocalizedLanguages();
            const filtered = localizedLanguages.filter(lang => 
                lang.toLowerCase().includes(searchTerm.toLowerCase())
            );

            optionsDiv.innerHTML = filtered.slice(0, 20).map(lang => 
                `<div class="language-option" 
                      style="padding: 12px 20px; cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05); font-size: 16px; color: #374151; transition: background 0.2s ease;"
                      onmouseover="this.style.background='rgba(102, 126, 234, 0.1)'"
                      onmouseout="this.style.background='transparent'"
                      onclick="selectLanguage('${inputId}', '${lang}')">
                    ${lang}
                </div>`
            ).join('');

            if (filtered.length === 0) {
                optionsDiv.innerHTML = '<div style="padding: 12px 20px; color: #64748b; font-style: italic;">Nincs találat</div>';
            }
        }

        // Select language from dropdown
        function selectLanguage(inputId, language) {
            const input = document.getElementById(inputId);
            if (input) {
                input.value = language;
                hideLanguageOptions(inputId);
            }
        }

        // Show edit set modal
        function showEditSetModal(set) {
            console.log('DEBUG - showEditSetModal: Received set data:', set);
            console.log('DEBUG - showEditSetModal: set.title =', set.title);
            console.log('DEBUG - showEditSetModal: set.description =', set.description);
            console.log('DEBUG - showEditSetModal: set.language_a =', set.language_a);
            console.log('DEBUG - showEditSetModal: set.language_b =', set.language_b);
            console.log('DEBUG - showEditSetModal: set.flashcard_set_categories =', set.flashcard_set_categories);
            
            const container = document.getElementById('modalContainer');
            
            container.innerHTML = `
                <div class="modal-overlay active" onclick="closeModal()">
                    <div class="modal" onclick="event.stopPropagation()" style="max-width: 600px;">
                        <div class="modal-header">
                            <h2 style="margin: 0; color: #667eea; font-size: 24px; font-weight: 700;">
                                 Szett szerkesztése
                            </h2>
                            <button onclick="closeModal()" style="position: absolute; top: 20px; right: 20px; background: none; border: none; font-size: 24px; color: #64748b; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(100, 116, 139, 0.1)'" onmouseout="this.style.background='none'">×</button>
                        </div>
                        
                        <form id="editSetForm" style="max-width: none; padding-bottom: 20px;">
                            <div style="background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.3); padding: 20px; margin-bottom: 16px;">
                                
                                <!-- Set Name -->
                                <div style="margin-bottom: 16px;">
                                    <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #374151; font-size: 14px;">
                                        Szett neve *
                                    </label>
                                    <input type="text" 
                                           id="editSetName" 
                                           value="${set.title || ''}"
                                           placeholder="Szett neve..." 
                                           style="width: 100%; padding: 16px 20px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 16px; font-size: 16px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(8px); transition: all 0.3s ease; outline: none; color: #000000;" 
                                           onfocus="this.style.borderColor='#667eea'; this.style.boxShadow='0 0 0 3px rgba(102, 126, 234, 0.1)'"
                                           onblur="this.style.borderColor='rgba(102, 126, 234, 0.2)'; this.style.boxShadow='none'">
                                </div>
                                
                                <!-- Description -->
                                <div style="margin-bottom: 16px;">
                                    <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #374151; font-size: 14px;">
                                        Leírás
                                    </label>
                                    <textarea id="editSetDescription" 
                                              placeholder="Opcionális leírás..."
                                              style="width: 100%; min-height: 80px; padding: 16px 20px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 16px; font-size: 16px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(8px); transition: all 0.3s ease; outline: none; resize: vertical; color: #000000; font-family: inherit;"
                                              onfocus="this.style.borderColor='#667eea'; this.style.boxShadow='0 0 0 3px rgba(102, 126, 234, 0.1)'"
                                              onblur="this.style.borderColor='rgba(102, 126, 234, 0.2)'; this.style.boxShadow='none'">${set.description || ''}</textarea>
                                </div>
                                
                                <!-- Languages Row -->
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 16px;">
                                    <div>
                                        <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #374151; font-size: 14px;">
                                            A nyelv neve * 
                                        </label>
                                        ${createLanguageDropdown('editLanguageA', translateLanguageName(set.language_a), 'Keress nyelveket...', false)}
                                    </div>
                                    <div>
                                        <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #374151; font-size: 14px;">
                                            B nyelv neve * 
                                        </label>
                                        ${createLanguageDropdown('editLanguageB', translateLanguageName(set.language_b), 'Keress nyelveket...', true)}
                                    </div>
                                </div>
                                
                                <!-- Tag -->
                                <div style="margin-bottom: 16px;">
                                    <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #374151; font-size: 14px;">
                                        Tag 
                                    </label>
                                    <div style="position: relative;">
                                        <input type="text" 
                                               id="editSetTag"
                                               class="modern-input" 
                                               style="width: 100%; padding: 16px 20px; border: 2px solid rgba(102, 126, 234, 0.2); border-radius: 16px; font-size: 16px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(8px); transition: all 0.3s ease; outline: none; color: #000000;"
                                               placeholder="pl. nyelvek, tudomány, sport" 
                                               value=""
                                               oninput="handleEditTagInput(this.value)"
                                               onkeydown="handleEditTagKeydown(event)"
                                               onfocus="this.style.borderColor='#667eea'; this.style.boxShadow='0 0 0 3px rgba(102, 126, 234, 0.1)'"
                                               onblur="this.style.borderColor='rgba(102, 126, 234, 0.2)'; this.style.boxShadow='none'">
                                        <div id="editTagSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #e2e8f0; max-height: 150px; overflow-y: auto; z-index: 1000; display: none; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                                    </div>
                                    <!-- Tag lista megjelenítés -->
                                    <div id="editSelectedTags" style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px;"></div>
                                </div>
                                
                            </div>
                            
                            <!-- Action Buttons - Bottom Fixed -->
                            <div style="position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px); border-top: 1px solid rgba(255, 255, 255, 0.2); padding: 20px; display: grid; grid-template-columns: 1fr 1fr; gap: 16px; z-index: 10000; max-width: 600px; width: 95%; border-radius: 24px 24px 0 0;">
                                <button type="submit" 
                                        style="padding: 16px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 16px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 12px 40px rgba(102, 126, 234, 0.4)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 8px 32px rgba(102, 126, 234, 0.3)'">
                                    Mentés
                                </button>
                                <button type="button" 
                                        onclick="closeModal()" 
                                        style="padding: 16px 24px; background: rgba(156, 163, 175, 0.1); color: #6b7280; border: 2px solid rgba(156, 163, 175, 0.2); border-radius: 16px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;"
                                        onmouseover="this.style.background='rgba(156, 163, 175, 0.15)'"
                                        onmouseout="this.style.background='rgba(156, 163, 175, 0.1)'">
                                    Mégse
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            
            container.style.display = 'block';
            
            // Debug: Check if form elements got the values
            setTimeout(() => {
                const nameInput = document.getElementById('editSetName');
                const descInput = document.getElementById('editSetDescription');
                const tagInput = document.getElementById('editSetTag');
                const langAInput = document.getElementById('editLanguageA');
                const langBInput = document.getElementById('editLanguageB');
                
                console.log('DEBUG - Form elements after modal creation:');
                console.log('  nameInput.value =', nameInput?.value);
                console.log('  descInput.value =', descInput?.value);
                console.log('  tagInput.value =', tagInput?.value, '(should be empty - tags loaded separately)');
                console.log('  langAInput.value =', langAInput?.value);
                console.log('  langBInput.value =', langBInput?.value);
                console.log('  editSelectedTagsList =', editSelectedTagsList);
            }, 100);
            
            // Handle form submission
            document.getElementById('editSetForm').onsubmit = function(e) {
                e.preventDefault();
                saveEditedSet(set.id);
            };
            
            // Clear previous tags
            editSelectedTagsList = [];
            const selectedTagsContainer = document.getElementById('editSelectedTags');
            selectedTagsContainer.innerHTML = '';
            
            // Extract and set current categories
            const categories = set.flashcard_set_categories?.map(fsc => fsc.categories?.name).filter(Boolean) || [];
            if (categories.length > 0) {
                console.log('DEBUG - showEditSetModal: Setting current categories:', categories);
                categories.forEach(categoryName => {
                    if (categoryName) {
                        addEditTag(categoryName);
                    }
                });
            } else {
                console.log('DEBUG - showEditSetModal: No current categories to set');
            }
        }

        // Handle tag input with autocomplete for Create modal
        async function handleCreateTagInput(value) {
            const suggestions = document.getElementById('createTagSuggestions');
            
            if (!value.trim()) {
                suggestions.style.display = 'none';
                return;
            }
            
            // Extract the current tag being typed (after the last comma)
            const tags = value.split(',');
            const currentTag = tags[tags.length - 1].trim().toLowerCase();
            
            if (currentTag.length < 1) {
                suggestions.style.display = 'none';
                return;
            }
            
            try {
                // Search categories from database with better Unicode support
                const { data: categories, error } = await supabase
                    .from('categories')
                    .select('name')
                    .ilike('name', '%' + currentTag + '%')
                    .order('name')
                    .limit(8);
                
                if (error) {
                    console.error('Error loading categories:', error);
                    suggestions.style.display = 'none';
                    return;
                }
                
                const matches = categories.map(cat => cat.name);
                const exactMatch = matches.find(name => name.toLowerCase() === currentTag);
                
                let suggestionsHTML = '';
                
                // Show matching categories
                if (matches.length > 0) {
                    suggestionsHTML += matches.map(tag => 
                        `<div class="tag-suggestion" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f5f9; transition: all 0.2s ease; display: flex; align-items: center; justify-content: space-between;" 
                             onmouseover="this.style.background='#f8fafc'" 
                             onmouseout="this.style.background='white'"
                             onclick="selectCreateTag('${tag}')">
                            <span>${tag}</span>
                            <span style="color: #64748b; font-size: 12px;">meglévő</span>
                        </div>`
                    ).join('');
                }
                
                // Add "Create new" option if not exact match
                if (!exactMatch && currentTag.length >= 2) {
                    suggestionsHTML += `
                        <div class="tag-suggestion" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f5f9; transition: all 0.2s ease; display: flex; align-items: center; justify-content: space-between; background: rgba(102, 126, 234, 0.05);" 
                             onmouseover="this.style.background='rgba(102, 126, 234, 0.1)'" 
                             onmouseout="this.style.background='rgba(102, 126, 234, 0.05)'"
                             onclick="selectCreateTag('${value.trim()}')">
                            <span><strong>+ "${value.trim()}"</strong></span>
                            <span style="color: #667eea; font-size: 12px; font-weight: 600;">új létrehozása</span>
                        </div>`;
                }
                
                if (suggestionsHTML) {
                    suggestions.innerHTML = suggestionsHTML;
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
            } catch (error) {
                console.error('Error in handleCreateTagInput:', error);
                suggestions.style.display = 'none';
            }
        }

        // Select tag for Create modal
        function selectCreateTag(tag) {
            addCreateTag(tag);
            // addCreateTag already clears input and hides suggestions
        }

        // Handle keydown for Create tag input
        function handleCreateTagKeydown(event) {
            if (event.key === 'Escape') {
                document.getElementById('createTagSuggestions').style.display = 'none';
            }
            
            // Handle comma separation - when comma is pressed, add current input as tag
            if (event.key === ',' || event.key === 'Enter') {
                event.preventDefault();
                
                const input = document.getElementById('setTag');
                const suggestions = document.getElementById('createTagSuggestions');
                
                // If there are suggestions visible and Enter was pressed, select the first one
                if (event.key === 'Enter' && suggestions.style.display !== 'none') {
                    const firstSuggestion = suggestions.querySelector('.tag-suggestion');
                    if (firstSuggestion) {
                        firstSuggestion.click();
                        return false;
                    }
                }
                
                // Get current input value and clean it up
                const currentValue = input.value.replace(/,$/, '').trim(); // Remove trailing comma if any
                
                if (currentValue) {
                    addCreateTag(currentValue);
                }
                
                return false;
            }
        }

        // Selected tags array for Create modal
        let createSelectedTagsList = [];
        
        // Selected tags array for filter
        let selectedTagFiltersList = [];

        // Handle tag filter input with autocomplete
        async function handleTagFilterInput(value) {
            const suggestions = document.getElementById('tagFilterSuggestions');
            const clearBtn = document.querySelector('.tag-filter-clear');
            
            // Show/hide clear button based on input value
            if (clearBtn) {
                clearBtn.style.display = value.trim() ? 'block' : 'none';
            }
            
            // Update clear all filters button state
            updateClearAllFiltersBtn();
            
            if (!value.trim()) {
                suggestions.style.display = 'none';
                return;
            }
            
            const currentTag = value.trim().toLowerCase();
            
            if (currentTag.length < 1) {
                suggestions.style.display = 'none';
                return;
            }
            
            try {
                // Search categories from database
                const { data: categories, error } = await supabase
                    .from('categories')
                    .select('name')
                    .ilike('name', '%' + currentTag + '%')
                    .order('name')
                    .limit(8);
                
                if (error) {
                    console.error('Error loading categories:', error);
                    suggestions.style.display = 'none';
                    return;
                }
                
                const matches = categories.map(cat => cat.name)
                    .filter(name => !selectedTagFiltersList.includes(name)); // Exclude already selected tags
                
                let suggestionsHTML = '';
                
                // Show matching categories that aren't already selected
                if (matches.length > 0) {
                    suggestionsHTML += matches.map(tag => 
                        `<div class="tag-suggestion" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f5f9; transition: all 0.2s ease; display: flex; align-items: center; justify-content: space-between;" 
                             onmouseover="this.style.background='#f8fafc'" 
                             onmouseout="this.style.background='white'"
                             onclick="selectTagFilter('${tag}')">
                            <span>${tag}</span>
                            <span style="color: #64748b; font-size: 12px;">szűrő</span>
                        </div>`
                    ).join('');
                }
                
                if (suggestionsHTML) {
                    suggestions.innerHTML = suggestionsHTML;
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
            } catch (error) {
                console.error('Error in handleTagFilterInput:', error);
                suggestions.style.display = 'none';
            }
        }

        // Handle keydown for tag filter input
        function handleTagFilterKeydown(event) {
            if (event.key === 'Escape') {
                document.getElementById('tagFilterSuggestions').style.display = 'none';
            }
            
            // Prevent form submission on Enter key
            if (event.key === 'Enter') {
                event.preventDefault();
                
                const suggestions = document.getElementById('tagFilterSuggestions');
                const input = document.getElementById('searchTagFilter');
                
                // If there are suggestions visible, select the first one
                if (suggestions.style.display !== 'none') {
                    const firstSuggestion = suggestions.querySelector('.tag-suggestion');
                    if (firstSuggestion) {
                        firstSuggestion.click();
                        return false;
                    }
                }
                
                return false;
            }
        }

        // Select tag for filter
        function selectTagFilter(tag) {
            addTagFilter(tag);
        }

        // Add tag to filter
        function addTagFilter(tagName) {
            console.log('DEBUG - addTagFilter:', tagName);
            
            const input = document.getElementById('searchTagFilter');
            const selectedTagsContainer = document.getElementById('selectedTagFilters');
            
            // Check if tag already exists
            if (selectedTagFiltersList.includes(tagName)) {
                console.log('DEBUG - Tag már kiválasztva szűrőnek:', tagName);
                if (input) input.value = '';
                document.getElementById('tagFilterSuggestions').style.display = 'none';
                return;
            }
            
            // Add to array
            selectedTagFiltersList.push(tagName);
            
            // Create tag element
            const tagElement = document.createElement('div');
            tagElement.style.cssText = 'display: inline-flex; align-items: center; background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: 500;';
            tagElement.innerHTML = `
                <span>${tagName}</span>
                <button type="button" onclick="removeTagFilter('${tagName}')" style="margin-left: 4px; background: none; border: none; color: white; cursor: pointer; font-size: 14px; padding: 0; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'" title="Tag eltávolítása">×</button>
            `;
            
            // Add to container
            selectedTagsContainer.appendChild(tagElement);
            
            // Show/hide second row and clear all button
            const selectedTagsRow = document.getElementById('selectedTagsRow');
            const clearAllBtn = document.getElementById('clearAllTagsBtn');
            const mainSearchRow = document.getElementById('mainSearchRow');
            
            if (selectedTagFiltersList.length > 0) {
                if (selectedTagsRow) selectedTagsRow.style.display = 'flex';
                if (clearAllBtn) clearAllBtn.style.display = 'block';
                if (mainSearchRow) mainSearchRow.style.marginBottom = '8px';
            } else {
                if (selectedTagsRow) selectedTagsRow.style.display = 'none';
                if (clearAllBtn) clearAllBtn.style.display = 'none';
                if (mainSearchRow) mainSearchRow.style.marginBottom = '0';
            }
            
            // Clear input and hide suggestions
            if (input) {
                input.oninput = null; // Temporarily disable event handler
                input.value = '';
                // Re-enable after a brief delay
                setTimeout(() => {
                    input.oninput = function() { handleTagFilterInput(this.value); };
                }, 10);
            }
            document.getElementById('tagFilterSuggestions').style.display = 'none';
            
            // Re-run search with new tag filter
            const searchValue = document.getElementById('ownSetsSearch').value;
            filterOwnSets(searchValue);
        }

        // Remove tag from filter
        function removeTagFilter(tagName) {
            const index = selectedTagFiltersList.indexOf(tagName);
            if (index > -1) {
                selectedTagFiltersList.splice(index, 1);
            }
            
            // Remove tag element from DOM
            const selectedTagsContainer = document.getElementById('selectedTagFilters');
            const tagElements = selectedTagsContainer.children;
            for (let i = 0; i < tagElements.length; i++) {
                if (tagElements[i].textContent.includes(tagName)) {
                    tagElements[i].remove();
                    break;
                }
            }
            
            // Show/hide second row and clear all button
            const selectedTagsRow = document.getElementById('selectedTagsRow');
            const clearAllBtn = document.getElementById('clearAllTagsBtn');
            const mainSearchRow = document.getElementById('mainSearchRow');
            
            if (selectedTagFiltersList.length > 0) {
                if (selectedTagsRow) selectedTagsRow.style.display = 'flex';
                if (clearAllBtn) clearAllBtn.style.display = 'block';
                if (mainSearchRow) mainSearchRow.style.marginBottom = '8px';
            } else {
                if (selectedTagsRow) selectedTagsRow.style.display = 'none';
                if (clearAllBtn) clearAllBtn.style.display = 'none';
                if (mainSearchRow) mainSearchRow.style.marginBottom = '0';
            }
            
            // Re-run search without this tag
            const searchValue = document.getElementById('ownSetsSearch').value;
            filterOwnSets(searchValue);
        }

        // Clear all tag filters
        function clearTagFilters() {
            selectedTagFiltersList = [];
            const selectedTagsContainer = document.getElementById('selectedTagFilters');
            if (selectedTagsContainer) {
                selectedTagsContainer.innerHTML = '';
            }
            
            // Hide second row and clear all button
            const selectedTagsRow = document.getElementById('selectedTagsRow');
            const clearAllBtn = document.getElementById('clearAllTagsBtn');
            const mainSearchRow = document.getElementById('mainSearchRow');
            if (selectedTagsRow) selectedTagsRow.style.display = 'none';
            if (clearAllBtn) clearAllBtn.style.display = 'none';
            if (mainSearchRow) mainSearchRow.style.marginBottom = '0';
            
            // Update clear all filters button state
            updateClearAllFiltersBtn();
            
            // Re-run search without tag filters
            const searchValue = document.getElementById('ownSetsSearch').value;
            filterOwnSets(searchValue);
        }

        // Clear single tag filter input
        function clearTagFilter() {
            const tagFilterInput = document.getElementById('searchTagFilter');
            const clearBtn = document.querySelector('.tag-filter-clear');
            const suggestions = document.getElementById('tagFilterSuggestions');
            
            if (tagFilterInput) {
                tagFilterInput.value = '';
            }
            if (clearBtn) {
                clearBtn.style.display = 'none';
            }
            if (suggestions) {
                suggestions.style.display = 'none';
            }
            
            // Update clear all filters button state
            updateClearAllFiltersBtn();
            
            // Focus back to input after clearing
            if (tagFilterInput) {
                tagFilterInput.focus();
            }
        }

        // Clear all filters (search, dropdown, tags)
        function clearAllFilters() {
            // Clear search input
            const searchInput = document.getElementById('ownSetsSearch');
            const searchClearBtn = searchInput?.parentElement.querySelector('.search-clear');
            if (searchInput) {
                searchInput.value = '';
            }
            if (searchClearBtn) {
                searchClearBtn.style.display = 'none';
            }
            
            // Reset dropdown to default
            const dropdown = document.getElementById('searchModeSelect');
            if (dropdown) {
                dropdown.value = 'all';
            }
            
            // Clear tag filter input
            const tagFilterInput = document.getElementById('searchTagFilter');
            const tagClearBtn = document.querySelector('.tag-filter-clear');
            const suggestions = document.getElementById('tagFilterSuggestions');
            if (tagFilterInput) {
                tagFilterInput.value = '';
            }
            if (tagClearBtn) {
                tagClearBtn.style.display = 'none';
            }
            if (suggestions) {
                suggestions.style.display = 'none';
            }
            
            // Clear selected tags
            selectedTagFiltersList = [];
            const selectedTagsContainer = document.getElementById('selectedTagFilters');
            if (selectedTagsContainer) {
                selectedTagsContainer.innerHTML = '';
            }
            
            // Hide second row and clear all tags button
            const selectedTagsRow = document.getElementById('selectedTagsRow');
            const clearAllTagsBtn = document.getElementById('clearAllTagsBtn');
            const mainSearchRow = document.getElementById('mainSearchRow');
            if (selectedTagsRow) selectedTagsRow.style.display = 'none';
            if (clearAllTagsBtn) clearAllTagsBtn.style.display = 'none';
            if (mainSearchRow) mainSearchRow.style.marginBottom = '0';
            
            // Update clear all filters button state
            updateClearAllFiltersBtn();
            
            // Reload all sets without any filters
            loadOwnSets();
        }

        // Update clear all filters button appearance
        function updateClearAllFiltersBtn(isHover = false) {
            const btn = document.getElementById('clearAllFiltersBtn');
            if (!btn) return;
            
            const hasActiveFilters = checkFiltersState();
            
            if (hasActiveFilters) {
                // Active state - colorful
                btn.style.color = isHover ? '#dc2626' : '#ef4444';
                btn.style.borderColor = isHover ? '#dc2626' : '#ef4444';
                btn.style.background = isHover ? 'rgba(239, 68, 68, 0.05)' : 'white';
            } else {
                // Inactive state - gray
                btn.style.color = isHover ? '#6b7280' : '#9ca3af';
                btn.style.borderColor = '#d1d5db';
                btn.style.background = 'white';
            }
        }

        // Check if any filters are active
        function checkFiltersState() {
            const searchInput = document.getElementById('ownSetsSearch');
            const dropdown = document.getElementById('searchModeSelect');
            const tagFilterInput = document.getElementById('searchTagFilter');
            
            // Check search input
            if (searchInput && searchInput.value.trim()) {
                return true;
            }
            
            // Check dropdown (not default)
            if (dropdown && dropdown.value !== 'all') {
                return true;
            }
            
            // Check tag filter input
            if (tagFilterInput && tagFilterInput.value.trim()) {
                return true;
            }
            
            // Check selected tags
            if (selectedTagFiltersList && selectedTagFiltersList.length > 0) {
                return true;
            }
            
            return false;
        }

        // Add tag to Create modal
        function addCreateTag(tagName) {
            console.log('DEBUG - addCreateTag:', tagName);
            
            const input = document.getElementById('setTag');
            const selectedTagsContainer = document.getElementById('createSelectedTags');
            
            // Check if tag already exists
            if (createSelectedTagsList.includes(tagName)) {
                console.log('DEBUG - Tag már létezik:', tagName);
                input.value = '';
                document.getElementById('createTagSuggestions').style.display = 'none';
                return;
            }
            
            // Add to array
            createSelectedTagsList.push(tagName);
            
            // Create tag element with new CSS classes
            const tagElement = document.createElement('div');
            tagElement.className = 'selected-tag';
            tagElement.innerHTML = `
                <span>${tagName}</span>
                <button type="button" class="tag-remove" onclick="removeCreateTag('${tagName}')" title="Tag eltávolítása">×</button>
            `;
            
            // Add to container
            selectedTagsContainer.appendChild(tagElement);
            
            // Clear input and hide suggestions (avoid triggering oninput)
            if (input) {
                input.oninput = null; // Temporarily disable event handler
                input.value = '';
                // Re-enable after a brief delay
                setTimeout(() => {
                    input.oninput = function() { handleCreateTagInput(this.value); };
                }, 10);
            }
            document.getElementById('createTagSuggestions').style.display = 'none';
        }

        // Remove tag from Create modal
        function removeCreateTag(tagName) {
            const index = createSelectedTagsList.indexOf(tagName);
            if (index > -1) {
                createSelectedTagsList.splice(index, 1);
            }
            
            // Remove tag element from DOM
            const selectedTagsContainer = document.getElementById('createSelectedTags');
            const tagElements = selectedTagsContainer.children;
            for (let i = 0; i < tagElements.length; i++) {
                if (tagElements[i].textContent.includes(tagName)) {
                    tagElements[i].remove();
                    break;
                }
            }
        }

        // Handle tag input with autocomplete for Edit modal
        async function handleEditTagInput(value) {
            const suggestions = document.getElementById('editTagSuggestions');
            
            if (!value.trim()) {
                suggestions.style.display = 'none';
                return;
            }
            
            const currentTag = value.trim().toLowerCase();
            
            if (currentTag.length < 1) {
                suggestions.style.display = 'none';
                return;
            }
            
            try {
                // Search categories from database with better Unicode support
                const { data: categories, error } = await supabase
                    .from('categories')
                    .select('name')
                    .ilike('name', '%' + currentTag + '%')
                    .order('name')
                    .limit(8);
                
                if (error) {
                    console.error('Error loading categories:', error);
                    suggestions.style.display = 'none';
                    return;
                }
                
                const matches = categories.map(cat => cat.name);
                const exactMatch = matches.find(name => name.toLowerCase() === currentTag);
                
                let suggestionsHTML = '';
                
                // Show matching categories
                if (matches.length > 0) {
                    suggestionsHTML += matches.map(tag => 
                        `<div class="tag-suggestion" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f5f9; transition: all 0.2s ease; display: flex; align-items: center; justify-content: space-between;" 
                             onmouseover="this.style.background='#f8fafc'" 
                             onmouseout="this.style.background='white'"
                             onclick="selectEditTag('${tag}')">
                            <span>${tag}</span>
                            <span style="color: #64748b; font-size: 12px;">meglévő</span>
                        </div>`
                    ).join('');
                }
                
                // Add "Create new" option if not exact match
                if (!exactMatch && currentTag.length >= 2) {
                    suggestionsHTML += `
                        <div class="tag-suggestion" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f5f9; transition: all 0.2s ease; display: flex; align-items: center; justify-content: space-between; background: rgba(102, 126, 234, 0.05);" 
                             onmouseover="this.style.background='rgba(102, 126, 234, 0.1)'" 
                             onmouseout="this.style.background='rgba(102, 126, 234, 0.05)'"
                             onclick="selectEditTag('${value.trim()}')">
                            <span><strong>+ "${value.trim()}"</strong></span>
                            <span style="color: #667eea; font-size: 12px; font-weight: 600;">új létrehozása</span>
                        </div>`;
                }
                
                if (suggestionsHTML) {
                    suggestions.innerHTML = suggestionsHTML;
                    suggestions.style.display = 'block';
                } else {
                    suggestions.style.display = 'none';
                }
            } catch (error) {
                console.error('Error in handleEditTagInput:', error);
                suggestions.style.display = 'none';
            }
        }

        // Select tag for Edit modal
        function selectEditTag(tag) {
            addEditTag(tag);
            // Clear input and hide suggestions
            const tagInput = document.getElementById('editSetTag');
            const suggestions = document.getElementById('editTagSuggestions');
            if (tagInput) tagInput.value = '';
            if (suggestions) suggestions.style.display = 'none';
        }

        // Handle keydown for Edit tag input
        function handleEditTagKeydown(event) {
            if (event.key === 'Escape') {
                document.getElementById('editTagSuggestions').style.display = 'none';
            }
            
            // Prevent form submission on Enter key
            if (event.key === 'Enter') {
                event.preventDefault();
                
                const suggestions = document.getElementById('editTagSuggestions');
                const input = document.getElementById('editSetTag');
                
                // If there are suggestions visible, select the first one
                if (suggestions.style.display !== 'none') {
                    const firstSuggestion = suggestions.querySelector('.tag-suggestion');
                    if (firstSuggestion) {
                        firstSuggestion.click();
                        return false;
                    }
                }
                
                // If input has value, add it as tag
                if (input.value.trim()) {
                    addEditTag(input.value.trim());
                }
                
                return false;
            }
        }

        // Selected tags array for Edit modal
        let editSelectedTagsList = [];

        // Add tag to Edit modal
        function addEditTag(tagName) {
            console.log('DEBUG - addEditTag:', tagName);
            
            const input = document.getElementById('editSetTag');
            const selectedTagsContainer = document.getElementById('editSelectedTags');
            
            // Check if tag already exists
            if (editSelectedTagsList.includes(tagName)) {
                console.log('DEBUG - Tag már létezik:', tagName);
                input.value = '';
                document.getElementById('editTagSuggestions').style.display = 'none';
                return;
            }
            
            // Add to array
            editSelectedTagsList.push(tagName);
            
            // Create tag element
            const tagElement = document.createElement('div');
            tagElement.style.cssText = 'display: inline-flex; align-items: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 500; margin-bottom: 4px;';
            tagElement.innerHTML = `
                <span>${tagName}</span>
                <button type="button" onclick="removeEditTag('${tagName}')" style="margin-left: 8px; background: none; border: none; color: white; cursor: pointer; font-size: 16px; padding: 0; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'" title="Tag eltávolítása">×</button>
            `;
            
            // Add to container
            selectedTagsContainer.appendChild(tagElement);
            
            // Clear and hide input
            input.value = '';
            document.getElementById('editTagSuggestions').style.display = 'none';
            
            console.log('DEBUG - Tag hozzáadva:', tagName);
            console.log('DEBUG - Jelenlegi tagek:', editSelectedTagsList);
        }

        // Remove specific tag from Edit modal
        function removeEditTag(tagName) {
            console.log('DEBUG - removeEditTag called for:', tagName);
            
            // Remove from array
            const index = editSelectedTagsList.indexOf(tagName);
            if (index > -1) {
                editSelectedTagsList.splice(index, 1);
            }
            
            // Remove from DOM - find and remove the tag element
            const selectedTagsContainer = document.getElementById('editSelectedTags');
            const tagElements = selectedTagsContainer.children;
            
            for (let i = 0; i < tagElements.length; i++) {
                const tagElement = tagElements[i];
                const tagText = tagElement.querySelector('span').textContent;
                if (tagText === tagName) {
                    tagElement.remove();
                    break;
                }
            }
            
            console.log('DEBUG - Tag eltávolítva:', tagName);
            console.log('DEBUG - Maradék tagek:', editSelectedTagsList);
        }

        // Get current edit tags (first tag only for compatibility)
        function getCurrentEditTag() {
            return editSelectedTagsList.length > 0 ? editSelectedTagsList[0] : null;
        }

        // Get all current edit tags
        function getAllEditTags() {
            return editSelectedTagsList;
        }

        // Save edited set
        async function saveEditedSet(setId) {
            console.log('DEBUG - saveEditedSet: FUNKCIÓ MEGHÍVVA! setId =', setId);
            
            const nameInput = document.getElementById('editSetName');
            const descriptionInput = document.getElementById('editSetDescription');
            const languageAInput = document.getElementById('editLanguageA');
            const languageBInput = document.getElementById('editLanguageB');
            
            console.log('DEBUG - saveEditedSet: INPUT ELEMEK BETÖLTVE');
            
            // Validation
            if (!nameInput.value.trim()) {
                showErrorMessage('A szett neve kötelező!');
                nameInput.focus();
                return;
            }
            
            if (!languageAInput.value.trim()) {
                showErrorMessage('Az A nyelv neve kötelező!');
                languageAInput.focus();
                return;
            }
            
            if (!languageBInput.value.trim()) {
                showErrorMessage('A B nyelv neve kötelező!');
                languageBInput.focus();
                return;
            }
            
            try {
                // Get current tags from the tag list
                const allTags = getAllEditTags();
                const currentTag = allTags.length > 0 ? allTags[0] : null; // Save first tag for compatibility
                console.log('DEBUG - saveEditedSet: allTags =', allTags);
                console.log('DEBUG - saveEditedSet: currentTag (first) =', currentTag);
                
                // Prepare data for update (without category - we'll handle that separately)
                const updateData = {
                    title: nameInput.value.trim(),
                    description: descriptionInput.value.trim() || null,
                    language_a: translateToEnglish(languageAInput.value.trim()),
                    language_b: translateToEnglish(languageBInput.value.trim()),
                    updated_at: new Date().toISOString()
                };
                
                console.log('DEBUG - saveEditedSet: updateData =', updateData);
                
                // Update flashcard set basic data
                const { error: setError } = await supabase
                    .from('flashcard_sets')
                    .update(updateData)
                    .eq('id', setId);
                
                if (setError) {
                    console.error('Error updating set:', setError);
                    showErrorMessage('Hiba történt a szett mentése során!');
                    return;
                }
                
                console.log('DEBUG - saveEditedSet: Flashcard set update successful!');
                
                // Handle categories (tags)
                if (allTags.length > 0) {
                    // First, get or create categories
                    const categoryPromises = allTags.map(async tagName => {
                        const trimmedName = tagName.trim().toLowerCase();
                        
                        // Try to find existing category (using ilike for better Unicode support)
                        const { data: existingCategories, error: findError } = await supabase
                            .from('categories')
                            .select('id, name')
                            .ilike('name', trimmedName)
                            .limit(1);
                        
                        // Check for exact match
                        const existingCategory = existingCategories?.find(cat => 
                            cat.name.toLowerCase() === trimmedName
                        );
                        
                        if (existingCategory) {
                            return existingCategory;
                        }
                        
                        // Handle search errors
                        if (findError) {
                            console.warn('Category search error (non-critical):', findError.message);
                        }
                        
                        // Create new category if not found
                        const { data: newCategory, error: createError } = await supabase
                            .from('categories')
                            .insert([{ name: trimmedName }])
                            .select('id, name')
                            .single();
                        
                        if (createError) {
                            console.error('Error creating category:', createError);
                            throw createError;
                        }
                        
                        return newCategory;
                    });
                    
                    try {
                        const categories = await Promise.all(categoryPromises);
                        console.log('DEBUG - saveEditedSet: Categories resolved:', categories);
                        
                        // Remove old category associations
                        const { error: deleteError } = await supabase
                            .from('flashcard_set_categories')
                            .delete()
                            .eq('set_id', setId);
                        
                        if (deleteError) {
                            console.error('Error deleting old categories:', deleteError);
                        }
                        
                        // Add new category associations
                        const categoryInserts = categories.map(category => ({
                            set_id: setId,
                            category_id: category.id
                        }));
                        
                        const { error: insertError } = await supabase
                            .from('flashcard_set_categories')
                            .insert(categoryInserts);
                        
                        if (insertError) {
                            console.error('Error inserting new categories:', insertError);
                            showErrorMessage('Hiba történt a tag-ek mentése során!');
                            return;
                        }
                        
                        console.log('DEBUG - saveEditedSet: Categories updated successfully!');
                        
                    } catch (error) {
                        console.error('Error handling categories:', error);
                        showErrorMessage('Hiba történt a tag-ek mentése során!');
                        return;
                    }
                } else {
                    // Remove all category associations if no tags
                    const { error: deleteError } = await supabase
                        .from('flashcard_set_categories')
                        .delete()
                        .eq('set_id', setId);
                    
                    if (deleteError) {
                        console.error('Error deleting categories:', deleteError);
                    }
                    
                    console.log('DEBUG - saveEditedSet: All categories removed (no tags)');
                }
                
                showSuccessMessage(' Szett sikeresen frissítve!');
                closeModal();
                
                // Refresh the dashboard to show updated data
                await loadDashboardData();
                
            } catch (error) {
                console.error('Error saving set:', error);
                showErrorMessage('Hiba történt a szett mentése során!');
            }
        }

        // Close modal function
        function closeModal() {
            const container = document.getElementById('modalContainer');
            if (container) {
                container.style.display = 'none';
                container.innerHTML = '';
            }
        }

        async function deleteSet(setId) {
            closeAllDropdowns();
            
            const set = dashboardData.ownSets.find(s => s.id === setId);
            if (!set) {
                showErrorMessage('Szett nem található!');
                return;
            }

            const confirmText = prompt(
                'FIGYELEM! Biztosan törölni szeretnéd a "' + set.title + '" szettet?\n\n' +
                `Ez a következőket jelenti:\n` +
                `• A szett és az összes kártyája véglegesen törlődik\n` +
                `• A tanulási előrehaladás is törlődik\n` +
                `• Ez a művelet nem vonható vissza!\n\n` +
                `Írj be "TÖRLÉS"-t a megerősítéshez:`
            );

            if (confirmText !== 'TÖRLÉS') {
                showInfoMessage('Törlés megszakítva.');
                return;
            }

            try {
                // Delete user progress first
                const { error: progressError } = await supabase
                    .from('user_card_progress')
                    .delete()
                    .eq('set_id', setId);

                if (progressError) {
                    console.warn('Warning deleting progress:', progressError);
                }

                // Delete flashcard set cards relationships
                const { error: setCardsError } = await supabase
                    .from('flashcard_set_cards')
                    .delete()
                    .eq('set_id', setId);

                if (setCardsError) {
                    console.warn('Warning deleting set cards:', setCardsError);
                }

                // Delete the flashcard set
                const { error: setError } = await supabase
                    .from('flashcard_sets')
                    .delete()
                    .eq('id', setId)
                    .eq('user_id', currentUser.id); // Extra safety check

                if (setError) {
                    throw setError;
                }

                showSuccessMessage('"' + set.title + '" szett sikeresen törölve!');
                
                // Reload dashboard data
                await loadDashboardData();

            } catch (error) {
                console.error('Error deleting set:', error);
                showErrorMessage('Hiba történt a szett törlésekor: ' + error.message);
            }
        }

        // Show enhanced cards list function
        async function showCardsList(setId) {
            console.log('🔥 showCardsList called with setId:', setId);
            
            // Show loading immediately
            const loadingModal = document.createElement('div');
            loadingModal.id = 'cardsListLoading';
            loadingModal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.3); display: flex; align-items: center;
                justify-content: center; z-index: 10001;
            `;
            loadingModal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 12px; text-align: center;">
                    <div style="color: #667eea; font-weight: 600; margin-bottom: 8px;">Lista betöltése...</div>
                    <div style="width: 40px; height: 4px; background: #f0f0f0; border-radius: 2px; margin: 0 auto; overflow: hidden;">
                        <div style="width: 100%; height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); border-radius: 2px; animation: loading 1.5s ease-in-out infinite; transform: translateX(-100%);"></div>
                    </div>
                </div>
                <style>
                    @keyframes loading {
                        0% { transform: translateX(-100%); }
                        50% { transform: translateX(0%); }
                        100% { transform: translateX(100%); }
                    }
                </style>
            `;
            document.body.appendChild(loadingModal);
            
            try {
                // Get set details
                const { data: set, error: setError } = await supabase
                    .from('flashcard_sets')
                    .select('*')
                    .eq('id', setId)
                    .single();

                console.log('📊 Set query result:', { set, setError });
                if (setError) {
                    console.error('❌ Set error:', setError);
                    throw setError;
                }

                // Try to get cards directly first (in case they exist in cards table)
                let cards = [];
                
                // Method 1: Try flashcard_set_cards junction table with manual join
                try {
                    // First get card IDs from junction table
                    const { data: flashcardSetCards, error: junctionError } = await supabase
                        .from('flashcard_set_cards')
                        .select('card_id, position')
                        .eq('set_id', setId)
                        .order('position', { ascending: true });

                    console.log('🔗 Junction table result:', { flashcardSetCards, junctionError });
                    
                    if (!junctionError && flashcardSetCards && flashcardSetCards.length > 0) {
                        // Extract card IDs
                        const cardIds = flashcardSetCards.map(item => item.card_id).filter(Boolean);
                        console.log('📝 Card IDs found:', cardIds);
                        
                        // Now get the actual cards with their categories
                        const { data: cardsData, error: cardsError } = await supabase
                            .from('cards')
                            .select('*')
                            .in('id', cardIds);
                        
                        if (!cardsError && cardsData) {
                            // Optimize: Load all categories for all cards in one query
                            const cardIds = cardsData.map(card => card.id);
                            
                            // Get all card-category relationships for these cards
                            const { data: allCardCategories } = await supabase
                                .from('card_categories')
                                .select(`
                                    card_id,
                                    categories!inner(id, name)
                                `)
                                .in('card_id', cardIds);
                            
                            // Build a map of card_id -> categories
                            const cardCategoriesMap = {};
                            if (allCardCategories) {
                                allCardCategories.forEach(cc => {
                                    if (!cardCategoriesMap[cc.card_id]) {
                                        cardCategoriesMap[cc.card_id] = [];
                                    }
                                    cardCategoriesMap[cc.card_id].push(cc.categories);
                                });
                            }
                            
                            // Assign categories to cards
                            cardsData.forEach(card => {
                                card.categories = cardCategoriesMap[card.id] || [];
                            });
                            
                            cards = cardsData;
                            console.log('✅ Found cards via optimized junction table:', cards.length);
                        }
                    }
                } catch (jError) {
                    console.log('⚠️ Junction table failed, trying direct method');
                }
                
                // Method 2: If no cards found, try direct cards table with set_id
                if (cards.length === 0) {
                    try {
                        const { data: directCards, error: directError } = await supabase
                            .from('cards')
                            .select('*')
                            .eq('set_id', setId)
                            .order('created_at', { ascending: false });

                        console.log('📝 Direct cards result:', { directCards, directError });
                        
                        if (!directError && directCards && directCards.length > 0) {
                            cards = directCards;
                            console.log('✅ Found cards via direct method:', cards.length);
                        }
                    } catch (dError) {
                        console.log('⚠️ Direct method also failed');
                    }
                }

                console.log('🎯 Final cards array:', cards);

                // Store cards globally for filtering
                window.currentListCards = cards;
                window.currentListSet = set;

                // Remove loading modal
                const loadingModal = document.getElementById('cardsListLoading');
                if (loadingModal) {
                    document.body.removeChild(loadingModal);
                }

                // Show simple modal for now
                showSimpleCardsList(set, cards);

            } catch (error) {
                console.error('❌ Error loading cards list:', error);
                
                // Remove loading modal in case of error
                const loadingModal = document.getElementById('cardsListLoading');
                if (loadingModal) {
                    document.body.removeChild(loadingModal);
                }
                
                alert('Hiba történt a kártyák betöltésekor: ' + error.message);
            }
        }

        // Global sorting state for cards list
        window.cardsSortState = {
            column: null, // 'hungarian' or 'english'
            direction: 'asc' // 'asc' or 'desc'
        };

        // Enhanced cards list modal  
        function showSimpleCardsList(set, cards) {
            console.log('📋 showSimpleCardsList called with:', cards.length, 'cards');
            
            let cardsHTML = '';
            
            if (!cards || cards.length === 0) {
                // Check if this is due to filtering (search) vs truly empty set
                const isFiltered = window.currentListCards && window.currentListCards.length > 0 && (!cards || cards.length === 0);
                
                if (isFiltered) {
                    // Empty due to search filter
                    cardsHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <div style="font-size: 48px; margin-bottom: 16px;">🔍</div>
                            <h3 style="margin: 0 0 8px 0; color: #374151;">Nincs találat</h3>
                            <p style="margin: 0; color: #6b7280;">Próbálj más keresési kifejezéssel!</p>
                        </div>
                    `;
                } else {
                    // Truly empty set
                    cardsHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <h3>📝 Még nincsenek kártyák</h3>
                            <p>Hozz létre az első kártyát ebben a szettben!</p>
                            <button onclick="addCardsToSet('${set.id}'); closeModal();" style="
                                background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                                color: white;
                                border: none;
                                padding: 12px 24px;
                                border-radius: 8px;
                                font-weight: 600;
                                cursor: pointer;
                                margin-top: 16px;
                            ">+ Új kártya</button>
                        </div>
                    `;
                }
            } else {
                // Header with sortable language labels
                const getSortIcon = (column) => {
                    if (window.cardsSortState.column !== column) {
                        return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity: 0.5; margin-left: 8px;"><path d="M8 9l4-4 4 4"/><path d="M16 15l-4 4-4-4"/></svg>';
                    }
                    if (window.cardsSortState.direction === 'asc') {
                        return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: 8px;"><path d="M8 9l4-4 4 4"/></svg>';
                    } else {
                        return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: 8px;"><path d="M16 15l-4 4-4-4"/></svg>';
                    }
                };

                const headerHTML = `
                    <div style="
                        display: grid;
                        grid-template-columns: 50px 1fr 1fr 100px;
                        gap: 20px;
                        padding: 16px 20px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border-radius: 8px 8px 0 0;
                        font-weight: 600;
                        font-size: 14px;
                        margin-bottom: 4px;
                    ">
                        <div>#</div>
                        <div onclick="sortCardsList('hungarian')" style="
                            cursor: pointer; 
                            display: flex; 
                            align-items: center; 
                            transition: opacity 0.2s;
                            user-select: none;
                        " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                            ${translateLanguageName(set.language_a)}${getSortIcon('hungarian')}
                        </div>
                        <div onclick="sortCardsList('english')" style="
                            cursor: pointer; 
                            display: flex; 
                            align-items: center; 
                            transition: opacity 0.2s;
                            user-select: none;
                        " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                            ${translateLanguageName(set.language_b)}${getSortIcon('english')}
                        </div>
                        <div style="text-align: center;">Műveletek</div>
                    </div>
                `;

                const cardsRows = cards.map((card, index) => `
                    <div id="row-${card.id}" style="
                        background: rgba(255, 255, 255, 0.95);
                        border: 1px solid rgba(226, 232, 240, 0.8);
                        border-radius: 0;
                        padding: 20px;
                        margin-bottom: 2px;
                        display: grid;
                        grid-template-columns: 50px 1fr 1fr 100px;
                        gap: 20px;
                        align-items: start;
                        transition: all 0.2s ease;
                        min-height: 60px;
                    " onmouseover="this.style.background='rgba(248, 250, 252, 1)'; this.style.transform='translateX(4px)'" 
                       onmouseout="this.style.background='rgba(255, 255, 255, 0.95)'; this.style.transform='translateX(0)'">
                        
                        <!-- Sorszám -->
                        <div style="
                            width: 36px;
                            height: 36px;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: 600;
                            font-size: 14px;
                            flex-shrink: 0;
                        ">${index + 1}</div>
                        
                        <!-- Magyar szöveg (Rich Text) -->
                        <div id="front-${card.id}" style="
                            font-size: 16px;
                            color: #1f2937;
                            line-height: 1.5;
                            word-wrap: break-word;
                            overflow-wrap: break-word;
                            padding: 8px;
                            border-radius: 4px;
                            transition: all 0.2s ease;
                        ">
                            ${card.title_formatted || card.title || card.front_text || 'N/A'}
                        </div>
                        
                        <!-- Angol szöveg (Rich Text) -->
                        <div id="back-${card.id}" style="
                            font-size: 16px;
                            color: #4b5563;
                            line-height: 1.5;
                            word-wrap: break-word;
                            overflow-wrap: break-word;
                            padding: 8px;
                            border-radius: 4px;
                            transition: all 0.2s ease;
                        ">
                            ${card.english_title_formatted || card.english_title || card.back_text || 'N/A'}
                        </div>
                        
                        <!-- Műveletek -->
                        <div id="actions-${card.id}" style="
                            display: flex;
                            gap: 8px;
                            justify-content: center;
                            align-items: center;
                        ">
                            <button onclick="openEditCardModal('${card.id}')" style="
                                width: 36px;
                                height: 36px;
                                background: rgba(59, 130, 246, 0.1);
                                border: 1px solid rgba(59, 130, 246, 0.2);
                                border-radius: 6px;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            " onmouseover="this.style.background='rgba(59, 130, 246, 0.2)'; this.style.transform='scale(1.1)'" 
                               onmouseout="this.style.background='rgba(59, 130, 246, 0.1)'; this.style.transform='scale(1)'" 
                               title="Szerkesztés">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"/>
                                    <path d="m15 5 4 4"/>
                                </svg>
                            </button>
                            
                            <button onclick="deleteCardFromList('${card.id}')" style="
                                width: 36px;
                                height: 36px;
                                background: rgba(239, 68, 68, 0.1);
                                border: 1px solid rgba(239, 68, 68, 0.2);
                                border-radius: 6px;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            " onmouseover="this.style.background='rgba(239, 68, 68, 0.2)'; this.style.transform='scale(1.1)'" 
                               onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.transform='scale(1)'" 
                               title="Törlés">
                                <i data-lucide="trash" width="16" height="16" style="color: #ef4444;"></i>
                            </button>
                        </div>
                    </div>
                `).join('');

                cardsHTML = headerHTML + cardsRows;
            }

            const modalContainer = document.getElementById('modalContainer');
            modalContainer.innerHTML = `
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                " onclick="closeModal()">
                    <div onclick="event.stopPropagation()" style="
                        background: white;
                        border-radius: 12px;
                        max-width: 1400px;
                        max-height: 85vh;
                        overflow-y: auto;
                        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                        width: 95%;
                        margin: 20px;
                    ">
                        <div style="padding: 24px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                                <h2 style="margin: 0; color: #1f2937; font-size: 24px; font-weight: 700;">
                                    ${set.title} - Kártyák (${cards.length})
                                </h2>
                                <button onclick="closeModal()" style="
                                    background: none;
                                    border: none;
                                    font-size: 24px;
                                    color: #6b7280;
                                    cursor: pointer;
                                    padding: 4px;
                                    border-radius: 4px;
                                    transition: background 0.2s;
                                " onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='none'">×</button>
                            </div>
                            <div>
                                ${cardsHTML}
                            </div>
                            
                            <!-- Footer with close button -->
                            <div style="
                                border-top: 1px solid #e5e7eb;
                                padding: 20px 0 0 0;
                                margin-top: 24px;
                                text-align: center;
                            ">
                                <button onclick="closeModal()" style="
                                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                    color: white;
                                    border: none;
                                    padding: 12px 32px;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    font-size: 16px;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.transform='scale(1.02)'" 
                                   onmouseout="this.style.transform='scale(1)'">
                                    Bezár
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            modalContainer.style.display = 'block';
            modalContainer.style.position = 'fixed';
            modalContainer.style.top = '0';
            modalContainer.style.left = '0';
            modalContainer.style.width = '100%';
            modalContainer.style.height = '100%';
            modalContainer.style.zIndex = '10000';
            console.log('✅ Modal displayed');
        }

        // Sort cards list by column (hungarian/english)
        function sortCardsList(column) {
            console.log('🔤 Sorting cards by:', column);
            
            // Update sort state
            if (window.cardsSortState.column === column) {
                // Toggle direction if same column
                window.cardsSortState.direction = window.cardsSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                // New column, start with ascending
                window.cardsSortState.column = column;
                window.cardsSortState.direction = 'asc';
            }
            
            // Sort the cards array
            const sortedCards = [...window.currentListCards].sort((a, b) => {
                let valueA, valueB;
                
                if (column === 'hungarian') {
                    valueA = (a.title_formatted || a.title || a.front_text || '').toLowerCase().trim();
                    valueB = (b.title_formatted || b.title || b.front_text || '').toLowerCase().trim();
                } else {
                    valueA = (a.english_title_formatted || a.english_title || a.back_text || '').toLowerCase().trim();
                    valueB = (b.english_title_formatted || b.english_title || b.back_text || '').toLowerCase().trim();
                }
                
                // Handle empty values
                if (!valueA && !valueB) return 0;
                if (!valueA) return 1;
                if (!valueB) return -1;
                
                // Sort with direction
                const comparison = valueA.localeCompare(valueB, 'hu', { 
                    sensitivity: 'base', 
                    numeric: true 
                });
                
                return window.cardsSortState.direction === 'asc' ? comparison : -comparison;
            });
            
            // Update global cards and refresh display
            window.currentListCards = sortedCards;
            showSimpleCardsList(window.currentListSet, sortedCards);
            
            console.log('✅ Cards sorted:', window.cardsSortState);
        }

        // Enhanced cards list modal
        function showCardsListModal(set, cards) {
            try {
                const cardsHTML = generateCardsListHTML(cards, set);
            
            document.getElementById('modalContainer').innerHTML = `
                <div class="modal-overlay" onclick="closeModal()">
                    <div class="modal-content cards-list-modal" onclick="event.stopPropagation()">
                        <!-- Header -->
                        <div class="cards-list-header">
                            <div class="header-title">
                                <h2>${set.title}</h2>
                                <div class="header-stats">
                                    <span class="stat-badge">${cards ? cards.length : 0} kártya</span>
                                    <span class="stat-badge">${translateLanguageName(set.language_a)} → ${translateLanguageName(set.language_b)}</span>
                                </div>
                            </div>
                            <button onclick="closeModal()" class="close-btn">
                                <svg class="lucide-icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M18 6 6 18"/>
                                    <path d="m6 6 12 12"/>
                                </svg>
                            </button>
                        </div>

                        <!-- Toolbar -->
                        <div class="cards-list-toolbar">
                            <div class="search-section">
                                <div class="search-input-wrapper">
                                    <input 
                                        type="text" 
                                        id="cardsListSearch" 
                                        class="search-input" 
                                        placeholder="🔍 Keresés kártyákban..."
                                        oninput="filterCardsList(this.value)"
                                    >
                                    <button class="search-clear" onclick="clearCardsListSearch()" style="display: none;">
                                        <svg class="lucide-icon icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M18 6 6 18"/>
                                            <path d="m6 6 12 12"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            
                            <div class="toolbar-actions">
                                <select id="sortOrder" onchange="sortCardsList(this.value)" class="sort-select">
                                    <option value="newest">Legújabb</option>
                                    <option value="oldest">Legrégebbi</option>
                                    <option value="az">A-Z (${translateLanguageName(set.language_a)})</option>
                                    <option value="za">Z-A (${translateLanguageName(set.language_a)})</option>
                                </select>
                                
                                <button onclick="exportCardsList()" class="action-btn export-btn" title="Exportálás">
                                    <svg class="lucide-icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="7,10 12,15 17,10"/>
                                        <line x1="12" x2="12" y1="15" y2="3"/>
                                    </svg>
                                    Export
                                </button>
                                
                                <button onclick="addCardsToSet('${set.id}')" class="action-btn add-btn" title="Új kártya">
                                    <svg class="lucide-icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M5 12h14"/>
                                        <path d="m12 5v14"/>
                                    </svg>
                                    Új kártya
                                </button>
                            </div>
                        </div>

                        <!-- Cards List -->
                        <div class="cards-list-container" id="cardsListContainer">
                            ${cardsHTML}
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('modalContainer').style.display = 'flex';
            
            } catch (error) {
                console.error('Error in showCardsListModal:', error);
                alert('Hiba a modal megjelenítésekor: ' + error.message);
            }
        }

        // Generate cards list HTML
        function generateCardsListHTML(cards, set) {
            if (!cards || cards.length === 0) {
                return `
                    <div class="empty-state">
                        <div class="empty-icon">📝</div>
                        <h3 class="empty-title">Még nincsenek kártyák</h3>
                        <p class="empty-description">Hozz létre az első kártyát ebben a szettben!</p>
                        <button onclick="addCardsToSet('${set.id}')" class="btn-action btn-add">
                            <svg class="lucide-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M5 12h14"/>
                                <path d="m12 5v14"/>
                            </svg>
                            Új kártya
                        </button>
                    </div>
                `;
            }

            return cards.map((card, index) => `
                <div class="card-list-item" data-card-id="${card.id}">
                    <div class="card-number">${index + 1}</div>
                    
                    <div class="card-content">
                        <div class="card-side front">
                            <div class="side-label">${translateLanguageName(set.language_a)}</div>
                            <div class="side-text">${card.title}</div>
                        </div>
                        
                        <div class="card-divider">
                            <svg class="lucide-icon icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9,18 15,12 9,6"/>
                            </svg>
                        </div>
                        
                        <div class="card-side back">
                            <div class="side-label">${translateLanguageName(set.language_b)}</div>
                            <div class="side-text">${card.english_title}</div>
                        </div>
                    </div>
                    
                    ${card.media_url ? `
                        <div class="card-media">
                            ${card.media_type === 'video' ? 
                                `<video src="${card.media_url}" controls style="max-width: 60px; max-height: 40px; border-radius: 4px;"></video>` :
                                `<img src="${card.media_url}" alt="Card media" style="max-width: 60px; max-height: 40px; object-fit: cover; border-radius: 4px;">`
                            }
                        </div>
                    ` : ''}
                    
                    ${card.categories && card.categories.length > 0 ? `
                        <div class="card-tags" style="display: flex; flex-wrap: wrap; gap: 4px; margin: 8px 0;">
                            ${card.categories.map(cat => `
                                <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 500;">
                                    ${cat.name}
                                </span>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div class="card-actions">
                                                    <button onclick="openEditCardModal('${card.id}')" class="list-action-btn edit" title="Szerkesztés">
                            <svg class="lucide-icon icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"/>
                                <path d="m15 5 4 4"/>
                            </svg>
                        </button>
                        
                        <button onclick="deleteCardFromList('${card.id}')" class="list-action-btn delete" title="Törlés">
                            <i data-lucide="trash" class="lucide-icon icon-xs"></i>
                        </button>
                    </div>
                    
                    <div class="card-date">
                        ${new Date(card.created_at).toLocaleDateString('hu-HU')}
                    </div>
                </div>
            `).join('');
        }

        // Cards list filter functions
        function filterCardsList(query) {
            const searchInput = document.getElementById('cardsListSearch');
            const clearBtn = searchInput.parentElement.querySelector('.search-clear');
            
            // Show/hide clear button
            if (query.trim()) {
                clearBtn.style.display = 'flex';
            } else {
                clearBtn.style.display = 'none';
            }
            
            // If query is empty, show all cards
            if (!query.trim()) {
                showSimpleCardsList(window.currentListSet, window.currentListCards);
                return;
            }
            
            // Normalize query for better search
            const normalizedQuery = query.toLowerCase().trim();
            
            // Filter cards based on query
            const filteredCards = window.currentListCards.filter(card => {
                return card.title.toLowerCase().includes(normalizedQuery) ||
                       card.english_title.toLowerCase().includes(normalizedQuery);
            });
            
            // Update display with filtered cards
            showSimpleCardsList(window.currentListSet, filteredCards);
        }

        function clearCardsListSearch() {
            const searchInput = document.getElementById('cardsListSearch');
            const clearBtn = searchInput.parentElement.querySelector('.search-clear');
            
            searchInput.value = '';
            clearBtn.style.display = 'none';
            showSimpleCardsList(window.currentListSet, window.currentListCards);
            searchInput.focus();
        }





        function exportCardsList() {
            if (!window.currentListCards || window.currentListCards.length === 0) {
                alert('Nincsenek kártyák az exportáláshoz!');
                return;
            }
            
            // Create CSV content
            const headers = [window.currentListSet.language_a, window.currentListSet.language_b, 'Létrehozva'];
            const csvContent = [
                headers.join(','),
                ...window.currentListCards.map(card => [
                    `"${card.title.replace(/"/g, '""')}"`,
                    `"${card.english_title.replace(/"/g, '""')}"`,
                    `"${new Date(card.created_at).toLocaleDateString('hu-HU')}"`
                ].join(','))
            ].join('\n');
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `${window.currentListSet.title}_kartyak.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            alert(`${window.currentListCards.length} kártya exportálva CSV formátumban!`);
        }

        // Inline editing functions
        function startInlineEdit(cardId) {
            console.log('✏️ Starting inline edit for card:', cardId);
            
            const card = window.currentListCards.find(c => c.id === cardId);
            if (!card) return;
            
            // Get current values
            const currentFront = card.title_formatted || card.title || '';
            const currentBack = card.english_title_formatted || card.english_title || '';
            
            // Store original values for cancel
            window.editingCard = {
                id: cardId,
                originalFront: currentFront,
                originalBack: currentBack
            };
            
            // Get elements
            const frontDiv = document.getElementById(`front-${cardId}`);
            const backDiv = document.getElementById(`back-${cardId}`);
            const actionsDiv = document.getElementById(`actions-${cardId}`);
            const rowDiv = document.getElementById(`row-${cardId}`);
            
            // Set container styles for proper alignment
            frontDiv.style.cssText = `
                display: flex;
                align-items: center;
                height: 36px;
                margin: 0;
                padding: 0;
            `;
            
            backDiv.style.cssText = `
                display: flex;
                align-items: center;
                height: 36px;
                margin: 0;
                padding: 0;
            `;
            
            // Replace text with input fields that have the exact same height as action buttons
            frontDiv.innerHTML = `
                <textarea id="edit-front-${cardId}" style="
                    width: 100%; 
                    height: 36px;
                    padding: 6px;
                    border: 2px solid #3b82f6;
                    border-radius: 6px;
                    font-size: 14px;
                    font-family: inherit;
                    line-height: 1.3;
                    resize: none;
                    outline: none;
                    background: rgba(59, 130, 246, 0.05);
                    margin: 0;
                    box-sizing: border-box;
                    overflow: hidden;
                    flex: 1;
                " onkeydown="handleInlineEditKeydown(event, '${cardId}')" oninput="autoResizeTextarea(this)">${currentFront}</textarea>
            `;
            
            backDiv.innerHTML = `
                <textarea id="edit-back-${cardId}" style="
                    width: 100%; 
                    height: 36px;
                    padding: 6px;
                    border: 2px solid #3b82f6;
                    border-radius: 6px;
                    font-size: 14px;
                    font-family: inherit;
                    line-height: 1.3;
                    resize: none;
                    outline: none;
                    background: rgba(59, 130, 246, 0.05);
                    margin: 0;
                    box-sizing: border-box;
                    overflow: hidden;
                    flex: 1;
                " onkeydown="handleInlineEditKeydown(event, '${cardId}')" oninput="autoResizeTextarea(this)">${currentBack}</textarea>
            `;
            
            // Replace actions with save/cancel buttons
            actionsDiv.innerHTML = `
                <button onclick="saveInlineEdit('${cardId}')" style="
                    width: 36px;
                    height: 36px;
                    background: rgba(34, 197, 94, 0.1);
                    border: 1px solid rgba(34, 197, 94, 0.3);
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0;
                    padding: 0;
                    flex-shrink: 0;
                    box-sizing: border-box;
                " onmouseover="this.style.background='rgba(34, 197, 94, 0.2)'; this.style.transform='scale(1.1)'" 
                   onmouseout="this.style.background='rgba(34, 197, 94, 0.1)'; this.style.transform='scale(1)'" 
                   title="Mentés (Enter)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 6 9 17l-5-5"/>
                    </svg>
                </button>
                
                <button onclick="cancelInlineEdit('${cardId}')" style="
                    width: 36px;
                    height: 36px;
                    background: rgba(107, 114, 128, 0.1);
                    border: 1px solid rgba(107, 114, 128, 0.3);
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0;
                    padding: 0;
                    flex-shrink: 0;
                    box-sizing: border-box;
                " onmouseover="this.style.background='rgba(107, 114, 128, 0.2)'; this.style.transform='scale(1.1)'" 
                   onmouseout="this.style.background='rgba(107, 114, 128, 0.1)'; this.style.transform='scale(1)'" 
                   title="Mégse (Escape)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"/>
                        <path d="m6 6 12 12"/>
                    </svg>
                </button>
            `;
            
            // Update the actions container to align items to top
            actionsDiv.style.cssText = `
                display: flex;
                gap: 8px;
                justify-content: center;
                align-items: center;
                padding: 0;
                margin: 0;
                height: 36px;
            `;
            
            // Auto-resize textareas to content
            setTimeout(() => {
                const frontInput = document.getElementById(`edit-front-${cardId}`);
                const backInput = document.getElementById(`edit-back-${cardId}`);
                
                if (frontInput) {
                    autoResizeTextarea(frontInput);
                    frontInput.focus();
                    frontInput.select();
                }
                if (backInput) {
                    autoResizeTextarea(backInput);
                }
            }, 50);
        }
        
        // Auto-resize textarea to fit content
        function autoResizeTextarea(textarea) {
            textarea.style.height = '36px'; // Reset to minimum
            const scrollHeight = textarea.scrollHeight;
            const container = textarea.parentElement;
            
            if (scrollHeight > 36) {
                const newHeight = Math.min(scrollHeight, 120);
                textarea.style.height = newHeight + 'px';
                container.style.height = newHeight + 'px';
                textarea.style.overflow = scrollHeight > 120 ? 'auto' : 'hidden';
            } else {
                container.style.height = '36px';
            }
        }
        
        function handleInlineEditKeydown(event, cardId) {
            if (event.key === 'Enter' && event.ctrlKey) {
                event.preventDefault();
                saveInlineEdit(cardId);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                cancelInlineEdit(cardId);
            }
        }
        
        async function saveInlineEdit(cardId) {
            console.log('💾 Saving inline edit for card:', cardId);
            
            const frontInput = document.getElementById(`edit-front-${cardId}`);
            const backInput = document.getElementById(`edit-back-${cardId}`);
            
            if (!frontInput || !backInput) return;
            
            const newFrontText = frontInput.value.trim();
            const newBackText = backInput.value.trim();
            
            if (!newFrontText || !newBackText) {
                alert('Mindkét mező kitöltése kötelező!');
                return;
            }
            
            try {
                // Update in database
                const { error } = await supabase
                    .from('cards')
                    .update({
                        title: newFrontText,
                        english_title: newBackText,
                        title_formatted: newFrontText,
                        english_title_formatted: newBackText
                    })
                    .eq('id', cardId);
                
                if (error) throw error;
                
                // Update local data
                const card = window.currentListCards.find(c => c.id === cardId);
                if (card) {
                    card.title = newFrontText;
                    card.english_title = newBackText;
                    card.title_formatted = newFrontText;
                    card.english_title_formatted = newBackText;
                }
                
                // Reset editing state
                window.editingCard = null;
                
                // Restore normal view
                restoreNormalView(cardId, newFrontText, newBackText);
                
                // Show success message
                setTimeout(() => {
                    const successDiv = document.createElement('div');
                    successDiv.innerHTML = '✅ Kártya frissítve!';
                    successDiv.style.cssText = `
                        position: fixed; top: 20px; right: 20px; z-index: 10001;
                        background: #22c55e; color: white; padding: 12px 20px;
                        border-radius: 8px; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    `;
                    document.body.appendChild(successDiv);
                    setTimeout(() => document.body.removeChild(successDiv), 2000);
                }, 100);
                
            } catch (error) {
                console.error('Error updating card:', error);
                alert('Hiba történt a kártya frissítésekor: ' + error.message);
            }
        }
        
        function cancelInlineEdit(cardId) {
            console.log('❌ Canceling inline edit for card:', cardId);
            
            if (!window.editingCard || window.editingCard.id !== cardId) return;
            
            // Restore original values
            restoreNormalView(cardId, window.editingCard.originalFront, window.editingCard.originalBack);
            
            // Reset editing state
            window.editingCard = null;
        }
        
        function restoreNormalView(cardId, frontText, backText) {
            const frontDiv = document.getElementById(`front-${cardId}`);
            const backDiv = document.getElementById(`back-${cardId}`);
            const actionsDiv = document.getElementById(`actions-${cardId}`);
            const rowDiv = document.getElementById(`row-${cardId}`);
            
            // No need to restore row alignment since we didn't change it
            
            // Restore text content
            frontDiv.innerHTML = frontText || 'N/A';
            frontDiv.style.cssText = `
                font-size: 16px;
                color: #1f2937;
                line-height: 1.5;
                word-wrap: break-word;
                overflow-wrap: break-word;
                padding: 8px;
                border-radius: 4px;
                transition: all 0.2s ease;
            `;
            
            backDiv.innerHTML = backText || 'N/A';
            backDiv.style.cssText = `
                font-size: 16px;
                color: #4b5563;
                line-height: 1.5;
                word-wrap: break-word;
                overflow-wrap: break-word;
                padding: 8px;
                border-radius: 4px;
                transition: all 0.2s ease;
            `;
            
            // Restore action buttons and container styles
            actionsDiv.style.cssText = `
                display: flex;
                gap: 8px;
                justify-content: center;
                align-items: center;
            `;
            
            actionsDiv.innerHTML = `
                                            <button onclick="openEditCardModal('${cardId}')" style="
                    width: 36px;
                    height: 36px;
                    background: rgba(59, 130, 246, 0.1);
                    border: 1px solid rgba(59, 130, 246, 0.2);
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                " onmouseover="this.style.background='rgba(59, 130, 246, 0.2)'; this.style.transform='scale(1.1)'" 
                   onmouseout="this.style.background='rgba(59, 130, 246, 0.1)'; this.style.transform='scale(1)'" 
                   title="Szerkesztés">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"/>
                        <path d="m15 5 4 4"/>
                    </svg>
                </button>
                
                <button onclick="deleteCardFromList('${cardId}')" style="
                    width: 36px;
                    height: 36px;
                    background: rgba(239, 68, 68, 0.1);
                    border: 1px solid rgba(239, 68, 68, 0.2);
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                " onmouseover="this.style.background='rgba(239, 68, 68, 0.2)'; this.style.transform='scale(1.1)'" 
                   onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.transform='scale(1)'" 
                   title="Törlés">
                    <i data-lucide="trash" width="16" height="16" style="color: #ef4444;"></i>
                </button>
            `;
        }

        async function deleteCardFromList(cardId) {
            const card = window.currentListCards.find(c => c.id === cardId);
            if (!card) return;
            
            // Get display values (prefer formatted versions)
            const frontText = card.title_formatted || card.title || '';
            const backText = card.english_title_formatted || card.english_title || '';
            
            // Create beautiful confirmation modal instead of ugly alert
            const confirmModal = document.createElement('div');
            confirmModal.id = 'deleteConfirmModal';
            confirmModal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.5); display: flex; align-items: center;
                justify-content: center; z-index: 10001;
            `;
            
            confirmModal.innerHTML = `
                <div onclick="event.stopPropagation()" style="
                    background: white; border-radius: 12px; padding: 32px;
                    text-align: center; max-width: 450px; margin: 20px;
                    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                ">
                    <h3 style="margin: 0 0 16px 0; color: #1f2937; font-size: 20px; font-weight: 700;">
                        Kártya törlése
                    </h3>
                    <p style="margin: 0 0 24px 0; color: #6b7280; line-height: 1.5;">
                        Biztosan törölni szeretnéd ezt a kártyát?
                    </p>
                    <div style="
                        background: rgba(239, 68, 68, 0.1); 
                        border: 1px solid rgba(239, 68, 68, 0.2);
                        border-radius: 8px; 
                        padding: 16px; 
                        margin-bottom: 24px;
                    ">
                        <div style="font-weight: 600; color: #1f2937; margin-bottom: 4px;">${frontText}</div>
                        <div style="color: #6b7280;">↓</div>
                        <div style="color: #6b7280;">${backText}</div>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <button onclick="cancelDeleteCard()" style="
                            background: #e5e7eb; color: #374151; border: none;
                            padding: 12px 24px; border-radius: 8px; font-size: 14px; 
                            font-weight: 600; cursor: pointer; transition: background 0.2s;
                        " onmouseover="this.style.background='#d1d5db'" onmouseout="this.style.background='#e5e7eb'">
                            Mégse
                        </button>
                        <button onclick="confirmDeleteCard('${cardId}')" style="
                            background: #ef4444; color: white; border: none;
                            padding: 12px 24px; border-radius: 8px; font-size: 14px; 
                            font-weight: 600; cursor: pointer; transition: background 0.2s;
                        " onmouseover="this.style.background='#dc2626'" onmouseout="this.style.background='#ef4444'">
                            Törlés
                        </button>
                    </div>
                </div>
            `;
            
            // Add click outside to close
            confirmModal.onclick = function(e) {
                if (e.target === confirmModal) {
                    cancelDeleteCard();
                }
            };
            
            document.body.appendChild(confirmModal);
        }
        
        // Cancel delete
        function cancelDeleteCard() {
            const modal = document.getElementById('deleteConfirmModal');
            if (modal) {
                document.body.removeChild(modal);
            }
        }
        
        // Confirm delete
        async function confirmDeleteCard(cardId) {
            // Remove modal first
            cancelDeleteCard();
            
            try {
                // Delete from cards table and the junction table will auto-cleanup via cascade
                const { error } = await supabase
                    .from('cards')
                    .delete()
                    .eq('id', cardId);
                
                if (error) throw error;
                
                // Remove from local data
                window.currentListCards = window.currentListCards.filter(c => c.id !== cardId);
                
                // Refresh display by calling the simple list again
                showSimpleCardsList(window.currentListSet, window.currentListCards);
                
                // Show success message briefly
                setTimeout(() => {
                    const successDiv = document.createElement('div');
                    successDiv.innerHTML = `
                        Kártya törölve!
                    `;
                    successDiv.style.cssText = `
                        position: fixed; top: 20px; right: 20px; z-index: 10001;
                        background: #ef4444; color: white; padding: 12px 20px;
                        border-radius: 8px; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    `;
                    document.body.appendChild(successDiv);
                    setTimeout(() => document.body.removeChild(successDiv), 2000);
                }, 100);
                
            } catch (error) {
                console.error('Error deleting card:', error);
                alert('Hiba történt a kártya törlésekor: ' + error.message);
            }
        }

        // Advanced Import cards function - FIXED VERSION using body append
        async function importCards(setId) {
            console.log('🚀 Opening import modal for setId:', setId);
            
            // Store setId globally for import process
            window.currentImportSetId = setId;
            window.importPreviewData = [];
            
            // Remove any existing import modal
            const existingModal = document.getElementById('importModal');
            if (existingModal) {
                document.body.removeChild(existingModal);
            }
            
            // Create modal directly in body (this approach works!)
            const importModal = document.createElement('div');
            importModal.id = 'importModal';
            importModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
            `;
            
            importModal.innerHTML = `
                <div onclick="event.stopPropagation()" style="
                    background: white;
                    border-radius: 12px;
                    max-width: 1440px;
                    max-height: 90vh;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                    width: 90%;
                    margin: 20px;
                    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
                ">
                    <!-- Header -->
                    <div style="padding: 24px 32px; border-bottom: 1px solid rgba(226, 232, 240, 0.8); background: rgba(255, 255, 255, 0.95);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h2 style="margin: 0; color: #1f2937; font-size: 24px; font-weight: 700;">
                                📥 Intelligens kártya import
                            </h2>
                            <button onclick="closeImportModal()" style="
                                background: none; border: none; font-size: 24px; color: #6b7280;
                                cursor: pointer; padding: 4px; border-radius: 4px; transition: background 0.2s;
                            " onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='none'">×</button>
                        </div>
                        <p style="margin: 8px 0 0 0; color: #6b7280; font-size: 14px;">
                            Támogatott formátumok: Google Sheets, Excel, Word táblák, CSV fájlok
                        </p>
                    </div>

                    <!-- Import Area -->
                    <div style="padding: 24px 32px; border-bottom: 1px solid rgba(226, 232, 240, 0.8);">
                        <div style="display: grid; grid-template-columns: 1fr auto; gap: 16px; align-items: end;">
                            <!-- Paste Area -->
                            <div>
                                <label style="display: block; font-size: 14px; color: #374151; font-weight: 600; margin-bottom: 8px;">
                                    📋 Adatok beillesztése vagy fájl kiválasztása
                                </label>
                                <div 
                                    id="smartPasteArea"
                                    contenteditable="true"
                                    style="
                                        width: 100%;
                                        min-height: 80px;
                                        padding: 16px;
                                        border: 2px dashed #d1d5db;
                                        border-radius: 12px;
                                        font-size: 14px;
                                        line-height: 1.5;
                                        background: rgba(249, 250, 251, 0.5);
                                        transition: all 0.3s ease;
                                        outline: none;
                                    "
                                    placeholder="Illeszd be ide a táblázatot Google Sheets-ből, Excel-ből, Word-ből vagy írj CSV formátumban..."
                                    onpaste="handleSmartPaste(event)"
                                    oninput="handlePasteInput(event)"
                                    onfocus="this.style.borderColor='#667eea'; this.style.background='rgba(255,255,255,0.9)'"
                                    onblur="this.style.borderColor='#d1d5db'; this.style.background='rgba(249,250,251,0.5)'"
                                ></div>
                            </div>

                            <!-- File Upload -->
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <label for="smartFileInput" style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    width: 120px;
                                    height: 80px;
                                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                    color: white;
                                    border-radius: 12px;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                    border: none;
                                    font-weight: 600;
                                    text-align: center;
                                    font-size: 12px;
                                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                    <div>
                                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-bottom: 4px;">
                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                            <polyline points="16,10 12,6 8,10"/>
                                            <line x1="12" x2="12" y1="6" y2="14"/>
                                        </svg>
                                        <div>Fájl<br>kiválasztás</div>
                                    </div>
                                </label>
                                <input 
                                    type="file" 
                                    id="smartFileInput"
                                    accept=".csv,.xlsx,.xls,.txt"
                                    style="display: none;"
                                    onchange="handleFileImport(event)"
                                >
                            </div>
                        </div>
                    </div>

                    <!-- Preview Area -->
                    <div style="flex: 1; overflow: auto; padding: 0;">
                        <div id="importPreviewContainer" style="min-height: 300px;">
                            <!-- Initial state -->
                            <div id="importWelcome" style="
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                                justify-content: center;
                                height: 300px;
                                color: #9ca3af;
                                text-align: center;
                            ">
                                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom: 16px; opacity: 0.5;">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                    <polyline points="16,10 12,6 8,10"/>
                                    <line x1="12" x2="12" y1="6" y2="14"/>
                                </svg>
                                <h3 style="margin: 0 0 8px 0; font-size: 18px; color: #6b7280;">Várjuk az adatokat...</h3>
                                <p style="margin: 0; font-size: 14px; max-width: 400px;">
                                    Illeszd be a táblázat tartalmát vagy válassz ki egy fájlt. 
                                    Az import automatikusan felismeri a formátumot!
                                </p>
                            </div>

                            <!-- Preview table will be inserted here -->
                            <div id="importPreviewTable" style="display: none;">
                                <!-- Dynamic content -->
                            </div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div id="importActions" style="
                        display: none;
                        padding: 20px 32px;
                        border-top: 1px solid rgba(226, 232, 240, 0.8);
                        background: rgba(249, 250, 251, 0.8);
                        gap: 12px;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span id="importCount" style="font-size: 14px; color: #374151; font-weight: 600;"></span>
                            <button onclick="clearImportPreview()" style="
                                background: none; border: 1px solid #d1d5db; color: #6b7280;
                                padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;
                            ">Törlés</button>
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <button onclick="closeImportModal()" style="
                                background: #e5e7eb; color: #374151; border: none;
                                padding: 12px 24px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;
                            ">Mégse</button>
                            <button id="confirmImportBtn" onclick="confirmImport()" style="
                                background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: white; border: none;
                                padding: 12px 24px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;
                            ">Importálás</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add click outside to close
            importModal.onclick = function(e) {
                if (e.target === importModal) {
                    closeImportModal();
                }
            };
            
            document.body.appendChild(importModal);
            console.log('✅ Import modal displayed successfully!');
        }

        // Close import modal function
        function closeImportModal() {
            const modal = document.getElementById('importModal');
            if (modal) {
                document.body.removeChild(modal);
            }
        }

        // Smart paste handler - intelligens beillesztés kezelése
        function handleSmartPaste(event) {
            console.log('🔥 Smart paste triggered');
            event.preventDefault();
            
            const clipboardData = event.clipboardData || window.clipboardData;
            const types = Array.from(clipboardData.types);
            console.log('📋 Available clipboard types:', types);
            
            let parsedData = [];
            
            // Próbáljuk meg a különböző formátumokat
            if (types.includes('text/html')) {
                // HTML tábla (Word, Google Docs)
                const htmlData = clipboardData.getData('text/html');
                console.log('🌐 HTML content found');
                parsedData = parseHTMLTable(htmlData);
            } else if (types.includes('text/tab-separated-values') || types.includes('text/plain')) {
                // Tab-separated values (Excel, Google Sheets)
                const textData = clipboardData.getData('text/plain');
                console.log('📊 Plain text content found');
                parsedData = parseTabSeparatedData(textData);
            }
            
            if (parsedData.length > 0) {
                window.importPreviewData = parsedData;
                updateImportPreview();
                
                // Clear the paste area content after processing
                document.getElementById('smartPasteArea').innerHTML = '';
            }
        }

        // Handle manual input in paste area
        function handlePasteInput(event) {
            const content = event.target.textContent.trim();
            if (content) {
                console.log('✏️ Manual input detected');
                const parsedData = parseManualInput(content);
                if (parsedData.length > 0) {
                    window.importPreviewData = parsedData;
                    updateImportPreview();
                }
            } else {
                clearImportPreview();
            }
        }

        // Parse HTML table from Word/Google Docs
        function parseHTMLTable(htmlContent) {
            console.log('🔍 Parsing HTML table...');
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const rows = doc.querySelectorAll('tr');
            
            const result = [];
            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('td, th');
                if (cells.length >= 2) {
                    const front = cells[0].textContent.trim();
                    const back = cells[1].textContent.trim();
                    if (front && back) {
                        result.push({ front, back });
                    }
                }
            });
            
            console.log('✅ HTML parsing result:', result.length, 'pairs');
            return result;
        }

        // Parse tab-separated data from Excel/Google Sheets
        function parseTabSeparatedData(textContent) {
            console.log('🔍 Parsing tab-separated data...');
            const lines = textContent.split('\n').filter(line => line.trim());
            const result = [];
            
            lines.forEach((line, index) => {
                // Try tab-separated first, then comma-separated
                let parts = line.split('\t');
                if (parts.length < 2) {
                    parts = line.split(',');
                }
                
                if (parts.length >= 2) {
                    const front = parts[0].trim();
                    const back = parts[1].trim();
                    if (front && back) {
                        result.push({ front, back });
                    }
                }
            });
            
            console.log('✅ Tab-separated parsing result:', result.length, 'pairs');
            return result;
        }

        // Parse manual input (CSV-like)
        function parseManualInput(content) {
            console.log('🔍 Parsing manual input...');
            const lines = content.split('\n').filter(line => line.trim());
            const result = [];
            
            lines.forEach(line => {
                // Support various separators
                let parts = line.split(',');
                if (parts.length < 2) parts = line.split(';');
                if (parts.length < 2) parts = line.split('\t');
                if (parts.length < 2) parts = line.split('|');
                
                if (parts.length >= 2) {
                    const front = parts[0].trim().replace(/["']/g, '');
                    const back = parts[1].trim().replace(/["']/g, '');
                    if (front && back) {
                        result.push({ front, back });
                    }
                }
            });
            
            console.log('✅ Manual input parsing result:', result.length, 'pairs');
            return result;
        }

        // Handle file import
        async function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log('📁 File import:', file.name, file.type);
            
            try {
                let content = '';
                if (file.type === 'text/csv' || file.name.endsWith('.csv') || file.name.endsWith('.txt')) {
                    content = await file.text();
                    const parsedData = parseManualInput(content);
                    window.importPreviewData = parsedData;
                    updateImportPreview();
                } else {
                    alert('Jelenleg csak CSV és TXT fájlok támogatottak. Excel support hamarosan!');
                }
            } catch (error) {
                console.error('File parsing error:', error);
                alert('Hiba történt a fájl olvasásakor: ' + error.message);
            }
        }

        // Update import preview table
        function updateImportPreview() {
            const data = window.importPreviewData || [];
            const welcomeDiv = document.getElementById('importWelcome');
            const previewDiv = document.getElementById('importPreviewTable');
            const actionsDiv = document.getElementById('importActions');
            
            if (data.length === 0) {
                welcomeDiv.style.display = 'flex';
                previewDiv.style.display = 'none';
                actionsDiv.style.display = 'none';
                return;
            }
            
            welcomeDiv.style.display = 'none';
            previewDiv.style.display = 'block';
            actionsDiv.style.display = 'flex';
            
            // Generate preview table
            const tableHTML = `
                <div style="padding: 24px 32px;">
                    <div style="margin-bottom: 16px;">
                        <h3 style="margin: 0 0 8px 0; color: #374151; font-size: 18px; font-weight: 600;">
                            📋 Import előnézet
                        </h3>
                        <p style="margin: 0; color: #6b7280; font-size: 14px;">
                            ${data.length} kártya importálásra kész
                        </p>
                    </div>
                    
                    <!-- Header -->
                    <div style="
                        display: grid;
                        grid-template-columns: 50px 1fr 1fr;
                        gap: 16px;
                        padding: 12px 16px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border-radius: 8px 8px 0 0;
                        font-weight: 600;
                        font-size: 14px;
                    ">
                        <div>#</div>
                        <div>Magyar</div>
                        <div>Angol</div>
                    </div>
                    
                    <!-- Data rows -->
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #e5e7eb; border-top: none;">
                        ${data.map((item, index) => `
                            <div style="
                                display: grid;
                                grid-template-columns: 50px 1fr 1fr;
                                gap: 16px;
                                padding: 12px 16px;
                                border-bottom: 1px solid rgba(226, 232, 240, 0.5);
                                background: ${index % 2 === 0 ? 'rgba(249, 250, 251, 0.5)' : 'white'};
                                align-items: center;
                            ">
                                <div style="font-weight: 600; color: #6b7280;">${index + 1}</div>
                                <div style="font-weight: 500; color: #374151;">${item.front}</div>
                                <div style="color: #6b7280;">${item.back}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            previewDiv.innerHTML = tableHTML;
            
            // Update count
            document.getElementById('importCount').textContent = `${data.length} kártya importálásra kész`;
        }

        // Clear import preview
        function clearImportPreview() {
            window.importPreviewData = [];
            document.getElementById('smartPasteArea').innerHTML = '';
            document.getElementById('smartFileInput').value = '';
            updateImportPreview();
        }

        // Confirm import
        async function confirmImport() {
            const data = window.importPreviewData || [];
            const setId = window.currentImportSetId;
            
            if (data.length === 0) {
                alert('Nincsenek importálandó adatok!');
                return;
            }
            
            const confirmBtn = document.getElementById('confirmImportBtn');
            const originalText = confirmBtn.textContent;
            
            try {
                confirmBtn.textContent = 'Ellenőrzés...';
                confirmBtn.disabled = true;
                
                console.log('🔍 Checking for duplicates in set:', setId);
                
                // Lekérjük a szett meglévő kártyáit duplikáció ellenőrzéshez
                const { data: existingCards, error: fetchError } = await supabase
                    .from('flashcard_set_cards')
                    .select(`
                        cards (
                            title, english_title
                        )
                    `)
                    .eq('set_id', setId);
                
                if (fetchError) {
                    console.error('Error fetching existing cards:', fetchError);
                    throw fetchError;
                }
                
                // Meglévő kártyák listája
                const existingPairs = existingCards?.map(item => ({
                    title: item.cards.title,
                    english_title: item.cards.english_title
                })) || [];
                
                console.log('📋 Found', existingPairs.length, 'existing cards in set');
                
                // Duplikációk szűrése
                const uniqueData = data.filter(item => {
                    const isDuplicate = existingPairs.some(existing => 
                        existing.title === item.front && existing.english_title === item.back
                    );
                    
                    if (isDuplicate) {
                        console.log('⚠️ Skipping duplicate:', item.front, '-', item.back);
                    }
                    
                    return !isDuplicate;
                });
                
                const duplicateCount = data.length - uniqueData.length;
                
                if (duplicateCount > 0) {
                    const message = `${duplicateCount} duplikált kártya kihagyva.\n${uniqueData.length} új kártya importálásra kész.`;
                    if (!confirm(message + '\n\nFolytatjuk az importálást?')) {
                        confirmBtn.textContent = originalText;
                        confirmBtn.disabled = false;
                        return;
                    }
                }
                
                if (uniqueData.length === 0) {
                    alert('Minden kártya már létezik ebben a szettben. Nincs mit importálni.');
                    confirmBtn.textContent = originalText;
                    confirmBtn.disabled = false;
                    return;
                }
                
                confirmBtn.textContent = 'Importálás...';
                console.log('🚀 Starting import of', uniqueData.length, 'unique cards');
                
                for (const item of uniqueData) {
                    // Create card
                    const { data: newCard, error: cardError } = await supabase
                        .from('cards')
                        .insert({
                            title: item.front,
                            english_title: item.back,
                            title_formatted: item.front,
                            english_title_formatted: item.back,
                            image_url: '',
                            category_id: null, // TODO: Set proper category ID
                            difficulty_level: 1,
                            media_type: 'text',
                            media_url: null,
                            set_id: window.currentImportSetId
                        })
                        .select()
                        .single();
                    
                    if (cardError) throw cardError;
                    
                    // Link to set
                    const { error: linkError } = await supabase
                        .from('flashcard_set_cards')
                        .insert({
                            set_id: setId,
                            card_id: newCard.id,
                            position: data.indexOf(item) + 1
                        });
                    
                    if (linkError) throw linkError;
                }
                
                // Success
                closeImportModal();
                
                // Show success message
                setTimeout(() => {
                    const successDiv = document.createElement('div');
                    successDiv.innerHTML = `🎉 ${uniqueData.length} kártya sikeresen importálva!`;
                    successDiv.style.cssText = `
                        position: fixed; top: 20px; right: 20px; z-index: 10001;
                        background: #22c55e; color: white; padding: 16px 24px;
                        border-radius: 8px; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        font-size: 16px;
                    `;
                    document.body.appendChild(successDiv);
                    setTimeout(() => document.body.removeChild(successDiv), 3000);
                }, 100);
                
                // Refresh dashboard - reload page to show new cards
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
                
            } catch (error) {
                console.error('Import error:', error);
                alert('Hiba történt az importálás során: ' + error.message);
                
                confirmBtn.textContent = originalText;
                confirmBtn.disabled = false;
            }
        }

        async function leaveSet(setId) {
            closeAllDropdowns();
            
            const set = dashboardData.joinedSets.find(s => s.id === setId);
            if (!set) {
                showErrorMessage('Szett nem található!');
                return;
            }

            const confirmLeave = confirm(
                'Biztosan el szeretnéd hagyni a "' + set.title + '" szettet?\n\n' +
                `Ez a következőket jelenti:\n` +
                `• A szett eltűnik a dashboard-odról\n` +
                `• A tanulási előrehaladásod megmarad\n` +
                `• Később újra csatlakozhatss, ha a szett nyilvános\n\n` +
                `Folytatod?`
            );

            if (!confirmLeave) {
                return;
            }

            try {
                // For public sets, we just need to delete user progress to "leave"
                // (since public sets are automatically "joined" when they appear)
                const { error } = await supabase
                    .from('user_card_progress')
                    .delete()
                    .eq('set_id', setId)
                    .eq('user_id', currentUser.id);

                if (error) {
                    throw error;
                }

                showSuccessMessage('"' + set.title + '" szett sikeresen elhagyva!');
                
                // Reload dashboard data
                await loadDashboardData();

            } catch (error) {
                console.error('Error leaving set:', error);
                showErrorMessage('Hiba történt a szett elhagyásakor: ' + error.message);
            }
        }

        function acceptInvitation(invitationId) {
            // TODO: Implement invitations system in future update
            showInfoMessage('A meghívó rendszer hamarosan elérhető lesz!');
        }

        function declineInvitation(invitationId) {
            // TODO: Implement invitations system in future update  
            showInfoMessage('A meghívó rendszer hamarosan elérhető lesz!');
        }

        // Info message function
        function showInfoMessage(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
                color: white;
                padding: 16px 24px;
                border-radius: 16px;
                box-shadow: 0 8px 32px rgba(59, 130, 246, 0.4);
                z-index: 10000;
                font-weight: 600;
                animation: slideInRight 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        async function logout() {
            try {
                const { error } = await supabase.auth.signOut();
                if (error) throw error;
                
                window.location.href = '/index.html';
            } catch (error) {
                console.error('Error logging out:', error);
                alert('Hiba a kilépés során');
            }
        }

        // Make functions globally accessible for onclick events
        window.createNewSet = createNewSet;
        window.toggleUserMenu = toggleUserMenu;
        window.openSettingsModal = openSettingsModal;
        window.filterLearningLanguages = filterLearningLanguages;
        window.showLearningLanguageOptions = showLearningLanguageOptions;
        window.hideLearningLanguageOptions = hideLearningLanguageOptions;
        window.addLearningLanguage = addLearningLanguage;
        window.removeLearningLanguage = removeLearningLanguage;
        window.loadCurrentUILanguage = loadCurrentUILanguage;
        window.toggleUILanguageDropdown = toggleUILanguageDropdown;
        window.loadUILanguageOptions = loadUILanguageOptions;
        window.showUILanguageOptions = showUILanguageOptions;
        window.hideUILanguageOptions = hideUILanguageOptions;
        window.selectUILanguage = selectUILanguage;
        window.detectBrowserLanguageForUI = detectBrowserLanguageForUI;
        window.saveAllSettings = saveAllSettings;
        window.closeUserMenu = closeUserMenu;
        window.logout = logout;
        window.closeCreateSetModal = closeCreateSetModal;
        window.showSetOptions = showSetOptions;
        window.addCardsToSet = addCardsToSet;
        window.editSet = editSet;
        window.deleteSet = deleteSet;
        window.showCardsList = showCardsList;
        window.importCards = importCards;
        window.closeImportModal = closeImportModal;
        window.handleSmartPaste = handleSmartPaste;
        window.handlePasteInput = handlePasteInput;
        window.handleFileImport = handleFileImport;
        window.clearImportPreview = clearImportPreview;
        window.confirmImport = confirmImport;
        window.leaveSet = leaveSet;
        window.filterOwnSets = filterOwnSets;
        window.debounceFilterOwnSets = debounceFilterOwnSets;
        window.clearOwnSetsSearch = clearOwnSetsSearch;
        window.onSearchModeChange = onSearchModeChange;
        window.filterCardsList = filterCardsList;
        window.clearCardsListSearch = clearCardsListSearch;
        window.sortCardsList = sortCardsList;
        window.exportCardsList = exportCardsList;
        window.startInlineEdit = startInlineEdit;
        window.handleInlineEditKeydown = handleInlineEditKeydown;
        window.saveInlineEdit = saveInlineEdit;
        window.cancelInlineEdit = cancelInlineEdit;
        window.restoreNormalView = restoreNormalView;
        window.autoResizeTextarea = autoResizeTextarea;
        window.deleteCardFromList = deleteCardFromList;
        window.cancelDeleteCard = cancelDeleteCard;
        window.confirmDeleteCard = confirmDeleteCard;
        window.deleteUploadedImage = deleteUploadedImage;
        window.approveCard = approveCard;
        window.clearForm = clearForm;
        window.closeAddCardsModal = closeAddCardsModal;
        window.closeModal = closeModal;
        window.acceptInvitation = acceptInvitation;
        window.declineInvitation = declineInvitation;
        window.selectEditTag = selectEditTag;
        window.removeEditTag = removeEditTag;
        window.selectTag = selectTag;
        window.handleCreateTagInput = handleCreateTagInput;
        window.handleCreateTagKeydown = handleCreateTagKeydown;
        window.selectCreateTag = selectCreateTag;
        window.addCreateTag = addCreateTag;
        window.removeCreateTag = removeCreateTag;
        window.handleTagFilterInput = handleTagFilterInput;
        window.handleTagFilterKeydown = handleTagFilterKeydown;
        window.selectTagFilter = selectTagFilter;
        window.addTagFilter = addTagFilter;
        window.removeTagFilter = removeTagFilter;
        window.clearTagFilters = clearTagFilters;
        window.openSet = openSet;
        window.openSlotMachineModal = openSlotMachineModal;
        window.closeSlotMachineModal = closeSlotMachineModal;
        window.handleFeedback = handleFeedback;
        window.openTagManagerModal = openTagManagerModal;
        window.createNewTag = createNewTag;
        window.loadExistingTags = loadExistingTags;
        window.deleteTag = deleteTag;
        window.openEditCardModal = openEditCardModal;
        window.saveEditedCard = saveEditedCard;
        window.closeEditCardModal = closeEditCardModal;
        window.generateEditCardForm = generateEditCardForm;

        // SlotMachine functionality
        let slotMachineData = {
            currentSetId: null,
            currentCards: [],
            currentCardIndex: 0,
            statistics: {
                correct: 0,
                uncertain: 0,
                learning: 0,
                progress: 0,
                startTime: null,
                totalResponseTime: 0,
                responses: 0
            },
            timer: null
        };

        async function openSlotMachineModal(setId, type) {
            console.log('DEBUG: Opening SlotMachine modal for set:', setId);
            
            try {
                // Show modal
                const modal = document.getElementById('slotMachineModal');
                modal.style.display = 'flex';
                modal.classList.add('active');
                
                // Initialize SlotMachine
                await initSlotMachine(setId, type);
                
            } catch (error) {
                console.error('Error opening SlotMachine modal:', error);
                alert('Hiba történt a tanulási felület betöltése során.');
            }
        }

        async function initSlotMachine(setId, type) {
            slotMachineData.currentSetId = setId;
            slotMachineData.statistics.startTime = Date.now();
            
            try {
                // Get set details
                const { data: setData, error: setError } = await supabase
                    .from('flashcard_sets')
                    .select('title')
                    .eq('id', setId)
                    .single();

                if (setError) throw setError;

                // Update modal title
                document.getElementById('slotMachineTitle').textContent = 'Tanulás: ' + setData.title + '';

                // Load cards for this set
                await loadSlotMachineCards(setId);
                
                // Start timer
                startSlotMachineTimer();
                
                // Show first 3 cards
                showNextCards();
                
            } catch (error) {
                console.error('Error initializing SlotMachine:', error);
                throw error;
            }
        }

        async function loadSlotMachineCards(setId) {
            try {
                const { data: flashcardSetCards, error } = await supabase
                    .from('flashcard_set_cards')
                    .select(`
                        cards (
                            id,
                            title,
                            english_title,
                            title_formatted,
                            english_title_formatted,
                            media_url,
                            media_type
                        )
                    `)
                    .eq('set_id', setId)
                    .order('position', { ascending: true });

                if (error) throw error;

                const cards = flashcardSetCards?.map(item => item.cards).filter(Boolean) || [];
                slotMachineData.currentCards = cards;
                slotMachineData.currentCardIndex = 0;
                
                console.log('DEBUG: Loaded ' + slotMachineData.currentCards.length + ' cards for SlotMachine');
                
                // Check if no cards exist
                if (slotMachineData.currentCards.length === 0) {
                    alert('Ehhez a szetthez még nincsenek kártyák hozzáadva! Kérlek adj hozzá kártyákat a tanulás megkezdése előtt.');
                    closeSlotMachineModal();
                    return;
                }
                
            } catch (error) {
                console.error('Error loading cards for SlotMachine:', error);
                throw error;
            }
        }

        function showNextCards() {
            const cards = slotMachineData.currentCards;
            const startIndex = slotMachineData.currentCardIndex;
            
            // Show spinning animation first
            for (let i = 1; i <= 3; i++) {
                const card = document.getElementById('studyCard' + i + '');
                card.classList.add('spinning');
            }
            
            // After animation, show new cards
            setTimeout(() => {
                for (let i = 1; i <= 3; i++) {
                    const cardIndex = startIndex + (i - 1);
                    const termElement = document.getElementById('cardTerm' + i + '');
                    const defElement = document.getElementById('cardDef' + i + '');
                    const cardElement = document.getElementById('studyCard' + i + '');
                    
                    if (cardIndex < cards.length) {
                        const card = cards[cardIndex];
                        termElement.textContent = card.term;
                        defElement.textContent = card.definition;
                        cardElement.style.opacity = '1';
                    } else {
                        termElement.textContent = 'Vége';
                        defElement.textContent = 'Összes kártya elvégezve!';
                        cardElement.style.opacity = '0.5';
                    }
                    
                    // Remove spinning animation
                    cardElement.classList.remove('spinning');
                }
                
                // Update progress
                updateProgress();
                
            }, 1500); // Match animation duration
        }

        function handleFeedback(type) {
            console.log('DEBUG: Feedback received: ' + type);
            
            // Record response time
            if (slotMachineData.statistics.startTime) {
                const responseTime = Date.now() - slotMachineData.statistics.startTime;
                slotMachineData.statistics.totalResponseTime += responseTime;
                slotMachineData.statistics.responses++;
                updateSpeedStat();
            }
            
            // Update statistics
            slotMachineData.statistics[type]++;
            updateStatistics();
            
            // Move to next set of cards
            slotMachineData.currentCardIndex += 3;
            
            // Check if we have more cards
            if (slotMachineData.currentCardIndex < slotMachineData.currentCards.length) {
                // Wait 2 seconds, then show next cards
                setTimeout(() => {
                    slotMachineData.statistics.startTime = Date.now(); // Reset timer for next cards
                    showNextCards();
                }, 2000);
            } else {
                // Session complete
                showSessionComplete();
            }
        }

        function updateStatistics() {
            const stats = slotMachineData.statistics;
            document.getElementById('statCorrect').textContent = stats.correct;
            document.getElementById('statUncertain').textContent = stats.uncertain;
            document.getElementById('statLearning').textContent = stats.learning;
        }

        function updateProgress() {
            const totalCards = slotMachineData.currentCards.length;
            const currentIndex = slotMachineData.currentCardIndex;
            const progress = Math.round((currentIndex / totalCards) * 100);
            document.getElementById('statProgress').textContent = '' + progress + '%';
        }

        function updateSpeedStat() {
            const avgTime = slotMachineData.statistics.totalResponseTime / slotMachineData.statistics.responses;
            const avgSeconds = (avgTime / 1000).toFixed(1);
            document.getElementById('statSpeed').textContent = '' + avgSeconds + 's';
        }

        function startSlotMachineTimer() {
            let startTime = Date.now();
            
            slotMachineData.timer = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('statTime').textContent = 
                    minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
            }, 1000);
        }

        function showSessionComplete() {
            // Stop timer
            if (slotMachineData.timer) {
                clearInterval(slotMachineData.timer);
            }
            
            // Show completion message
            const stats = slotMachineData.statistics;
            alert('Tanulási munkamenet befejezve!\n\nStatisztikák:\n• Tudom: ' + stats.correct + '\n• Bizonytalan: ' + stats.uncertain + '\n• Tanulandó: ' + stats.learning);
            
            // Close modal
            closeSlotMachineModal();
        }

        function closeSlotMachineModal() {
            // Stop timer
            if (slotMachineData.timer) {
                clearInterval(slotMachineData.timer);
            }
            
            // Hide modal
            const modal = document.getElementById('slotMachineModal');
            modal.classList.remove('active');
            setTimeout(() => {
                modal.style.display = 'none';
            }, 300); // Wait for transition
            
            // Reset data
            slotMachineData = {
                currentSetId: null,
                currentCards: [],
                currentCardIndex: 0,
                statistics: {
                    correct: 0,
                    uncertain: 0,
                    learning: 0,
                    progress: 0,
                    startTime: null,
                    totalResponseTime: 0,
                    responses: 0
                },
                timer: null
            };
        }

        // DEBUG: Initialize without events first
        console.log('DEBUG: Script loaded, waiting for DOM...');
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DEBUG: DOM loaded, calling initDashboard...');
            initDashboard();
            
            // Add event listener for user avatar
            const userAvatar = document.getElementById('userAvatar');
            if (userAvatar) {
                userAvatar.addEventListener('click', toggleUserMenu);
            }
            
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
                console.log('✅ Lucide icons initialized');
            }
        });

        // 🔄 AUTO-REFRESH: Frissítés amikor visszatérnek a dashboard-ra
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                console.log('🔄🔄🔄 DASHBOARD ÚJRA AKTÍV - FRISSÍTÉS KEZDŐDIK! 🔄🔄🔄');
                loadDashboardData();
            }
        });

        // 🔄 FOCUS-REFRESH: Frissítés amikor az ablak fókuszba kerül
        window.addEventListener('focus', () => {
            console.log('🔄 Ablak fókuszba került - frissítés...');
            loadDashboardData();
        });


    </script>

    <!-- Modal Container -->
    <div id="modalContainer" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10000;"></div>
        
        <!-- Dedicated Edit Card Modal Container -->
        <div id="editCardModalContainer" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 20000; background: rgba(0, 0, 0, 0.5);"></div>

</body>
</html>